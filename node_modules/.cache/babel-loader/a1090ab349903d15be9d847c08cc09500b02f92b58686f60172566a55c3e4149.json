{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines the {@linkplain Driver WebDriver} client for Firefox.\n * Before using this module, you must download the latest\n * [geckodriver release] and ensure it can be found on your system [PATH].\n *\n * Each FirefoxDriver instance will be created with an anonymous profile,\n * ensuring browser historys do not share session data (cookies, history, cache,\n * offline storage, etc.)\n *\n * __Customizing the Firefox Profile__\n *\n * The profile used for each WebDriver session may be configured using the\n * {@linkplain Options} class. For example, you may install an extension, like\n * Firebug:\n *\n *     const {Builder} = require('selenium-webdriver');\n *     const firefox = require('selenium-webdriver/firefox');\n *\n *     let options = new firefox.Options()\n *         .addExtensions('/path/to/firebug.xpi')\n *         .setPreference('extensions.firebug.showChromeErrors', true);\n *\n *     let driver = new Builder()\n *         .forBrowser('firefox')\n *         .setFirefoxOptions(options)\n *         .build();\n *\n * The {@linkplain Options} class may also be used to configure WebDriver based\n * on a pre-existing browser profile:\n *\n *     let profile = '/usr/local/home/bob/.mozilla/firefox/3fgog75h.testing';\n *     let options = new firefox.Options().setProfile(profile);\n *\n * The FirefoxDriver will _never_ modify a pre-existing profile; instead it will\n * create a copy for it to modify. By extension, there are certain browser\n * preferences that are required for WebDriver to function properly and they\n * will always be overwritten.\n *\n * __Using a Custom Firefox Binary__\n *\n * On Windows and MacOS, the FirefoxDriver will search for Firefox in its\n * default installation location:\n *\n * - Windows: C:\\Program Files and C:\\Program Files (x86).\n * - MacOS: /Applications/Firefox.app\n *\n * For Linux, Firefox will always be located on the PATH: `$(where firefox)`.\n *\n * Several methods are provided for starting Firefox with a custom executable.\n * First, on Windows and MacOS, you may configure WebDriver to check the default\n * install location for a non-release channel. If the requested channel cannot\n * be found in its default location, WebDriver will fallback to searching your\n * PATH. _Note:_ on Linux, Firefox is _always_ located on your path, regardless\n * of the requested channel.\n *\n *     const {Builder} = require('selenium-webdriver');\n *     const firefox = require('selenium-webdriver/firefox');\n *\n *     let options = new firefox.Options().setBinary(firefox.Channel.NIGHTLY);\n *     let driver = new Builder()\n *         .forBrowser('firefox')\n *         .setFirefoxOptions(options)\n *         .build();\n *\n * On all platforms, you may configure WebDriver to use a Firefox specific\n * executable:\n *\n *     let options = new firefox.Options()\n *         .setBinary('/my/firefox/install/dir/firefox-bin');\n *\n * __Remote Testing__\n *\n * You may customize the Firefox binary and profile when running against a\n * remote Selenium server. Your custom profile will be packaged as a zip and\n * transferred to the remote host for use. The profile will be transferred\n * _once for each new session_. The performance impact should be minimal if\n * you've only configured a few extra browser preferences. If you have a large\n * profile with several extensions, you should consider installing it on the\n * remote host and defining its path via the {@link Options} class. Custom\n * binaries are never copied to remote machines and must be referenced by\n * installation path.\n *\n *     const {Builder} = require('selenium-webdriver');\n *     const firefox = require('selenium-webdriver/firefox');\n *\n *     let options = new firefox.Options()\n *         .setProfile('/profile/path/on/remote/host')\n *         .setBinary('/install/dir/on/remote/host/firefox-bin');\n *\n *     let driver = new Builder()\n *         .forBrowser('firefox')\n *         .usingServer('http://127.0.0.1:4444/wd/hub')\n *         .setFirefoxOptions(options)\n *         .build();\n *\n * [geckodriver release]: https://github.com/mozilla/geckodriver/releases/\n * [PATH]: http://en.wikipedia.org/wiki/PATH_%28variable%29\n */\n\n'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst Symbols = require('./lib/symbols');\nconst command = require('./lib/command');\nconst http = require('./http');\nconst io = require('./io');\nconst remote = require('./remote');\nconst webdriver = require('./lib/webdriver');\nconst zip = require('./io/zip');\nconst {\n  Browser,\n  Capabilities\n} = require('./lib/capabilities');\nconst {\n  Zip\n} = require('./io/zip');\nconst {\n  getPath\n} = require('./common/driverFinder');\n\n/**\n * Thrown when there an add-on is malformed.\n * @final\n */\nclass AddonFormatError extends Error {\n  /** @param {string} msg The error message. */\n  constructor(msg) {\n    super(msg);\n    /** @override */\n    this.name = this.constructor.name;\n  }\n}\n\n/**\n * Installs an extension to the given directory.\n * @param {string} extension Path to the xpi extension file to install.\n * @param {string} dir Path to the directory to install the extension in.\n * @return {!Promise<string>} A promise for the add-on ID once\n *     installed.\n */\nasync function installExtension(extension, dir) {\n  const ext = extension.slice(-4);\n  if (ext !== '.xpi' && ext !== '.zip') {\n    throw Error('File name does not end in \".zip\" or \".xpi\": ' + ext);\n  }\n  let archive = await zip.load(extension);\n  if (!archive.has('manifest.json')) {\n    throw new AddonFormatError(`Couldn't find manifest.json in ${extension}`);\n  }\n  let buf = await archive.getFile('manifest.json');\n  let parsedJSON = JSON.parse(buf.toString('utf8'));\n  let {\n    browser_specific_settings\n  } = /** @type {{browser_specific_settings:{gecko:{id:string}}}} */\n  parsedJSON;\n  if (browser_specific_settings && browser_specific_settings.gecko) {\n    /* browser_specific_settings is an alternative to applications\n     * It is meant to facilitate cross-browser plugins since Firefox48\n     * see https://bugzilla.mozilla.org/show_bug.cgi?id=1262005\n     */\n    parsedJSON.applications = browser_specific_settings;\n  }\n  let {\n    applications\n  } = /** @type {{applications:{gecko:{id:string}}}} */\n  parsedJSON;\n  if (!(applications && applications.gecko && applications.gecko.id)) {\n    throw new AddonFormatError(`Could not find add-on ID for ${extension}`);\n  }\n  await io.copy(extension, `${path.join(dir, applications.gecko.id)}.xpi`);\n  return applications.gecko.id;\n}\nclass Profile {\n  constructor() {\n    /** @private {?string} */\n    this.template_ = null;\n\n    /** @private {!Array<string>} */\n    this.extensions_ = [];\n  }\n  addExtensions( /** !Array<string> */paths) {\n    this.extensions_ = this.extensions_.concat(...paths);\n  }\n\n  /**\n   * @return {(!Promise<string>|undefined)} a promise for a base64 encoded\n   *     profile, or undefined if there's no data to include.\n   */\n  [Symbols.serialize]() {\n    if (this.template_ || this.extensions_.length) {\n      return buildProfile(this.template_, this.extensions_);\n    }\n    return undefined;\n  }\n}\n\n/**\n * @param {?string} template path to an existing profile to use as a template.\n * @param {!Array<string>} extensions paths to extensions to install in the new\n *     profile.\n * @return {!Promise<string>} a promise for the base64 encoded profile.\n */\nasync function buildProfile(template, extensions) {\n  let dir = template;\n  if (extensions.length) {\n    dir = await io.tmpDir();\n    if (template) {\n      await io.copyDir( /** @type {string} */template, dir, /(parent\\.lock|lock|\\.parentlock)/);\n    }\n    const extensionsDir = path.join(dir, 'extensions');\n    await io.mkdir(extensionsDir);\n    for (let i = 0; i < extensions.length; i++) {\n      await installExtension(extensions[i], extensionsDir);\n    }\n  }\n  let zip = new Zip();\n  return zip.addDir(dir).then(() => zip.toBuffer()).then(buf => buf.toString('base64'));\n}\n\n/**\n * Configuration options for the FirefoxDriver.\n */\nclass Options extends Capabilities {\n  /**\n   * @param {(Capabilities|Map<string, ?>|Object)=} other Another set of\n   *     capabilities to initialize this instance from.\n   */\n  constructor(other) {\n    super(other);\n    this.setBrowserName(Browser.FIREFOX);\n  }\n\n  /**\n   * @return {!Object}\n   * @private\n   */\n  firefoxOptions_() {\n    let options = this.get('moz:firefoxOptions');\n    if (!options) {\n      options = {};\n      this.set('moz:firefoxOptions', options);\n    }\n    return options;\n  }\n\n  /**\n   * @return {!Profile}\n   * @private\n   */\n  profile_() {\n    let options = this.firefoxOptions_();\n    if (!options.profile) {\n      options.profile = new Profile();\n    }\n    return options.profile;\n  }\n\n  /**\n   * Specify additional command line arguments that should be used when starting\n   * the Firefox browser.\n   *\n   * @param {...(string|!Array<string>)} args The arguments to include.\n   * @return {!Options} A self reference.\n   */\n  addArguments() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (args.length) {\n      let options = this.firefoxOptions_();\n      options.args = options.args ? options.args.concat(...args) : args;\n    }\n    return this;\n  }\n\n  /**\n   * @deprecated Use {@link Options#addArguments} instead.\n   * @example\n   * options.addArguments('-headless');\n   * @example\n   * Configures the geckodriver to start Firefox in headless mode.\n   *\n   * @return {!Options} A self reference.\n   */\n  headless() {\n    return this.addArguments('-headless');\n  }\n\n  /**\n   * Sets the initial window size when running in\n   * {@linkplain #headless headless} mode.\n   *\n   * @param {{width: number, height: number}} size The desired window size.\n   * @return {!Options} A self reference.\n   * @throws {TypeError} if width or height is unspecified, not a number, or\n   *     less than or equal to 0.\n   */\n  windowSize(_ref) {\n    let {\n      width,\n      height\n    } = _ref;\n    function checkArg(arg) {\n      if (typeof arg !== 'number' || arg <= 0) {\n        throw TypeError('Arguments must be {width, height} with numbers > 0');\n      }\n    }\n    checkArg(width);\n    checkArg(height);\n    return this.addArguments(`--width=${width}`, `--height=${height}`);\n  }\n\n  /**\n   * Add extensions that should be installed when starting Firefox.\n   *\n   * @param {...string} paths The paths to the extension XPI files to install.\n   * @return {!Options} A self reference.\n   */\n  addExtensions() {\n    for (var _len2 = arguments.length, paths = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      paths[_key2] = arguments[_key2];\n    }\n    this.profile_().addExtensions(paths);\n    return this;\n  }\n\n  /**\n   * @param {string} key the preference key.\n   * @param {(string|number|boolean)} value the preference value.\n   * @return {!Options} A self reference.\n   * @throws {TypeError} if either the key or value has an invalid type.\n   */\n  setPreference(key, value) {\n    if (typeof key !== 'string') {\n      throw TypeError(`key must be a string, but got ${typeof key}`);\n    }\n    if (typeof value !== 'string' && typeof value !== 'number' && typeof value !== 'boolean') {\n      throw TypeError(`value must be a string, number, or boolean, but got ${typeof value}`);\n    }\n    let options = this.firefoxOptions_();\n    options.prefs = options.prefs || {};\n    options.prefs[key] = value;\n    return this;\n  }\n\n  /**\n   * Sets the path to an existing profile to use as a template for new browser\n   * sessions. This profile will be copied for each new session - changes will\n   * not be applied to the profile itself.\n   *\n   * @param {string} profile The profile to use.\n   * @return {!Options} A self reference.\n   * @throws {TypeError} if profile is not a string.\n   */\n  setProfile(profile) {\n    if (typeof profile !== 'string') {\n      throw TypeError(`profile must be a string, but got ${typeof profile}`);\n    }\n    this.profile_().template_ = profile;\n    return this;\n  }\n\n  /**\n   * Sets the binary to use. The binary may be specified as the path to a\n   * Firefox executable or a desired release {@link Channel}.\n   *\n   * @param {(string|!Channel)} binary The binary to use.\n   * @return {!Options} A self reference.\n   * @throws {TypeError} If `binary` is an invalid type.\n   */\n  setBinary(binary) {\n    if (binary instanceof Channel || typeof binary === 'string') {\n      this.firefoxOptions_().binary = binary;\n      return this;\n    }\n    throw TypeError('binary must be a string path or Channel object');\n  }\n\n  /**\n   * Enables Mobile start up features\n   *\n   * @param {string} androidPackage The package to use\n   * @return {!Options} A self reference\n   */\n  enableMobile() {\n    let androidPackage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'org.mozilla.firefox';\n    let androidActivity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let deviceSerial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    this.firefoxOptions_().androidPackage = androidPackage;\n    if (androidActivity) {\n      this.firefoxOptions_().androidActivity = androidActivity;\n    }\n    if (deviceSerial) {\n      this.firefoxOptions_().deviceSerial = deviceSerial;\n    }\n    return this;\n  }\n\n  /**\n   * Enables moz:debuggerAddress for firefox cdp\n   */\n  enableDebugger() {\n    return this.set('moz:debuggerAddress', true);\n  }\n\n  /**\n   * Enable bidi connection\n   * @returns {!Capabilities}\n   */\n  enableBidi() {\n    return this.set('webSocketUrl', true);\n  }\n}\n\n/**\n * Enum of available command contexts.\n *\n * Command contexts are specific to Marionette, and may be used with the\n * {@link #context=} method. Contexts allow you to direct all subsequent\n * commands to either \"content\" (default) or \"chrome\". The latter gives\n * you elevated security permissions.\n *\n * @enum {string}\n */\nconst Context = {\n  CONTENT: 'content',\n  CHROME: 'chrome'\n};\nconst GECKO_DRIVER_EXE = process.platform === 'win32' ? 'geckodriver.exe' : 'geckodriver';\n\n/**\n * _Synchronously_ attempts to locate the geckodriver executable on the current\n * system.\n *\n * @return {?string} the located executable, or `null`.\n */\nfunction locateSynchronously() {\n  return io.findInPath(GECKO_DRIVER_EXE, true);\n}\n\n/**\n * @return {string} .\n * @throws {Error}\n */\nfunction findGeckoDriver() {\n  return locateSynchronously();\n}\n\n/**\n * @param {string} file Path to the file to find, relative to the program files\n *     root.\n * @return {!Promise<?string>} A promise for the located executable.\n *     The promise will resolve to {@code null} if Firefox was not found.\n */\nfunction findInProgramFiles(file) {\n  let files = [process.env['PROGRAMFILES'] || 'C:\\\\Program Files', process.env['PROGRAMFILES(X86)'] || 'C:\\\\Program Files (x86)'].map(prefix => path.join(prefix, file));\n  return io.exists(files[0]).then(function (exists) {\n    return exists ? files[0] : io.exists(files[1]).then(function (exists) {\n      return exists ? files[1] : null;\n    });\n  });\n}\n\n/** @enum {string} */\nconst ExtensionCommand = {\n  GET_CONTEXT: 'getContext',\n  SET_CONTEXT: 'setContext',\n  INSTALL_ADDON: 'install addon',\n  UNINSTALL_ADDON: 'uninstall addon'\n};\n\n/**\n * Creates a command executor with support for Marionette's custom commands.\n * @param {!Promise<string>} serverUrl The server's URL.\n * @return {!command.Executor} The new command executor.\n */\nfunction createExecutor(serverUrl) {\n  let client = serverUrl.then(url => new http.HttpClient(url));\n  let executor = new http.Executor(client);\n  configureExecutor(executor);\n  return executor;\n}\n\n/**\n * Configures the given executor with Firefox-specific commands.\n * @param {!http.Executor} executor the executor to configure.\n */\nfunction configureExecutor(executor) {\n  executor.defineCommand(ExtensionCommand.GET_CONTEXT, 'GET', '/session/:sessionId/moz/context');\n  executor.defineCommand(ExtensionCommand.SET_CONTEXT, 'POST', '/session/:sessionId/moz/context');\n  executor.defineCommand(ExtensionCommand.INSTALL_ADDON, 'POST', '/session/:sessionId/moz/addon/install');\n  executor.defineCommand(ExtensionCommand.UNINSTALL_ADDON, 'POST', '/session/:sessionId/moz/addon/uninstall');\n}\n\n/**\n * Creates {@link selenium-webdriver/remote.DriverService} instances that manage\n * a [geckodriver](https://github.com/mozilla/geckodriver) server in a child\n * process.\n */\nclass ServiceBuilder extends remote.DriverService.Builder {\n  /**\n   * @param {string=} opt_exe Path to the server executable to use. If omitted,\n   *     the builder will attempt to locate the geckodriver on the system PATH.\n   */\n  constructor(opt_exe) {\n    super(opt_exe || findGeckoDriver());\n    this.setLoopback(true); // Required.\n  }\n\n  /**\n   * Enables verbose logging.\n   *\n   * @param {boolean=} opt_trace Whether to enable trace-level logging. By\n   *     default, only debug logging is enabled.\n   * @return {!ServiceBuilder} A self reference.\n   */\n  enableVerboseLogging(opt_trace) {\n    return this.addArguments(opt_trace ? '-vv' : '-v');\n  }\n}\n\n/**\n * A WebDriver client for Firefox.\n */\nclass Driver extends webdriver.WebDriver {\n  /**\n   * Creates a new Firefox session.\n   *\n   * @param {(Options|Capabilities|Object)=} opt_config The\n   *    configuration options for this driver, specified as either an\n   *    {@link Options} or {@link Capabilities}, or as a raw hash object.\n   * @param {(http.Executor|remote.DriverService)=} opt_executor Either a\n   *   pre-configured command executor to use for communicating with an\n   *   externally managed remote end (which is assumed to already be running),\n   *   or the `DriverService` to use to start the geckodriver in a child\n   *   process.\n   *\n   *   If an executor is provided, care should e taken not to use reuse it with\n   *   other clients as its internal command mappings will be updated to support\n   *   Firefox-specific commands.\n   *\n   *   _This parameter may only be used with Mozilla's GeckoDriver._\n   *\n   * @throws {Error} If a custom command executor is provided and the driver is\n   *     configured to use the legacy FirefoxDriver from the Selenium project.\n   * @return {!Driver} A new driver instance.\n   */\n  static createSession(opt_config, opt_executor) {\n    let caps = opt_config instanceof Capabilities ? opt_config : new Options(opt_config);\n    let executor;\n    let onQuit;\n    if (opt_executor instanceof http.Executor) {\n      executor = opt_executor;\n      configureExecutor(executor);\n    } else if (opt_executor instanceof remote.DriverService) {\n      if (!opt_executor.getExecutable()) {\n        opt_executor.setExecutable(getPath(opt_executor, opt_config));\n      }\n      executor = createExecutor(opt_executor.start());\n      onQuit = () => opt_executor.kill();\n    } else {\n      let service = new ServiceBuilder().build();\n      if (!service.getExecutable()) {\n        service.setExecutable(getPath(service, opt_config));\n      }\n      executor = createExecutor(service.start());\n      onQuit = () => service.kill();\n    }\n    return (/** @type {!Driver} */super.createSession(executor, caps, onQuit)\n    );\n  }\n\n  /**\n   * This function is a no-op as file detectors are not supported by this\n   * implementation.\n   * @override\n   */\n  setFileDetector() {}\n\n  /**\n   * Get the context that is currently in effect.\n   *\n   * @return {!Promise<Context>} Current context.\n   */\n  getContext() {\n    return this.execute(new command.Command(ExtensionCommand.GET_CONTEXT));\n  }\n\n  /**\n   * Changes target context for commands between chrome- and content.\n   *\n   * Changing the current context has a stateful impact on all subsequent\n   * commands. The {@link Context.CONTENT} context has normal web\n   * platform document permissions, as if you would evaluate arbitrary\n   * JavaScript. The {@link Context.CHROME} context gets elevated\n   * permissions that lets you manipulate the browser chrome itself,\n   * with full access to the XUL toolkit.\n   *\n   * Use your powers wisely.\n   *\n   * @param {!Promise<void>} ctx The context to switch to.\n   */\n  setContext(ctx) {\n    return this.execute(new command.Command(ExtensionCommand.SET_CONTEXT).setParameter('context', ctx));\n  }\n\n  /**\n   * Installs a new addon with the current session. This function will return an\n   * ID that may later be used to {@linkplain #uninstallAddon uninstall} the\n   * addon.\n   *\n   *\n   * @param {string} path Path on the local filesystem to the web extension to\n   *     install.\n   * @param {boolean} temporary Flag indicating whether the extension should be\n   *     installed temporarily - gets removed on restart\n   * @return {!Promise<string>} A promise that will resolve to an ID for the\n   *     newly installed addon.\n   * @see #uninstallAddon\n   */\n  async installAddon(path) {\n    let temporary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let stats = fs.statSync(path);\n    let buf;\n    if (stats.isDirectory()) {\n      let zip = new Zip();\n      await zip.addDir(path);\n      buf = await zip.toBuffer('DEFLATE');\n    } else {\n      buf = await io.read(path);\n    }\n    return this.execute(new command.Command(ExtensionCommand.INSTALL_ADDON).setParameter('addon', buf.toString('base64')).setParameter('temporary', temporary));\n  }\n\n  /**\n   * Uninstalls an addon from the current browser session's profile.\n   *\n   * @param {(string|!Promise<string>)} id ID of the addon to uninstall.\n   * @return {!Promise} A promise that will resolve when the operation has\n   *     completed.\n   * @see #installAddon\n   */\n  async uninstallAddon(id) {\n    id = await Promise.resolve(id);\n    return this.execute(new command.Command(ExtensionCommand.UNINSTALL_ADDON).setParameter('id', id));\n  }\n}\n\n/**\n * Provides methods for locating the executable for a Firefox release channel\n * on Windows and MacOS. For other systems (i.e. Linux), Firefox will always\n * be located on the system PATH.\n *\n * @final\n */\nclass Channel {\n  /**\n   * @param {string} darwin The path to check when running on MacOS.\n   * @param {string} win32 The path to check when running on Windows.\n   */\n  constructor(darwin, win32) {\n    /** @private @const */this.darwin_ = darwin;\n    /** @private @const */\n    this.win32_ = win32;\n    /** @private {Promise<string>} */\n    this.found_ = null;\n  }\n\n  /**\n   * Attempts to locate the Firefox executable for this release channel. This\n   * will first check the default installation location for the channel before\n   * checking the user's PATH. The returned promise will be rejected if Firefox\n   * can not be found.\n   *\n   * @return {!Promise<string>} A promise for the location of the located\n   *     Firefox executable.\n   */\n  locate() {\n    if (this.found_) {\n      return this.found_;\n    }\n    let found;\n    switch (process.platform) {\n      case 'darwin':\n        found = io.exists(this.darwin_).then(exists => exists ? this.darwin_ : io.findInPath('firefox'));\n        break;\n      case 'win32':\n        found = findInProgramFiles(this.win32_).then(found => found || io.findInPath('firefox.exe'));\n        break;\n      default:\n        found = Promise.resolve(io.findInPath('firefox'));\n        break;\n    }\n    this.found_ = found.then(found => {\n      if (found) {\n        // TODO: verify version info.\n        return found;\n      }\n      throw Error('Could not locate Firefox on the current system');\n    });\n    return this.found_;\n  }\n\n  /** @return {!Promise<string>} */\n  [Symbols.serialize]() {\n    return this.locate();\n  }\n}\n\n/**\n * Firefox's developer channel.\n * @const\n * @see <https://www.mozilla.org/en-US/firefox/channel/desktop/#aurora>\n */\nChannel.AURORA = new Channel('/Applications/FirefoxDeveloperEdition.app/Contents/MacOS/firefox-bin', 'Firefox Developer Edition\\\\firefox.exe');\n\n/**\n * Firefox's beta channel. Note this is provided mainly for convenience as\n * the beta channel has the same installation location as the main release\n * channel.\n * @const\n * @see <https://www.mozilla.org/en-US/firefox/channel/desktop/#beta>\n */\nChannel.BETA = new Channel('/Applications/Firefox.app/Contents/MacOS/firefox-bin', 'Mozilla Firefox\\\\firefox.exe');\n\n/**\n * Firefox's release channel.\n * @const\n * @see <https://www.mozilla.org/en-US/firefox/desktop/>\n */\nChannel.RELEASE = new Channel('/Applications/Firefox.app/Contents/MacOS/firefox-bin', 'Mozilla Firefox\\\\firefox.exe');\n\n/**\n * Firefox's nightly release channel.\n * @const\n * @see <https://www.mozilla.org/en-US/firefox/channel/desktop/#nightly>\n */\nChannel.NIGHTLY = new Channel('/Applications/Firefox Nightly.app/Contents/MacOS/firefox-bin', 'Nightly\\\\firefox.exe');\n\n// PUBLIC API\n\nmodule.exports = {\n  Channel,\n  Context,\n  Driver,\n  Options,\n  ServiceBuilder,\n  locateSynchronously\n};","map":{"version":3,"names":["fs","require","path","Symbols","command","http","io","remote","webdriver","zip","Browser","Capabilities","Zip","getPath","AddonFormatError","Error","constructor","msg","name","installExtension","extension","dir","ext","slice","archive","load","has","buf","getFile","parsedJSON","JSON","parse","toString","browser_specific_settings","gecko","applications","id","copy","join","Profile","template_","extensions_","addExtensions","paths","concat","serialize","length","buildProfile","undefined","template","extensions","tmpDir","copyDir","extensionsDir","mkdir","i","addDir","then","toBuffer","Options","other","setBrowserName","FIREFOX","firefoxOptions_","options","get","set","profile_","profile","addArguments","_len","arguments","args","Array","_key","headless","windowSize","_ref","width","height","checkArg","arg","TypeError","_len2","_key2","setPreference","key","value","prefs","setProfile","setBinary","binary","Channel","enableMobile","androidPackage","androidActivity","deviceSerial","enableDebugger","enableBidi","Context","CONTENT","CHROME","GECKO_DRIVER_EXE","process","platform","locateSynchronously","findInPath","findGeckoDriver","findInProgramFiles","file","files","env","map","prefix","exists","ExtensionCommand","GET_CONTEXT","SET_CONTEXT","INSTALL_ADDON","UNINSTALL_ADDON","createExecutor","serverUrl","client","url","HttpClient","executor","Executor","configureExecutor","defineCommand","ServiceBuilder","DriverService","Builder","opt_exe","setLoopback","enableVerboseLogging","opt_trace","Driver","WebDriver","createSession","opt_config","opt_executor","caps","onQuit","getExecutable","setExecutable","start","kill","service","build","setFileDetector","getContext","execute","Command","setContext","ctx","setParameter","installAddon","temporary","stats","statSync","isDirectory","read","uninstallAddon","Promise","resolve","darwin","win32","darwin_","win32_","found_","locate","found","AURORA","BETA","RELEASE","NIGHTLY","module","exports"],"sources":["/Users/Shared/ATS Git/ATSDemo/ReactJs/ReactCaseStudy/my-app/node_modules/selenium-webdriver/firefox.js"],"sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines the {@linkplain Driver WebDriver} client for Firefox.\n * Before using this module, you must download the latest\n * [geckodriver release] and ensure it can be found on your system [PATH].\n *\n * Each FirefoxDriver instance will be created with an anonymous profile,\n * ensuring browser historys do not share session data (cookies, history, cache,\n * offline storage, etc.)\n *\n * __Customizing the Firefox Profile__\n *\n * The profile used for each WebDriver session may be configured using the\n * {@linkplain Options} class. For example, you may install an extension, like\n * Firebug:\n *\n *     const {Builder} = require('selenium-webdriver');\n *     const firefox = require('selenium-webdriver/firefox');\n *\n *     let options = new firefox.Options()\n *         .addExtensions('/path/to/firebug.xpi')\n *         .setPreference('extensions.firebug.showChromeErrors', true);\n *\n *     let driver = new Builder()\n *         .forBrowser('firefox')\n *         .setFirefoxOptions(options)\n *         .build();\n *\n * The {@linkplain Options} class may also be used to configure WebDriver based\n * on a pre-existing browser profile:\n *\n *     let profile = '/usr/local/home/bob/.mozilla/firefox/3fgog75h.testing';\n *     let options = new firefox.Options().setProfile(profile);\n *\n * The FirefoxDriver will _never_ modify a pre-existing profile; instead it will\n * create a copy for it to modify. By extension, there are certain browser\n * preferences that are required for WebDriver to function properly and they\n * will always be overwritten.\n *\n * __Using a Custom Firefox Binary__\n *\n * On Windows and MacOS, the FirefoxDriver will search for Firefox in its\n * default installation location:\n *\n * - Windows: C:\\Program Files and C:\\Program Files (x86).\n * - MacOS: /Applications/Firefox.app\n *\n * For Linux, Firefox will always be located on the PATH: `$(where firefox)`.\n *\n * Several methods are provided for starting Firefox with a custom executable.\n * First, on Windows and MacOS, you may configure WebDriver to check the default\n * install location for a non-release channel. If the requested channel cannot\n * be found in its default location, WebDriver will fallback to searching your\n * PATH. _Note:_ on Linux, Firefox is _always_ located on your path, regardless\n * of the requested channel.\n *\n *     const {Builder} = require('selenium-webdriver');\n *     const firefox = require('selenium-webdriver/firefox');\n *\n *     let options = new firefox.Options().setBinary(firefox.Channel.NIGHTLY);\n *     let driver = new Builder()\n *         .forBrowser('firefox')\n *         .setFirefoxOptions(options)\n *         .build();\n *\n * On all platforms, you may configure WebDriver to use a Firefox specific\n * executable:\n *\n *     let options = new firefox.Options()\n *         .setBinary('/my/firefox/install/dir/firefox-bin');\n *\n * __Remote Testing__\n *\n * You may customize the Firefox binary and profile when running against a\n * remote Selenium server. Your custom profile will be packaged as a zip and\n * transferred to the remote host for use. The profile will be transferred\n * _once for each new session_. The performance impact should be minimal if\n * you've only configured a few extra browser preferences. If you have a large\n * profile with several extensions, you should consider installing it on the\n * remote host and defining its path via the {@link Options} class. Custom\n * binaries are never copied to remote machines and must be referenced by\n * installation path.\n *\n *     const {Builder} = require('selenium-webdriver');\n *     const firefox = require('selenium-webdriver/firefox');\n *\n *     let options = new firefox.Options()\n *         .setProfile('/profile/path/on/remote/host')\n *         .setBinary('/install/dir/on/remote/host/firefox-bin');\n *\n *     let driver = new Builder()\n *         .forBrowser('firefox')\n *         .usingServer('http://127.0.0.1:4444/wd/hub')\n *         .setFirefoxOptions(options)\n *         .build();\n *\n * [geckodriver release]: https://github.com/mozilla/geckodriver/releases/\n * [PATH]: http://en.wikipedia.org/wiki/PATH_%28variable%29\n */\n\n'use strict'\n\nconst fs = require('fs')\nconst path = require('path')\nconst Symbols = require('./lib/symbols')\nconst command = require('./lib/command')\nconst http = require('./http')\nconst io = require('./io')\nconst remote = require('./remote')\nconst webdriver = require('./lib/webdriver')\nconst zip = require('./io/zip')\nconst { Browser, Capabilities } = require('./lib/capabilities')\nconst { Zip } = require('./io/zip')\nconst { getPath } = require('./common/driverFinder')\n\n/**\n * Thrown when there an add-on is malformed.\n * @final\n */\nclass AddonFormatError extends Error {\n  /** @param {string} msg The error message. */\n  constructor(msg) {\n    super(msg)\n    /** @override */\n    this.name = this.constructor.name\n  }\n}\n\n/**\n * Installs an extension to the given directory.\n * @param {string} extension Path to the xpi extension file to install.\n * @param {string} dir Path to the directory to install the extension in.\n * @return {!Promise<string>} A promise for the add-on ID once\n *     installed.\n */\nasync function installExtension(extension, dir) {\n  const ext = extension.slice(-4)\n  if (ext !== '.xpi' && ext !== '.zip') {\n    throw Error('File name does not end in \".zip\" or \".xpi\": ' + ext)\n  }\n\n  let archive = await zip.load(extension)\n  if (!archive.has('manifest.json')) {\n    throw new AddonFormatError(`Couldn't find manifest.json in ${extension}`)\n  }\n\n  let buf = await archive.getFile('manifest.json')\n  let parsedJSON = JSON.parse(buf.toString('utf8'))\n\n  let { browser_specific_settings } =\n    /** @type {{browser_specific_settings:{gecko:{id:string}}}} */\n    parsedJSON\n\n  if (browser_specific_settings && browser_specific_settings.gecko) {\n    /* browser_specific_settings is an alternative to applications\n     * It is meant to facilitate cross-browser plugins since Firefox48\n     * see https://bugzilla.mozilla.org/show_bug.cgi?id=1262005\n     */\n    parsedJSON.applications = browser_specific_settings\n  }\n\n  let { applications } =\n    /** @type {{applications:{gecko:{id:string}}}} */\n    parsedJSON\n  if (!(applications && applications.gecko && applications.gecko.id)) {\n    throw new AddonFormatError(`Could not find add-on ID for ${extension}`)\n  }\n\n  await io.copy(extension, `${path.join(dir, applications.gecko.id)}.xpi`)\n  return applications.gecko.id\n}\n\nclass Profile {\n  constructor() {\n    /** @private {?string} */\n    this.template_ = null\n\n    /** @private {!Array<string>} */\n    this.extensions_ = []\n  }\n\n  addExtensions(/** !Array<string> */ paths) {\n    this.extensions_ = this.extensions_.concat(...paths)\n  }\n\n  /**\n   * @return {(!Promise<string>|undefined)} a promise for a base64 encoded\n   *     profile, or undefined if there's no data to include.\n   */\n  [Symbols.serialize]() {\n    if (this.template_ || this.extensions_.length) {\n      return buildProfile(this.template_, this.extensions_)\n    }\n    return undefined\n  }\n}\n\n/**\n * @param {?string} template path to an existing profile to use as a template.\n * @param {!Array<string>} extensions paths to extensions to install in the new\n *     profile.\n * @return {!Promise<string>} a promise for the base64 encoded profile.\n */\nasync function buildProfile(template, extensions) {\n  let dir = template\n\n  if (extensions.length) {\n    dir = await io.tmpDir()\n    if (template) {\n      await io.copyDir(\n        /** @type {string} */ (template),\n        dir,\n        /(parent\\.lock|lock|\\.parentlock)/\n      )\n    }\n\n    const extensionsDir = path.join(dir, 'extensions')\n    await io.mkdir(extensionsDir)\n\n    for (let i = 0; i < extensions.length; i++) {\n      await installExtension(extensions[i], extensionsDir)\n    }\n  }\n\n  let zip = new Zip()\n  return zip\n    .addDir(dir)\n    .then(() => zip.toBuffer())\n    .then((buf) => buf.toString('base64'))\n}\n\n/**\n * Configuration options for the FirefoxDriver.\n */\nclass Options extends Capabilities {\n  /**\n   * @param {(Capabilities|Map<string, ?>|Object)=} other Another set of\n   *     capabilities to initialize this instance from.\n   */\n  constructor(other) {\n    super(other)\n    this.setBrowserName(Browser.FIREFOX)\n  }\n\n  /**\n   * @return {!Object}\n   * @private\n   */\n  firefoxOptions_() {\n    let options = this.get('moz:firefoxOptions')\n    if (!options) {\n      options = {}\n      this.set('moz:firefoxOptions', options)\n    }\n    return options\n  }\n\n  /**\n   * @return {!Profile}\n   * @private\n   */\n  profile_() {\n    let options = this.firefoxOptions_()\n    if (!options.profile) {\n      options.profile = new Profile()\n    }\n    return options.profile\n  }\n\n  /**\n   * Specify additional command line arguments that should be used when starting\n   * the Firefox browser.\n   *\n   * @param {...(string|!Array<string>)} args The arguments to include.\n   * @return {!Options} A self reference.\n   */\n  addArguments(...args) {\n    if (args.length) {\n      let options = this.firefoxOptions_()\n      options.args = options.args ? options.args.concat(...args) : args\n    }\n    return this\n  }\n\n  /**\n   * @deprecated Use {@link Options#addArguments} instead.\n   * @example\n   * options.addArguments('-headless');\n   * @example\n   * Configures the geckodriver to start Firefox in headless mode.\n   *\n   * @return {!Options} A self reference.\n   */\n  headless() {\n    return this.addArguments('-headless')\n  }\n\n  /**\n   * Sets the initial window size when running in\n   * {@linkplain #headless headless} mode.\n   *\n   * @param {{width: number, height: number}} size The desired window size.\n   * @return {!Options} A self reference.\n   * @throws {TypeError} if width or height is unspecified, not a number, or\n   *     less than or equal to 0.\n   */\n  windowSize({ width, height }) {\n    function checkArg(arg) {\n      if (typeof arg !== 'number' || arg <= 0) {\n        throw TypeError('Arguments must be {width, height} with numbers > 0')\n      }\n    }\n    checkArg(width)\n    checkArg(height)\n    return this.addArguments(`--width=${width}`, `--height=${height}`)\n  }\n\n  /**\n   * Add extensions that should be installed when starting Firefox.\n   *\n   * @param {...string} paths The paths to the extension XPI files to install.\n   * @return {!Options} A self reference.\n   */\n  addExtensions(...paths) {\n    this.profile_().addExtensions(paths)\n    return this\n  }\n\n  /**\n   * @param {string} key the preference key.\n   * @param {(string|number|boolean)} value the preference value.\n   * @return {!Options} A self reference.\n   * @throws {TypeError} if either the key or value has an invalid type.\n   */\n  setPreference(key, value) {\n    if (typeof key !== 'string') {\n      throw TypeError(`key must be a string, but got ${typeof key}`)\n    }\n    if (\n      typeof value !== 'string' &&\n      typeof value !== 'number' &&\n      typeof value !== 'boolean'\n    ) {\n      throw TypeError(\n        `value must be a string, number, or boolean, but got ${typeof value}`\n      )\n    }\n    let options = this.firefoxOptions_()\n    options.prefs = options.prefs || {}\n    options.prefs[key] = value\n    return this\n  }\n\n  /**\n   * Sets the path to an existing profile to use as a template for new browser\n   * sessions. This profile will be copied for each new session - changes will\n   * not be applied to the profile itself.\n   *\n   * @param {string} profile The profile to use.\n   * @return {!Options} A self reference.\n   * @throws {TypeError} if profile is not a string.\n   */\n  setProfile(profile) {\n    if (typeof profile !== 'string') {\n      throw TypeError(`profile must be a string, but got ${typeof profile}`)\n    }\n    this.profile_().template_ = profile\n    return this\n  }\n\n  /**\n   * Sets the binary to use. The binary may be specified as the path to a\n   * Firefox executable or a desired release {@link Channel}.\n   *\n   * @param {(string|!Channel)} binary The binary to use.\n   * @return {!Options} A self reference.\n   * @throws {TypeError} If `binary` is an invalid type.\n   */\n  setBinary(binary) {\n    if (binary instanceof Channel || typeof binary === 'string') {\n      this.firefoxOptions_().binary = binary\n      return this\n    }\n    throw TypeError('binary must be a string path or Channel object')\n  }\n\n  /**\n   * Enables Mobile start up features\n   *\n   * @param {string} androidPackage The package to use\n   * @return {!Options} A self reference\n   */\n  enableMobile(\n    androidPackage = 'org.mozilla.firefox',\n    androidActivity = null,\n    deviceSerial = null\n  ) {\n    this.firefoxOptions_().androidPackage = androidPackage\n\n    if (androidActivity) {\n      this.firefoxOptions_().androidActivity = androidActivity\n    }\n    if (deviceSerial) {\n      this.firefoxOptions_().deviceSerial = deviceSerial\n    }\n    return this\n  }\n\n  /**\n   * Enables moz:debuggerAddress for firefox cdp\n   */\n  enableDebugger() {\n    return this.set('moz:debuggerAddress', true)\n  }\n\n  /**\n   * Enable bidi connection\n   * @returns {!Capabilities}\n   */\n  enableBidi() {\n    return this.set('webSocketUrl', true)\n  }\n}\n\n/**\n * Enum of available command contexts.\n *\n * Command contexts are specific to Marionette, and may be used with the\n * {@link #context=} method. Contexts allow you to direct all subsequent\n * commands to either \"content\" (default) or \"chrome\". The latter gives\n * you elevated security permissions.\n *\n * @enum {string}\n */\nconst Context = {\n  CONTENT: 'content',\n  CHROME: 'chrome',\n}\n\nconst GECKO_DRIVER_EXE =\n  process.platform === 'win32' ? 'geckodriver.exe' : 'geckodriver'\n\n/**\n * _Synchronously_ attempts to locate the geckodriver executable on the current\n * system.\n *\n * @return {?string} the located executable, or `null`.\n */\nfunction locateSynchronously() {\n  return io.findInPath(GECKO_DRIVER_EXE, true)\n}\n\n/**\n * @return {string} .\n * @throws {Error}\n */\nfunction findGeckoDriver() {\n  return locateSynchronously()\n}\n\n/**\n * @param {string} file Path to the file to find, relative to the program files\n *     root.\n * @return {!Promise<?string>} A promise for the located executable.\n *     The promise will resolve to {@code null} if Firefox was not found.\n */\nfunction findInProgramFiles(file) {\n  let files = [\n    process.env['PROGRAMFILES'] || 'C:\\\\Program Files',\n    process.env['PROGRAMFILES(X86)'] || 'C:\\\\Program Files (x86)',\n  ].map((prefix) => path.join(prefix, file))\n  return io.exists(files[0]).then(function (exists) {\n    return exists\n      ? files[0]\n      : io.exists(files[1]).then(function (exists) {\n          return exists ? files[1] : null\n        })\n  })\n}\n\n/** @enum {string} */\nconst ExtensionCommand = {\n  GET_CONTEXT: 'getContext',\n  SET_CONTEXT: 'setContext',\n  INSTALL_ADDON: 'install addon',\n  UNINSTALL_ADDON: 'uninstall addon',\n}\n\n/**\n * Creates a command executor with support for Marionette's custom commands.\n * @param {!Promise<string>} serverUrl The server's URL.\n * @return {!command.Executor} The new command executor.\n */\nfunction createExecutor(serverUrl) {\n  let client = serverUrl.then((url) => new http.HttpClient(url))\n  let executor = new http.Executor(client)\n  configureExecutor(executor)\n  return executor\n}\n\n/**\n * Configures the given executor with Firefox-specific commands.\n * @param {!http.Executor} executor the executor to configure.\n */\nfunction configureExecutor(executor) {\n  executor.defineCommand(\n    ExtensionCommand.GET_CONTEXT,\n    'GET',\n    '/session/:sessionId/moz/context'\n  )\n\n  executor.defineCommand(\n    ExtensionCommand.SET_CONTEXT,\n    'POST',\n    '/session/:sessionId/moz/context'\n  )\n\n  executor.defineCommand(\n    ExtensionCommand.INSTALL_ADDON,\n    'POST',\n    '/session/:sessionId/moz/addon/install'\n  )\n\n  executor.defineCommand(\n    ExtensionCommand.UNINSTALL_ADDON,\n    'POST',\n    '/session/:sessionId/moz/addon/uninstall'\n  )\n}\n\n/**\n * Creates {@link selenium-webdriver/remote.DriverService} instances that manage\n * a [geckodriver](https://github.com/mozilla/geckodriver) server in a child\n * process.\n */\nclass ServiceBuilder extends remote.DriverService.Builder {\n  /**\n   * @param {string=} opt_exe Path to the server executable to use. If omitted,\n   *     the builder will attempt to locate the geckodriver on the system PATH.\n   */\n  constructor(opt_exe) {\n    super(opt_exe || findGeckoDriver())\n    this.setLoopback(true) // Required.\n  }\n\n  /**\n   * Enables verbose logging.\n   *\n   * @param {boolean=} opt_trace Whether to enable trace-level logging. By\n   *     default, only debug logging is enabled.\n   * @return {!ServiceBuilder} A self reference.\n   */\n  enableVerboseLogging(opt_trace) {\n    return this.addArguments(opt_trace ? '-vv' : '-v')\n  }\n}\n\n/**\n * A WebDriver client for Firefox.\n */\nclass Driver extends webdriver.WebDriver {\n  /**\n   * Creates a new Firefox session.\n   *\n   * @param {(Options|Capabilities|Object)=} opt_config The\n   *    configuration options for this driver, specified as either an\n   *    {@link Options} or {@link Capabilities}, or as a raw hash object.\n   * @param {(http.Executor|remote.DriverService)=} opt_executor Either a\n   *   pre-configured command executor to use for communicating with an\n   *   externally managed remote end (which is assumed to already be running),\n   *   or the `DriverService` to use to start the geckodriver in a child\n   *   process.\n   *\n   *   If an executor is provided, care should e taken not to use reuse it with\n   *   other clients as its internal command mappings will be updated to support\n   *   Firefox-specific commands.\n   *\n   *   _This parameter may only be used with Mozilla's GeckoDriver._\n   *\n   * @throws {Error} If a custom command executor is provided and the driver is\n   *     configured to use the legacy FirefoxDriver from the Selenium project.\n   * @return {!Driver} A new driver instance.\n   */\n  static createSession(opt_config, opt_executor) {\n    let caps =\n      opt_config instanceof Capabilities ? opt_config : new Options(opt_config)\n\n    let executor\n    let onQuit\n\n    if (opt_executor instanceof http.Executor) {\n      executor = opt_executor\n      configureExecutor(executor)\n    } else if (opt_executor instanceof remote.DriverService) {\n      if (!opt_executor.getExecutable()) {\n        opt_executor.setExecutable(getPath(opt_executor, opt_config))\n      }\n      executor = createExecutor(opt_executor.start())\n      onQuit = () => opt_executor.kill()\n    } else {\n      let service = new ServiceBuilder().build()\n      if (!service.getExecutable()) {\n        service.setExecutable(getPath(service, opt_config))\n      }\n      executor = createExecutor(service.start())\n      onQuit = () => service.kill()\n    }\n\n    return /** @type {!Driver} */ (super.createSession(executor, caps, onQuit))\n  }\n\n  /**\n   * This function is a no-op as file detectors are not supported by this\n   * implementation.\n   * @override\n   */\n  setFileDetector() {}\n\n  /**\n   * Get the context that is currently in effect.\n   *\n   * @return {!Promise<Context>} Current context.\n   */\n  getContext() {\n    return this.execute(new command.Command(ExtensionCommand.GET_CONTEXT))\n  }\n\n  /**\n   * Changes target context for commands between chrome- and content.\n   *\n   * Changing the current context has a stateful impact on all subsequent\n   * commands. The {@link Context.CONTENT} context has normal web\n   * platform document permissions, as if you would evaluate arbitrary\n   * JavaScript. The {@link Context.CHROME} context gets elevated\n   * permissions that lets you manipulate the browser chrome itself,\n   * with full access to the XUL toolkit.\n   *\n   * Use your powers wisely.\n   *\n   * @param {!Promise<void>} ctx The context to switch to.\n   */\n  setContext(ctx) {\n    return this.execute(\n      new command.Command(ExtensionCommand.SET_CONTEXT).setParameter(\n        'context',\n        ctx\n      )\n    )\n  }\n\n  /**\n   * Installs a new addon with the current session. This function will return an\n   * ID that may later be used to {@linkplain #uninstallAddon uninstall} the\n   * addon.\n   *\n   *\n   * @param {string} path Path on the local filesystem to the web extension to\n   *     install.\n   * @param {boolean} temporary Flag indicating whether the extension should be\n   *     installed temporarily - gets removed on restart\n   * @return {!Promise<string>} A promise that will resolve to an ID for the\n   *     newly installed addon.\n   * @see #uninstallAddon\n   */\n  async installAddon(path, temporary = false) {\n    let stats = fs.statSync(path)\n    let buf\n    if (stats.isDirectory()) {\n      let zip = new Zip()\n      await zip.addDir(path)\n      buf = await zip.toBuffer('DEFLATE')\n    } else {\n      buf = await io.read(path)\n    }\n    return this.execute(\n      new command.Command(ExtensionCommand.INSTALL_ADDON)\n        .setParameter('addon', buf.toString('base64'))\n        .setParameter('temporary', temporary)\n    )\n  }\n\n  /**\n   * Uninstalls an addon from the current browser session's profile.\n   *\n   * @param {(string|!Promise<string>)} id ID of the addon to uninstall.\n   * @return {!Promise} A promise that will resolve when the operation has\n   *     completed.\n   * @see #installAddon\n   */\n  async uninstallAddon(id) {\n    id = await Promise.resolve(id)\n    return this.execute(\n      new command.Command(ExtensionCommand.UNINSTALL_ADDON).setParameter(\n        'id',\n        id\n      )\n    )\n  }\n}\n\n/**\n * Provides methods for locating the executable for a Firefox release channel\n * on Windows and MacOS. For other systems (i.e. Linux), Firefox will always\n * be located on the system PATH.\n *\n * @final\n */\nclass Channel {\n  /**\n   * @param {string} darwin The path to check when running on MacOS.\n   * @param {string} win32 The path to check when running on Windows.\n   */\n  constructor(darwin, win32) {\n    /** @private @const */ this.darwin_ = darwin\n    /** @private @const */ this.win32_ = win32\n    /** @private {Promise<string>} */\n    this.found_ = null\n  }\n\n  /**\n   * Attempts to locate the Firefox executable for this release channel. This\n   * will first check the default installation location for the channel before\n   * checking the user's PATH. The returned promise will be rejected if Firefox\n   * can not be found.\n   *\n   * @return {!Promise<string>} A promise for the location of the located\n   *     Firefox executable.\n   */\n  locate() {\n    if (this.found_) {\n      return this.found_\n    }\n\n    let found\n    switch (process.platform) {\n      case 'darwin':\n        found = io\n          .exists(this.darwin_)\n          .then((exists) => (exists ? this.darwin_ : io.findInPath('firefox')))\n        break\n\n      case 'win32':\n        found = findInProgramFiles(this.win32_).then(\n          (found) => found || io.findInPath('firefox.exe')\n        )\n        break\n\n      default:\n        found = Promise.resolve(io.findInPath('firefox'))\n        break\n    }\n\n    this.found_ = found.then((found) => {\n      if (found) {\n        // TODO: verify version info.\n        return found\n      }\n      throw Error('Could not locate Firefox on the current system')\n    })\n    return this.found_\n  }\n\n  /** @return {!Promise<string>} */\n  [Symbols.serialize]() {\n    return this.locate()\n  }\n}\n\n/**\n * Firefox's developer channel.\n * @const\n * @see <https://www.mozilla.org/en-US/firefox/channel/desktop/#aurora>\n */\nChannel.AURORA = new Channel(\n  '/Applications/FirefoxDeveloperEdition.app/Contents/MacOS/firefox-bin',\n  'Firefox Developer Edition\\\\firefox.exe'\n)\n\n/**\n * Firefox's beta channel. Note this is provided mainly for convenience as\n * the beta channel has the same installation location as the main release\n * channel.\n * @const\n * @see <https://www.mozilla.org/en-US/firefox/channel/desktop/#beta>\n */\nChannel.BETA = new Channel(\n  '/Applications/Firefox.app/Contents/MacOS/firefox-bin',\n  'Mozilla Firefox\\\\firefox.exe'\n)\n\n/**\n * Firefox's release channel.\n * @const\n * @see <https://www.mozilla.org/en-US/firefox/desktop/>\n */\nChannel.RELEASE = new Channel(\n  '/Applications/Firefox.app/Contents/MacOS/firefox-bin',\n  'Mozilla Firefox\\\\firefox.exe'\n)\n\n/**\n * Firefox's nightly release channel.\n * @const\n * @see <https://www.mozilla.org/en-US/firefox/channel/desktop/#nightly>\n */\nChannel.NIGHTLY = new Channel(\n  '/Applications/Firefox Nightly.app/Contents/MacOS/firefox-bin',\n  'Nightly\\\\firefox.exe'\n)\n\n// PUBLIC API\n\nmodule.exports = {\n  Channel,\n  Context,\n  Driver,\n  Options,\n  ServiceBuilder,\n  locateSynchronously,\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAI,CAAC;AACxB,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAME,OAAO,GAAGF,OAAO,CAAC,eAAe,CAAC;AACxC,MAAMG,OAAO,GAAGH,OAAO,CAAC,eAAe,CAAC;AACxC,MAAMI,IAAI,GAAGJ,OAAO,CAAC,QAAQ,CAAC;AAC9B,MAAMK,EAAE,GAAGL,OAAO,CAAC,MAAM,CAAC;AAC1B,MAAMM,MAAM,GAAGN,OAAO,CAAC,UAAU,CAAC;AAClC,MAAMO,SAAS,GAAGP,OAAO,CAAC,iBAAiB,CAAC;AAC5C,MAAMQ,GAAG,GAAGR,OAAO,CAAC,UAAU,CAAC;AAC/B,MAAM;EAAES,OAAO;EAAEC;AAAa,CAAC,GAAGV,OAAO,CAAC,oBAAoB,CAAC;AAC/D,MAAM;EAAEW;AAAI,CAAC,GAAGX,OAAO,CAAC,UAAU,CAAC;AACnC,MAAM;EAAEY;AAAQ,CAAC,GAAGZ,OAAO,CAAC,uBAAuB,CAAC;;AAEpD;AACA;AACA;AACA;AACA,MAAMa,gBAAgB,SAASC,KAAK,CAAC;EACnC;EACAC,WAAWA,CAACC,GAAG,EAAE;IACf,KAAK,CAACA,GAAG,CAAC;IACV;IACA,IAAI,CAACC,IAAI,GAAG,IAAI,CAACF,WAAW,CAACE,IAAI;EACnC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeC,gBAAgBA,CAACC,SAAS,EAAEC,GAAG,EAAE;EAC9C,MAAMC,GAAG,GAAGF,SAAS,CAACG,KAAK,CAAC,CAAC,CAAC,CAAC;EAC/B,IAAID,GAAG,KAAK,MAAM,IAAIA,GAAG,KAAK,MAAM,EAAE;IACpC,MAAMP,KAAK,CAAC,8CAA8C,GAAGO,GAAG,CAAC;EACnE;EAEA,IAAIE,OAAO,GAAG,MAAMf,GAAG,CAACgB,IAAI,CAACL,SAAS,CAAC;EACvC,IAAI,CAACI,OAAO,CAACE,GAAG,CAAC,eAAe,CAAC,EAAE;IACjC,MAAM,IAAIZ,gBAAgB,CAAE,kCAAiCM,SAAU,EAAC,CAAC;EAC3E;EAEA,IAAIO,GAAG,GAAG,MAAMH,OAAO,CAACI,OAAO,CAAC,eAAe,CAAC;EAChD,IAAIC,UAAU,GAAGC,IAAI,CAACC,KAAK,CAACJ,GAAG,CAACK,QAAQ,CAAC,MAAM,CAAC,CAAC;EAEjD,IAAI;IAAEC;EAA0B,CAAC,GAC/B;EACAJ,UAAU;EAEZ,IAAII,yBAAyB,IAAIA,yBAAyB,CAACC,KAAK,EAAE;IAChE;AACJ;AACA;AACA;IACIL,UAAU,CAACM,YAAY,GAAGF,yBAAyB;EACrD;EAEA,IAAI;IAAEE;EAAa,CAAC,GAClB;EACAN,UAAU;EACZ,IAAI,EAAEM,YAAY,IAAIA,YAAY,CAACD,KAAK,IAAIC,YAAY,CAACD,KAAK,CAACE,EAAE,CAAC,EAAE;IAClE,MAAM,IAAItB,gBAAgB,CAAE,gCAA+BM,SAAU,EAAC,CAAC;EACzE;EAEA,MAAMd,EAAE,CAAC+B,IAAI,CAACjB,SAAS,EAAG,GAAElB,IAAI,CAACoC,IAAI,CAACjB,GAAG,EAAEc,YAAY,CAACD,KAAK,CAACE,EAAE,CAAE,MAAK,CAAC;EACxE,OAAOD,YAAY,CAACD,KAAK,CAACE,EAAE;AAC9B;AAEA,MAAMG,OAAO,CAAC;EACZvB,WAAWA,CAAA,EAAG;IACZ;IACA,IAAI,CAACwB,SAAS,GAAG,IAAI;;IAErB;IACA,IAAI,CAACC,WAAW,GAAG,EAAE;EACvB;EAEAC,aAAaA,CAAA,CAAC,qBAAsBC,KAAK,EAAE;IACzC,IAAI,CAACF,WAAW,GAAG,IAAI,CAACA,WAAW,CAACG,MAAM,CAAC,GAAGD,KAAK,CAAC;EACtD;;EAEA;AACF;AACA;AACA;EACE,CAACxC,OAAO,CAAC0C,SAAS,IAAI;IACpB,IAAI,IAAI,CAACL,SAAS,IAAI,IAAI,CAACC,WAAW,CAACK,MAAM,EAAE;MAC7C,OAAOC,YAAY,CAAC,IAAI,CAACP,SAAS,EAAE,IAAI,CAACC,WAAW,CAAC;IACvD;IACA,OAAOO,SAAS;EAClB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeD,YAAYA,CAACE,QAAQ,EAAEC,UAAU,EAAE;EAChD,IAAI7B,GAAG,GAAG4B,QAAQ;EAElB,IAAIC,UAAU,CAACJ,MAAM,EAAE;IACrBzB,GAAG,GAAG,MAAMf,EAAE,CAAC6C,MAAM,CAAC,CAAC;IACvB,IAAIF,QAAQ,EAAE;MACZ,MAAM3C,EAAE,CAAC8C,OAAO,EACd,qBAAuBH,QAAQ,EAC/B5B,GAAG,EACH,kCACF,CAAC;IACH;IAEA,MAAMgC,aAAa,GAAGnD,IAAI,CAACoC,IAAI,CAACjB,GAAG,EAAE,YAAY,CAAC;IAClD,MAAMf,EAAE,CAACgD,KAAK,CAACD,aAAa,CAAC;IAE7B,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,UAAU,CAACJ,MAAM,EAAES,CAAC,EAAE,EAAE;MAC1C,MAAMpC,gBAAgB,CAAC+B,UAAU,CAACK,CAAC,CAAC,EAAEF,aAAa,CAAC;IACtD;EACF;EAEA,IAAI5C,GAAG,GAAG,IAAIG,GAAG,CAAC,CAAC;EACnB,OAAOH,GAAG,CACP+C,MAAM,CAACnC,GAAG,CAAC,CACXoC,IAAI,CAAC,MAAMhD,GAAG,CAACiD,QAAQ,CAAC,CAAC,CAAC,CAC1BD,IAAI,CAAE9B,GAAG,IAAKA,GAAG,CAACK,QAAQ,CAAC,QAAQ,CAAC,CAAC;AAC1C;;AAEA;AACA;AACA;AACA,MAAM2B,OAAO,SAAShD,YAAY,CAAC;EACjC;AACF;AACA;AACA;EACEK,WAAWA,CAAC4C,KAAK,EAAE;IACjB,KAAK,CAACA,KAAK,CAAC;IACZ,IAAI,CAACC,cAAc,CAACnD,OAAO,CAACoD,OAAO,CAAC;EACtC;;EAEA;AACF;AACA;AACA;EACEC,eAAeA,CAAA,EAAG;IAChB,IAAIC,OAAO,GAAG,IAAI,CAACC,GAAG,CAAC,oBAAoB,CAAC;IAC5C,IAAI,CAACD,OAAO,EAAE;MACZA,OAAO,GAAG,CAAC,CAAC;MACZ,IAAI,CAACE,GAAG,CAAC,oBAAoB,EAAEF,OAAO,CAAC;IACzC;IACA,OAAOA,OAAO;EAChB;;EAEA;AACF;AACA;AACA;EACEG,QAAQA,CAAA,EAAG;IACT,IAAIH,OAAO,GAAG,IAAI,CAACD,eAAe,CAAC,CAAC;IACpC,IAAI,CAACC,OAAO,CAACI,OAAO,EAAE;MACpBJ,OAAO,CAACI,OAAO,GAAG,IAAI7B,OAAO,CAAC,CAAC;IACjC;IACA,OAAOyB,OAAO,CAACI,OAAO;EACxB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,YAAYA,CAAA,EAAU;IAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAzB,MAAA,EAAN0B,IAAI,OAAAC,KAAA,CAAAH,IAAA,GAAAI,IAAA,MAAAA,IAAA,GAAAJ,IAAA,EAAAI,IAAA;MAAJF,IAAI,CAAAE,IAAA,IAAAH,SAAA,CAAAG,IAAA;IAAA;IAClB,IAAIF,IAAI,CAAC1B,MAAM,EAAE;MACf,IAAIkB,OAAO,GAAG,IAAI,CAACD,eAAe,CAAC,CAAC;MACpCC,OAAO,CAACQ,IAAI,GAAGR,OAAO,CAACQ,IAAI,GAAGR,OAAO,CAACQ,IAAI,CAAC5B,MAAM,CAAC,GAAG4B,IAAI,CAAC,GAAGA,IAAI;IACnE;IACA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEG,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI,CAACN,YAAY,CAAC,WAAW,CAAC;EACvC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEO,UAAUA,CAAAC,IAAA,EAAoB;IAAA,IAAnB;MAAEC,KAAK;MAAEC;IAAO,CAAC,GAAAF,IAAA;IAC1B,SAASG,QAAQA,CAACC,GAAG,EAAE;MACrB,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAIA,GAAG,IAAI,CAAC,EAAE;QACvC,MAAMC,SAAS,CAAC,oDAAoD,CAAC;MACvE;IACF;IACAF,QAAQ,CAACF,KAAK,CAAC;IACfE,QAAQ,CAACD,MAAM,CAAC;IAChB,OAAO,IAAI,CAACV,YAAY,CAAE,WAAUS,KAAM,EAAC,EAAG,YAAWC,MAAO,EAAC,CAAC;EACpE;;EAEA;AACF;AACA;AACA;AACA;AACA;EACErC,aAAaA,CAAA,EAAW;IAAA,SAAAyC,KAAA,GAAAZ,SAAA,CAAAzB,MAAA,EAAPH,KAAK,OAAA8B,KAAA,CAAAU,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAALzC,KAAK,CAAAyC,KAAA,IAAAb,SAAA,CAAAa,KAAA;IAAA;IACpB,IAAI,CAACjB,QAAQ,CAAC,CAAC,CAACzB,aAAa,CAACC,KAAK,CAAC;IACpC,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE0C,aAAaA,CAACC,GAAG,EAAEC,KAAK,EAAE;IACxB,IAAI,OAAOD,GAAG,KAAK,QAAQ,EAAE;MAC3B,MAAMJ,SAAS,CAAE,iCAAgC,OAAOI,GAAI,EAAC,CAAC;IAChE;IACA,IACE,OAAOC,KAAK,KAAK,QAAQ,IACzB,OAAOA,KAAK,KAAK,QAAQ,IACzB,OAAOA,KAAK,KAAK,SAAS,EAC1B;MACA,MAAML,SAAS,CACZ,uDAAsD,OAAOK,KAAM,EACtE,CAAC;IACH;IACA,IAAIvB,OAAO,GAAG,IAAI,CAACD,eAAe,CAAC,CAAC;IACpCC,OAAO,CAACwB,KAAK,GAAGxB,OAAO,CAACwB,KAAK,IAAI,CAAC,CAAC;IACnCxB,OAAO,CAACwB,KAAK,CAACF,GAAG,CAAC,GAAGC,KAAK;IAC1B,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEE,UAAUA,CAACrB,OAAO,EAAE;IAClB,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;MAC/B,MAAMc,SAAS,CAAE,qCAAoC,OAAOd,OAAQ,EAAC,CAAC;IACxE;IACA,IAAI,CAACD,QAAQ,CAAC,CAAC,CAAC3B,SAAS,GAAG4B,OAAO;IACnC,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEsB,SAASA,CAACC,MAAM,EAAE;IAChB,IAAIA,MAAM,YAAYC,OAAO,IAAI,OAAOD,MAAM,KAAK,QAAQ,EAAE;MAC3D,IAAI,CAAC5B,eAAe,CAAC,CAAC,CAAC4B,MAAM,GAAGA,MAAM;MACtC,OAAO,IAAI;IACb;IACA,MAAMT,SAAS,CAAC,gDAAgD,CAAC;EACnE;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEW,YAAYA,CAAA,EAIV;IAAA,IAHAC,cAAc,GAAAvB,SAAA,CAAAzB,MAAA,QAAAyB,SAAA,QAAAvB,SAAA,GAAAuB,SAAA,MAAG,qBAAqB;IAAA,IACtCwB,eAAe,GAAAxB,SAAA,CAAAzB,MAAA,QAAAyB,SAAA,QAAAvB,SAAA,GAAAuB,SAAA,MAAG,IAAI;IAAA,IACtByB,YAAY,GAAAzB,SAAA,CAAAzB,MAAA,QAAAyB,SAAA,QAAAvB,SAAA,GAAAuB,SAAA,MAAG,IAAI;IAEnB,IAAI,CAACR,eAAe,CAAC,CAAC,CAAC+B,cAAc,GAAGA,cAAc;IAEtD,IAAIC,eAAe,EAAE;MACnB,IAAI,CAAChC,eAAe,CAAC,CAAC,CAACgC,eAAe,GAAGA,eAAe;IAC1D;IACA,IAAIC,YAAY,EAAE;MAChB,IAAI,CAACjC,eAAe,CAAC,CAAC,CAACiC,YAAY,GAAGA,YAAY;IACpD;IACA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;EACEC,cAAcA,CAAA,EAAG;IACf,OAAO,IAAI,CAAC/B,GAAG,CAAC,qBAAqB,EAAE,IAAI,CAAC;EAC9C;;EAEA;AACF;AACA;AACA;EACEgC,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI,CAAChC,GAAG,CAAC,cAAc,EAAE,IAAI,CAAC;EACvC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMiC,OAAO,GAAG;EACdC,OAAO,EAAE,SAAS;EAClBC,MAAM,EAAE;AACV,CAAC;AAED,MAAMC,gBAAgB,GACpBC,OAAO,CAACC,QAAQ,KAAK,OAAO,GAAG,iBAAiB,GAAG,aAAa;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,mBAAmBA,CAAA,EAAG;EAC7B,OAAOnG,EAAE,CAACoG,UAAU,CAACJ,gBAAgB,EAAE,IAAI,CAAC;AAC9C;;AAEA;AACA;AACA;AACA;AACA,SAASK,eAAeA,CAAA,EAAG;EACzB,OAAOF,mBAAmB,CAAC,CAAC;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,kBAAkBA,CAACC,IAAI,EAAE;EAChC,IAAIC,KAAK,GAAG,CACVP,OAAO,CAACQ,GAAG,CAAC,cAAc,CAAC,IAAI,mBAAmB,EAClDR,OAAO,CAACQ,GAAG,CAAC,mBAAmB,CAAC,IAAI,yBAAyB,CAC9D,CAACC,GAAG,CAAEC,MAAM,IAAK/G,IAAI,CAACoC,IAAI,CAAC2E,MAAM,EAAEJ,IAAI,CAAC,CAAC;EAC1C,OAAOvG,EAAE,CAAC4G,MAAM,CAACJ,KAAK,CAAC,CAAC,CAAC,CAAC,CAACrD,IAAI,CAAC,UAAUyD,MAAM,EAAE;IAChD,OAAOA,MAAM,GACTJ,KAAK,CAAC,CAAC,CAAC,GACRxG,EAAE,CAAC4G,MAAM,CAACJ,KAAK,CAAC,CAAC,CAAC,CAAC,CAACrD,IAAI,CAAC,UAAUyD,MAAM,EAAE;MACzC,OAAOA,MAAM,GAAGJ,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI;IACjC,CAAC,CAAC;EACR,CAAC,CAAC;AACJ;;AAEA;AACA,MAAMK,gBAAgB,GAAG;EACvBC,WAAW,EAAE,YAAY;EACzBC,WAAW,EAAE,YAAY;EACzBC,aAAa,EAAE,eAAe;EAC9BC,eAAe,EAAE;AACnB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,SAASC,cAAcA,CAACC,SAAS,EAAE;EACjC,IAAIC,MAAM,GAAGD,SAAS,CAAChE,IAAI,CAAEkE,GAAG,IAAK,IAAItH,IAAI,CAACuH,UAAU,CAACD,GAAG,CAAC,CAAC;EAC9D,IAAIE,QAAQ,GAAG,IAAIxH,IAAI,CAACyH,QAAQ,CAACJ,MAAM,CAAC;EACxCK,iBAAiB,CAACF,QAAQ,CAAC;EAC3B,OAAOA,QAAQ;AACjB;;AAEA;AACA;AACA;AACA;AACA,SAASE,iBAAiBA,CAACF,QAAQ,EAAE;EACnCA,QAAQ,CAACG,aAAa,CACpBb,gBAAgB,CAACC,WAAW,EAC5B,KAAK,EACL,iCACF,CAAC;EAEDS,QAAQ,CAACG,aAAa,CACpBb,gBAAgB,CAACE,WAAW,EAC5B,MAAM,EACN,iCACF,CAAC;EAEDQ,QAAQ,CAACG,aAAa,CACpBb,gBAAgB,CAACG,aAAa,EAC9B,MAAM,EACN,uCACF,CAAC;EAEDO,QAAQ,CAACG,aAAa,CACpBb,gBAAgB,CAACI,eAAe,EAChC,MAAM,EACN,yCACF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAMU,cAAc,SAAS1H,MAAM,CAAC2H,aAAa,CAACC,OAAO,CAAC;EACxD;AACF;AACA;AACA;EACEnH,WAAWA,CAACoH,OAAO,EAAE;IACnB,KAAK,CAACA,OAAO,IAAIzB,eAAe,CAAC,CAAC,CAAC;IACnC,IAAI,CAAC0B,WAAW,CAAC,IAAI,CAAC,EAAC;EACzB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,oBAAoBA,CAACC,SAAS,EAAE;IAC9B,OAAO,IAAI,CAAClE,YAAY,CAACkE,SAAS,GAAG,KAAK,GAAG,IAAI,CAAC;EACpD;AACF;;AAEA;AACA;AACA;AACA,MAAMC,MAAM,SAAShI,SAAS,CAACiI,SAAS,CAAC;EACvC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAOC,aAAaA,CAACC,UAAU,EAAEC,YAAY,EAAE;IAC7C,IAAIC,IAAI,GACNF,UAAU,YAAYhI,YAAY,GAAGgI,UAAU,GAAG,IAAIhF,OAAO,CAACgF,UAAU,CAAC;IAE3E,IAAId,QAAQ;IACZ,IAAIiB,MAAM;IAEV,IAAIF,YAAY,YAAYvI,IAAI,CAACyH,QAAQ,EAAE;MACzCD,QAAQ,GAAGe,YAAY;MACvBb,iBAAiB,CAACF,QAAQ,CAAC;IAC7B,CAAC,MAAM,IAAIe,YAAY,YAAYrI,MAAM,CAAC2H,aAAa,EAAE;MACvD,IAAI,CAACU,YAAY,CAACG,aAAa,CAAC,CAAC,EAAE;QACjCH,YAAY,CAACI,aAAa,CAACnI,OAAO,CAAC+H,YAAY,EAAED,UAAU,CAAC,CAAC;MAC/D;MACAd,QAAQ,GAAGL,cAAc,CAACoB,YAAY,CAACK,KAAK,CAAC,CAAC,CAAC;MAC/CH,MAAM,GAAGA,CAAA,KAAMF,YAAY,CAACM,IAAI,CAAC,CAAC;IACpC,CAAC,MAAM;MACL,IAAIC,OAAO,GAAG,IAAIlB,cAAc,CAAC,CAAC,CAACmB,KAAK,CAAC,CAAC;MAC1C,IAAI,CAACD,OAAO,CAACJ,aAAa,CAAC,CAAC,EAAE;QAC5BI,OAAO,CAACH,aAAa,CAACnI,OAAO,CAACsI,OAAO,EAAER,UAAU,CAAC,CAAC;MACrD;MACAd,QAAQ,GAAGL,cAAc,CAAC2B,OAAO,CAACF,KAAK,CAAC,CAAC,CAAC;MAC1CH,MAAM,GAAGA,CAAA,KAAMK,OAAO,CAACD,IAAI,CAAC,CAAC;IAC/B;IAEA,OAAO,uBAAwB,KAAK,CAACR,aAAa,CAACb,QAAQ,EAAEgB,IAAI,EAAEC,MAAM;IAAC;EAC5E;;EAEA;AACF;AACA;AACA;AACA;EACEO,eAAeA,CAAA,EAAG,CAAC;;EAEnB;AACF;AACA;AACA;AACA;EACEC,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI,CAACC,OAAO,CAAC,IAAInJ,OAAO,CAACoJ,OAAO,CAACrC,gBAAgB,CAACC,WAAW,CAAC,CAAC;EACxE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEqC,UAAUA,CAACC,GAAG,EAAE;IACd,OAAO,IAAI,CAACH,OAAO,CACjB,IAAInJ,OAAO,CAACoJ,OAAO,CAACrC,gBAAgB,CAACE,WAAW,CAAC,CAACsC,YAAY,CAC5D,SAAS,EACTD,GACF,CACF,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAME,YAAYA,CAAC1J,IAAI,EAAqB;IAAA,IAAnB2J,SAAS,GAAAtF,SAAA,CAAAzB,MAAA,QAAAyB,SAAA,QAAAvB,SAAA,GAAAuB,SAAA,MAAG,KAAK;IACxC,IAAIuF,KAAK,GAAG9J,EAAE,CAAC+J,QAAQ,CAAC7J,IAAI,CAAC;IAC7B,IAAIyB,GAAG;IACP,IAAImI,KAAK,CAACE,WAAW,CAAC,CAAC,EAAE;MACvB,IAAIvJ,GAAG,GAAG,IAAIG,GAAG,CAAC,CAAC;MACnB,MAAMH,GAAG,CAAC+C,MAAM,CAACtD,IAAI,CAAC;MACtByB,GAAG,GAAG,MAAMlB,GAAG,CAACiD,QAAQ,CAAC,SAAS,CAAC;IACrC,CAAC,MAAM;MACL/B,GAAG,GAAG,MAAMrB,EAAE,CAAC2J,IAAI,CAAC/J,IAAI,CAAC;IAC3B;IACA,OAAO,IAAI,CAACqJ,OAAO,CACjB,IAAInJ,OAAO,CAACoJ,OAAO,CAACrC,gBAAgB,CAACG,aAAa,CAAC,CAChDqC,YAAY,CAAC,OAAO,EAAEhI,GAAG,CAACK,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAC7C2H,YAAY,CAAC,WAAW,EAAEE,SAAS,CACxC,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMK,cAAcA,CAAC9H,EAAE,EAAE;IACvBA,EAAE,GAAG,MAAM+H,OAAO,CAACC,OAAO,CAAChI,EAAE,CAAC;IAC9B,OAAO,IAAI,CAACmH,OAAO,CACjB,IAAInJ,OAAO,CAACoJ,OAAO,CAACrC,gBAAgB,CAACI,eAAe,CAAC,CAACoC,YAAY,CAChE,IAAI,EACJvH,EACF,CACF,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMwD,OAAO,CAAC;EACZ;AACF;AACA;AACA;EACE5E,WAAWA,CAACqJ,MAAM,EAAEC,KAAK,EAAE;IACzB,sBAAuB,IAAI,CAACC,OAAO,GAAGF,MAAM;IAC5C;IAAuB,IAAI,CAACG,MAAM,GAAGF,KAAK;IAC1C;IACA,IAAI,CAACG,MAAM,GAAG,IAAI;EACpB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,MAAMA,CAAA,EAAG;IACP,IAAI,IAAI,CAACD,MAAM,EAAE;MACf,OAAO,IAAI,CAACA,MAAM;IACpB;IAEA,IAAIE,KAAK;IACT,QAAQpE,OAAO,CAACC,QAAQ;MACtB,KAAK,QAAQ;QACXmE,KAAK,GAAGrK,EAAE,CACP4G,MAAM,CAAC,IAAI,CAACqD,OAAO,CAAC,CACpB9G,IAAI,CAAEyD,MAAM,IAAMA,MAAM,GAAG,IAAI,CAACqD,OAAO,GAAGjK,EAAE,CAACoG,UAAU,CAAC,SAAS,CAAE,CAAC;QACvE;MAEF,KAAK,OAAO;QACViE,KAAK,GAAG/D,kBAAkB,CAAC,IAAI,CAAC4D,MAAM,CAAC,CAAC/G,IAAI,CACzCkH,KAAK,IAAKA,KAAK,IAAIrK,EAAE,CAACoG,UAAU,CAAC,aAAa,CACjD,CAAC;QACD;MAEF;QACEiE,KAAK,GAAGR,OAAO,CAACC,OAAO,CAAC9J,EAAE,CAACoG,UAAU,CAAC,SAAS,CAAC,CAAC;QACjD;IACJ;IAEA,IAAI,CAAC+D,MAAM,GAAGE,KAAK,CAAClH,IAAI,CAAEkH,KAAK,IAAK;MAClC,IAAIA,KAAK,EAAE;QACT;QACA,OAAOA,KAAK;MACd;MACA,MAAM5J,KAAK,CAAC,gDAAgD,CAAC;IAC/D,CAAC,CAAC;IACF,OAAO,IAAI,CAAC0J,MAAM;EACpB;;EAEA;EACA,CAACtK,OAAO,CAAC0C,SAAS,IAAI;IACpB,OAAO,IAAI,CAAC6H,MAAM,CAAC,CAAC;EACtB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA9E,OAAO,CAACgF,MAAM,GAAG,IAAIhF,OAAO,CAC1B,sEAAsE,EACtE,wCACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,OAAO,CAACiF,IAAI,GAAG,IAAIjF,OAAO,CACxB,sDAAsD,EACtD,8BACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAA,OAAO,CAACkF,OAAO,GAAG,IAAIlF,OAAO,CAC3B,sDAAsD,EACtD,8BACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAA,OAAO,CAACmF,OAAO,GAAG,IAAInF,OAAO,CAC3B,8DAA8D,EAC9D,sBACF,CAAC;;AAED;;AAEAoF,MAAM,CAACC,OAAO,GAAG;EACfrF,OAAO;EACPO,OAAO;EACPqC,MAAM;EACN7E,OAAO;EACPsE,cAAc;EACdxB;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}