{"ast":null,"code":"/*!\n * Tmp\n *\n * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */\n\n/*\n * Module dependencies.\n */\nconst fs = require('fs');\nconst os = require('os');\nconst path = require('path');\nconst crypto = require('crypto');\nconst _c = {\n  fs: fs.constants,\n  os: os.constants\n};\nconst rimraf = require('rimraf');\n\n/*\n * The working inner variables.\n */\nconst\n  // the random characters to choose from\n  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  TEMPLATE_PATTERN = /XXXXXX/,\n  DEFAULT_TRIES = 3,\n  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),\n  // constants are off on the windows platform and will not match the actual errno codes\n  IS_WIN32 = os.platform() === 'win32',\n  EBADF = _c.EBADF || _c.os.errno.EBADF,\n  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,\n  DIR_MODE = 0o700 /* 448 */,\n  FILE_MODE = 0o600 /* 384 */,\n  EXIT = 'exit',\n  // this will hold the objects need to be removed on exit\n  _removeObjects = [],\n  // API change in fs.rmdirSync leads to error when passing in a second parameter, e.g. the callback\n  FN_RMDIR_SYNC = fs.rmdirSync.bind(fs),\n  FN_RIMRAF_SYNC = rimraf.sync;\nlet _gracefulCleanup = false;\n\n/**\n * Gets a temporary file name.\n *\n * @param {(Options|tmpNameCallback)} options options or callback\n * @param {?tmpNameCallback} callback the callback function\n */\nfunction tmpName(options, callback) {\n  const args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n  try {\n    _assertAndSanitizeOptions(opts);\n  } catch (err) {\n    return cb(err);\n  }\n  let tries = opts.tries;\n  (function _getUniqueName() {\n    try {\n      const name = _generateTmpName(opts);\n\n      // check whether the path exists then retry if needed\n      fs.stat(name, function (err) {\n        /* istanbul ignore else */\n        if (!err) {\n          /* istanbul ignore else */\n          if (tries-- > 0) return _getUniqueName();\n          return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));\n        }\n        cb(null, name);\n      });\n    } catch (err) {\n      cb(err);\n    }\n  })();\n}\n\n/**\n * Synchronous version of tmpName.\n *\n * @param {Object} options\n * @returns {string} the generated random name\n * @throws {Error} if the options are invalid or could not generate a filename\n */\nfunction tmpNameSync(options) {\n  const args = _parseArguments(options),\n    opts = args[0];\n  _assertAndSanitizeOptions(opts);\n  let tries = opts.tries;\n  do {\n    const name = _generateTmpName(opts);\n    try {\n      fs.statSync(name);\n    } catch (e) {\n      return name;\n    }\n  } while (tries-- > 0);\n  throw new Error('Could not get a unique tmp filename, max tries reached');\n}\n\n/**\n * Creates and opens a temporary file.\n *\n * @param {(Options|null|undefined|fileCallback)} options the config options or the callback function or null or undefined\n * @param {?fileCallback} callback\n */\nfunction file(options, callback) {\n  const args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create and open the file\n    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n      /* istanbu ignore else */\n      if (err) return cb(err);\n      if (opts.discardDescriptor) {\n        return fs.close(fd, function _discardCallback(possibleErr) {\n          // the chance of getting an error on close here is rather low and might occur in the most edgiest cases only\n          return cb(possibleErr, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts, false));\n        });\n      } else {\n        // detachDescriptor passes the descriptor whereas discardDescriptor closes it, either way, we no longer care\n        // about the descriptor\n        const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n        cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));\n      }\n    });\n  });\n}\n\n/**\n * Synchronous version of file.\n *\n * @param {Options} options\n * @returns {FileSyncObject} object consists of name, fd and removeCallback\n * @throws {Error} if cannot create a file\n */\nfunction fileSync(options) {\n  const args = _parseArguments(options),\n    opts = args[0];\n  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n  const name = tmpNameSync(opts);\n  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n  /* istanbul ignore else */\n  if (opts.discardDescriptor) {\n    fs.closeSync(fd);\n    fd = undefined;\n  }\n  return {\n    name: name,\n    fd: fd,\n    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)\n  };\n}\n\n/**\n * Creates a temporary directory.\n *\n * @param {(Options|dirCallback)} options the options or the callback function\n * @param {?dirCallback} callback\n */\nfunction dir(options, callback) {\n  const args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create the directory\n    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n      /* istanbul ignore else */\n      if (err) return cb(err);\n      cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));\n    });\n  });\n}\n\n/**\n * Synchronous version of dir.\n *\n * @param {Options} options\n * @returns {DirSyncObject} object consists of name and removeCallback\n * @throws {Error} if it cannot create a directory\n */\nfunction dirSync(options) {\n  const args = _parseArguments(options),\n    opts = args[0];\n  const name = tmpNameSync(opts);\n  fs.mkdirSync(name, opts.mode || DIR_MODE);\n  return {\n    name: name,\n    removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)\n  };\n}\n\n/**\n * Removes files asynchronously.\n *\n * @param {Object} fdPath\n * @param {Function} next\n * @private\n */\nfunction _removeFileAsync(fdPath, next) {\n  const _handler = function (err) {\n    if (err && !_isENOENT(err)) {\n      // reraise any unanticipated error\n      return next(err);\n    }\n    next();\n  };\n  if (0 <= fdPath[0]) fs.close(fdPath[0], function () {\n    fs.unlink(fdPath[1], _handler);\n  });else fs.unlink(fdPath[1], _handler);\n}\n\n/**\n * Removes files synchronously.\n *\n * @param {Object} fdPath\n * @private\n */\nfunction _removeFileSync(fdPath) {\n  let rethrownException = null;\n  try {\n    if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);\n  } catch (e) {\n    // reraise any unanticipated error\n    if (!_isEBADF(e) && !_isENOENT(e)) throw e;\n  } finally {\n    try {\n      fs.unlinkSync(fdPath[1]);\n    } catch (e) {\n      // reraise any unanticipated error\n      if (!_isENOENT(e)) rethrownException = e;\n    }\n  }\n  if (rethrownException !== null) {\n    throw rethrownException;\n  }\n}\n\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * Returns either a sync callback or a async callback depending on whether\n * fileSync or file was called, which is expressed by the sync parameter.\n *\n * @param {string} name the path of the file\n * @param {number} fd file descriptor\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {fileCallback | fileCallbackSync}\n * @private\n */\nfunction _prepareTmpFileRemoveCallback(name, fd, opts, sync) {\n  const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync);\n  const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync, removeCallbackSync);\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n  return sync ? removeCallbackSync : removeCallback;\n}\n\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * Returns either a sync callback or a async callback depending on whether\n * tmpFileSync or tmpFile was called, which is expressed by the sync parameter.\n *\n * @param {string} name\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {Function} the callback\n * @private\n */\nfunction _prepareTmpDirRemoveCallback(name, opts, sync) {\n  const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);\n  const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;\n  const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);\n  const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n  return sync ? removeCallbackSync : removeCallback;\n}\n\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * The cleanup callback is save to be called multiple times.\n * Subsequent invocations will be ignored.\n *\n * @param {Function} removeFunction\n * @param {string} fileOrDirName\n * @param {boolean} sync\n * @param {cleanupCallbackSync?} cleanupCallbackSync\n * @returns {cleanupCallback | cleanupCallbackSync}\n * @private\n */\nfunction _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {\n  let called = false;\n\n  // if sync is true, the next parameter will be ignored\n  return function _cleanupCallback(next) {\n    /* istanbul ignore else */\n    if (!called) {\n      // remove cleanupCallback from cache\n      const toRemove = cleanupCallbackSync || _cleanupCallback;\n      const index = _removeObjects.indexOf(toRemove);\n      /* istanbul ignore else */\n      if (index >= 0) _removeObjects.splice(index, 1);\n      called = true;\n      if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {\n        return removeFunction(fileOrDirName);\n      } else {\n        return removeFunction(fileOrDirName, next || function () {});\n      }\n    }\n  };\n}\n\n/**\n * The garbage collector.\n *\n * @private\n */\nfunction _garbageCollector() {\n  /* istanbul ignore else */\n  if (!_gracefulCleanup) return;\n\n  // the function being called removes itself from _removeObjects,\n  // loop until _removeObjects is empty\n  while (_removeObjects.length) {\n    try {\n      _removeObjects[0]();\n    } catch (e) {\n      // already removed?\n    }\n  }\n}\n\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {number} howMany\n * @returns {string} the generated random name\n * @private\n */\nfunction _randomChars(howMany) {\n  let value = [],\n    rnd = null;\n\n  // make sure that we do not fail because we ran out of entropy\n  try {\n    rnd = crypto.randomBytes(howMany);\n  } catch (e) {\n    rnd = crypto.pseudoRandomBytes(howMany);\n  }\n  for (var i = 0; i < howMany; i++) {\n    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n  }\n  return value.join('');\n}\n\n/**\n * Helper which determines whether a string s is blank, that is undefined, or empty or null.\n *\n * @private\n * @param {string} s\n * @returns {Boolean} true whether the string s is blank, false otherwise\n */\nfunction _isBlank(s) {\n  return s === null || _isUndefined(s) || !s.trim();\n}\n\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @returns {boolean} true if the object is undefined\n * @private\n */\nfunction _isUndefined(obj) {\n  return typeof obj === 'undefined';\n}\n\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {(Options|null|undefined|Function)} options\n * @param {?Function} callback\n * @returns {Array} parsed arguments\n * @private\n */\nfunction _parseArguments(options, callback) {\n  /* istanbul ignore else */\n  if (typeof options === 'function') {\n    return [{}, options];\n  }\n\n  /* istanbul ignore else */\n  if (_isUndefined(options)) {\n    return [{}, callback];\n  }\n\n  // copy options so we do not leak the changes we make internally\n  const actualOptions = {};\n  for (const key of Object.getOwnPropertyNames(options)) {\n    actualOptions[key] = options[key];\n  }\n  return [actualOptions, callback];\n}\n\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {string} the new random name according to opts\n * @private\n */\nfunction _generateTmpName(opts) {\n  const tmpDir = opts.tmpdir;\n\n  /* istanbul ignore else */\n  if (!_isUndefined(opts.name)) return path.join(tmpDir, opts.dir, opts.name);\n\n  /* istanbul ignore else */\n  if (!_isUndefined(opts.template)) return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));\n\n  // prefix and postfix\n  const name = [opts.prefix ? opts.prefix : 'tmp', '-', process.pid, '-', _randomChars(12), opts.postfix ? '-' + opts.postfix : ''].join('');\n  return path.join(tmpDir, opts.dir, name);\n}\n\n/**\n * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing\n * options.\n *\n * @param {Options} options\n * @private\n */\nfunction _assertAndSanitizeOptions(options) {\n  options.tmpdir = _getTmpDir(options);\n  const tmpDir = options.tmpdir;\n\n  /* istanbul ignore else */\n  if (!_isUndefined(options.name)) _assertIsRelative(options.name, 'name', tmpDir);\n  /* istanbul ignore else */\n  if (!_isUndefined(options.dir)) _assertIsRelative(options.dir, 'dir', tmpDir);\n  /* istanbul ignore else */\n  if (!_isUndefined(options.template)) {\n    _assertIsRelative(options.template, 'template', tmpDir);\n    if (!options.template.match(TEMPLATE_PATTERN)) throw new Error(`Invalid template, found \"${options.template}\".`);\n  }\n  /* istanbul ignore else */\n  if (!_isUndefined(options.tries) && isNaN(options.tries) || options.tries < 0) throw new Error(`Invalid tries, found \"${options.tries}\".`);\n\n  // if a name was specified we will try once\n  options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;\n  options.keep = !!options.keep;\n  options.detachDescriptor = !!options.detachDescriptor;\n  options.discardDescriptor = !!options.discardDescriptor;\n  options.unsafeCleanup = !!options.unsafeCleanup;\n\n  // sanitize dir, also keep (multiple) blanks if the user, purportedly sane, requests us to\n  options.dir = _isUndefined(options.dir) ? '' : path.relative(tmpDir, _resolvePath(options.dir, tmpDir));\n  options.template = _isUndefined(options.template) ? undefined : path.relative(tmpDir, _resolvePath(options.template, tmpDir));\n  // sanitize further if template is relative to options.dir\n  options.template = _isBlank(options.template) ? undefined : path.relative(options.dir, options.template);\n\n  // for completeness' sake only, also keep (multiple) blanks if the user, purportedly sane, requests us to\n  options.name = _isUndefined(options.name) ? undefined : _sanitizeName(options.name);\n  options.prefix = _isUndefined(options.prefix) ? '' : options.prefix;\n  options.postfix = _isUndefined(options.postfix) ? '' : options.postfix;\n}\n\n/**\n * Resolve the specified path name in respect to tmpDir.\n *\n * The specified name might include relative path components, e.g. ../\n * so we need to resolve in order to be sure that is is located inside tmpDir\n *\n * @param name\n * @param tmpDir\n * @returns {string}\n * @private\n */\nfunction _resolvePath(name, tmpDir) {\n  const sanitizedName = _sanitizeName(name);\n  if (sanitizedName.startsWith(tmpDir)) {\n    return path.resolve(sanitizedName);\n  } else {\n    return path.resolve(path.join(tmpDir, sanitizedName));\n  }\n}\n\n/**\n * Sanitize the specified path name by removing all quote characters.\n *\n * @param name\n * @returns {string}\n * @private\n */\nfunction _sanitizeName(name) {\n  if (_isBlank(name)) {\n    return name;\n  }\n  return name.replace(/[\"']/g, '');\n}\n\n/**\n * Asserts whether specified name is relative to the specified tmpDir.\n *\n * @param {string} name\n * @param {string} option\n * @param {string} tmpDir\n * @throws {Error}\n * @private\n */\nfunction _assertIsRelative(name, option, tmpDir) {\n  if (option === 'name') {\n    // assert that name is not absolute and does not contain a path\n    if (path.isAbsolute(name)) throw new Error(`${option} option must not contain an absolute path, found \"${name}\".`);\n    // must not fail on valid .<name> or ..<name> or similar such constructs\n    let basename = path.basename(name);\n    if (basename === '..' || basename === '.' || basename !== name) throw new Error(`${option} option must not contain a path, found \"${name}\".`);\n  } else {\n    // if (option === 'dir' || option === 'template') {\n    // assert that dir or template are relative to tmpDir\n    if (path.isAbsolute(name) && !name.startsWith(tmpDir)) {\n      throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${name}\".`);\n    }\n    let resolvedPath = _resolvePath(name, tmpDir);\n    if (!resolvedPath.startsWith(tmpDir)) throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${resolvedPath}\".`);\n  }\n}\n\n/**\n * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */\nfunction _isEBADF(error) {\n  return _isExpectedError(error, -EBADF, 'EBADF');\n}\n\n/**\n * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */\nfunction _isENOENT(error) {\n  return _isExpectedError(error, -ENOENT, 'ENOENT');\n}\n\n/**\n * Helper to determine whether the expected error code matches the actual code and errno,\n * which will differ between the supported node versions.\n *\n * - Node >= 7.0:\n *   error.code {string}\n *   error.errno {number} any numerical value will be negated\n *\n * CAVEAT\n *\n * On windows, the errno for EBADF is -4083 but os.constants.errno.EBADF is different and we must assume that ENOENT\n * is no different here.\n *\n * @param {SystemError} error\n * @param {number} errno\n * @param {string} code\n * @private\n */\nfunction _isExpectedError(error, errno, code) {\n  return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;\n}\n\n/**\n * Sets the graceful cleanup.\n *\n * If graceful cleanup is set, tmp will remove all controlled temporary objects on process exit, otherwise the\n * temporary objects will remain in place, waiting to be cleaned up on system restart or otherwise scheduled temporary\n * object removals.\n */\nfunction setGracefulCleanup() {\n  _gracefulCleanup = true;\n}\n\n/**\n * Returns the currently configured tmp dir from os.tmpdir().\n *\n * @private\n * @param {?Options} options\n * @returns {string} the currently configured tmp dir\n */\nfunction _getTmpDir(options) {\n  return path.resolve(_sanitizeName(options && options.tmpdir || os.tmpdir()));\n}\n\n// Install process exit listener\nprocess.addListener(EXIT, _garbageCollector);\n\n/**\n * Configuration options.\n *\n * @typedef {Object} Options\n * @property {?boolean} keep the temporary object (file or dir) will not be garbage collected\n * @property {?number} tries the number of tries before give up the name generation\n * @property (?int) mode the access mode, defaults are 0o700 for directories and 0o600 for files\n * @property {?string} template the \"mkstemp\" like filename template\n * @property {?string} name fixed name relative to tmpdir or the specified dir option\n * @property {?string} dir tmp directory relative to the root tmp directory in use\n * @property {?string} prefix prefix for the generated name\n * @property {?string} postfix postfix for the generated name\n * @property {?string} tmpdir the root tmp directory which overrides the os tmpdir\n * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty\n * @property {?boolean} detachDescriptor detaches the file descriptor, caller is responsible for closing the file, tmp will no longer try closing the file during garbage collection\n * @property {?boolean} discardDescriptor discards the file descriptor (closes file, fd is -1), tmp will no longer try closing the file during garbage collection\n */\n\n/**\n * @typedef {Object} FileSyncObject\n * @property {string} name the name of the file\n * @property {string} fd the file descriptor or -1 if the fd has been discarded\n * @property {fileCallback} removeCallback the callback function to remove the file\n */\n\n/**\n * @typedef {Object} DirSyncObject\n * @property {string} name the name of the directory\n * @property {fileCallback} removeCallback the callback function to remove the directory\n */\n\n/**\n * @callback tmpNameCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n */\n\n/**\n * @callback fileCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback fileCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallback\n * @param {simpleCallback} [next] function to call whenever the tmp object needs to be removed\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallbackSync\n */\n\n/**\n * Callback function for function composition.\n * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}\n *\n * @callback simpleCallback\n */\n\n// exporting all the needed methods\n\n// evaluate _getTmpDir() lazily, mainly for simplifying testing but it also will\n// allow users to reconfigure the temporary directory\nObject.defineProperty(module.exports, 'tmpdir', {\n  enumerable: true,\n  configurable: false,\n  get: function () {\n    return _getTmpDir();\n  }\n});\nmodule.exports.dir = dir;\nmodule.exports.dirSync = dirSync;\nmodule.exports.file = file;\nmodule.exports.fileSync = fileSync;\nmodule.exports.tmpName = tmpName;\nmodule.exports.tmpNameSync = tmpNameSync;\nmodule.exports.setGracefulCleanup = setGracefulCleanup;","map":{"version":3,"names":["fs","require","os","path","crypto","_c","constants","rimraf","RANDOM_CHARS","TEMPLATE_PATTERN","DEFAULT_TRIES","CREATE_FLAGS","O_CREAT","O_EXCL","O_RDWR","IS_WIN32","platform","EBADF","errno","ENOENT","DIR_MODE","FILE_MODE","EXIT","_removeObjects","FN_RMDIR_SYNC","rmdirSync","bind","FN_RIMRAF_SYNC","sync","_gracefulCleanup","tmpName","options","callback","args","_parseArguments","opts","cb","_assertAndSanitizeOptions","err","tries","_getUniqueName","name","_generateTmpName","stat","Error","tmpNameSync","statSync","e","file","_tmpNameCreated","open","mode","_fileCreated","fd","discardDescriptor","close","_discardCallback","possibleErr","undefined","_prepareTmpFileRemoveCallback","discardOrDetachDescriptor","detachDescriptor","fileSync","openSync","closeSync","removeCallback","dir","mkdir","_dirCreated","_prepareTmpDirRemoveCallback","dirSync","mkdirSync","_removeFileAsync","fdPath","next","_handler","_isENOENT","unlink","_removeFileSync","rethrownException","_isEBADF","unlinkSync","removeCallbackSync","_prepareRemoveCallback","keep","unshift","removeFunction","unsafeCleanup","rmdir","removeFunctionSync","fileOrDirName","cleanupCallbackSync","called","_cleanupCallback","toRemove","index","indexOf","splice","_garbageCollector","length","_randomChars","howMany","value","rnd","randomBytes","pseudoRandomBytes","i","push","join","_isBlank","s","_isUndefined","trim","obj","actualOptions","key","Object","getOwnPropertyNames","tmpDir","tmpdir","template","replace","prefix","process","pid","postfix","_getTmpDir","_assertIsRelative","match","isNaN","relative","_resolvePath","_sanitizeName","sanitizedName","startsWith","resolve","option","isAbsolute","basename","resolvedPath","error","_isExpectedError","code","setGracefulCleanup","addListener","defineProperty","module","exports","enumerable","configurable","get"],"sources":["/Users/Shared/ATS Git/ATSDemo/ReactJs/ReactCaseStudy/my-app/node_modules/tmp/lib/tmp.js"],"sourcesContent":["/*!\n * Tmp\n *\n * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */\n\n/*\n * Module dependencies.\n */\nconst fs = require('fs');\nconst os = require('os');\nconst path = require('path');\nconst crypto = require('crypto');\nconst _c = { fs: fs.constants, os: os.constants };\nconst rimraf = require('rimraf');\n\n/*\n * The working inner variables.\n */\nconst\n  // the random characters to choose from\n  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n\n  TEMPLATE_PATTERN = /XXXXXX/,\n\n  DEFAULT_TRIES = 3,\n\n  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),\n\n  // constants are off on the windows platform and will not match the actual errno codes\n  IS_WIN32 = os.platform() === 'win32',\n  EBADF = _c.EBADF || _c.os.errno.EBADF,\n  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,\n\n  DIR_MODE = 0o700 /* 448 */,\n  FILE_MODE = 0o600 /* 384 */,\n\n  EXIT = 'exit',\n\n  // this will hold the objects need to be removed on exit\n  _removeObjects = [],\n\n  // API change in fs.rmdirSync leads to error when passing in a second parameter, e.g. the callback\n  FN_RMDIR_SYNC = fs.rmdirSync.bind(fs),\n  FN_RIMRAF_SYNC = rimraf.sync;\n\nlet\n  _gracefulCleanup = false;\n\n/**\n * Gets a temporary file name.\n *\n * @param {(Options|tmpNameCallback)} options options or callback\n * @param {?tmpNameCallback} callback the callback function\n */\nfunction tmpName(options, callback) {\n  const\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  try {\n    _assertAndSanitizeOptions(opts);\n  } catch (err) {\n    return cb(err);\n  }\n\n  let tries = opts.tries;\n  (function _getUniqueName() {\n    try {\n      const name = _generateTmpName(opts);\n\n      // check whether the path exists then retry if needed\n      fs.stat(name, function (err) {\n        /* istanbul ignore else */\n        if (!err) {\n          /* istanbul ignore else */\n          if (tries-- > 0) return _getUniqueName();\n\n          return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));\n        }\n\n        cb(null, name);\n      });\n    } catch (err) {\n      cb(err);\n    }\n  }());\n}\n\n/**\n * Synchronous version of tmpName.\n *\n * @param {Object} options\n * @returns {string} the generated random name\n * @throws {Error} if the options are invalid or could not generate a filename\n */\nfunction tmpNameSync(options) {\n  const\n    args = _parseArguments(options),\n    opts = args[0];\n\n  _assertAndSanitizeOptions(opts);\n\n  let tries = opts.tries;\n  do {\n    const name = _generateTmpName(opts);\n    try {\n      fs.statSync(name);\n    } catch (e) {\n      return name;\n    }\n  } while (tries-- > 0);\n\n  throw new Error('Could not get a unique tmp filename, max tries reached');\n}\n\n/**\n * Creates and opens a temporary file.\n *\n * @param {(Options|null|undefined|fileCallback)} options the config options or the callback function or null or undefined\n * @param {?fileCallback} callback\n */\nfunction file(options, callback) {\n  const\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create and open the file\n    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n      /* istanbu ignore else */\n      if (err) return cb(err);\n\n      if (opts.discardDescriptor) {\n        return fs.close(fd, function _discardCallback(possibleErr) {\n          // the chance of getting an error on close here is rather low and might occur in the most edgiest cases only\n          return cb(possibleErr, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts, false));\n        });\n      } else {\n        // detachDescriptor passes the descriptor whereas discardDescriptor closes it, either way, we no longer care\n        // about the descriptor\n        const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n        cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));\n      }\n    });\n  });\n}\n\n/**\n * Synchronous version of file.\n *\n * @param {Options} options\n * @returns {FileSyncObject} object consists of name, fd and removeCallback\n * @throws {Error} if cannot create a file\n */\nfunction fileSync(options) {\n  const\n    args = _parseArguments(options),\n    opts = args[0];\n\n  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n  const name = tmpNameSync(opts);\n  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n  /* istanbul ignore else */\n  if (opts.discardDescriptor) {\n    fs.closeSync(fd);\n    fd = undefined;\n  }\n\n  return {\n    name: name,\n    fd: fd,\n    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)\n  };\n}\n\n/**\n * Creates a temporary directory.\n *\n * @param {(Options|dirCallback)} options the options or the callback function\n * @param {?dirCallback} callback\n */\nfunction dir(options, callback) {\n  const\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create the directory\n    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n      /* istanbul ignore else */\n      if (err) return cb(err);\n\n      cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));\n    });\n  });\n}\n\n/**\n * Synchronous version of dir.\n *\n * @param {Options} options\n * @returns {DirSyncObject} object consists of name and removeCallback\n * @throws {Error} if it cannot create a directory\n */\nfunction dirSync(options) {\n  const\n    args = _parseArguments(options),\n    opts = args[0];\n\n  const name = tmpNameSync(opts);\n  fs.mkdirSync(name, opts.mode || DIR_MODE);\n\n  return {\n    name: name,\n    removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)\n  };\n}\n\n/**\n * Removes files asynchronously.\n *\n * @param {Object} fdPath\n * @param {Function} next\n * @private\n */\nfunction _removeFileAsync(fdPath, next) {\n  const _handler = function (err) {\n    if (err && !_isENOENT(err)) {\n      // reraise any unanticipated error\n      return next(err);\n    }\n    next();\n  };\n\n  if (0 <= fdPath[0])\n    fs.close(fdPath[0], function () {\n      fs.unlink(fdPath[1], _handler);\n    });\n  else fs.unlink(fdPath[1], _handler);\n}\n\n/**\n * Removes files synchronously.\n *\n * @param {Object} fdPath\n * @private\n */\nfunction _removeFileSync(fdPath) {\n  let rethrownException = null;\n  try {\n    if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);\n  } catch (e) {\n    // reraise any unanticipated error\n    if (!_isEBADF(e) && !_isENOENT(e)) throw e;\n  } finally {\n    try {\n      fs.unlinkSync(fdPath[1]);\n    }\n    catch (e) {\n      // reraise any unanticipated error\n      if (!_isENOENT(e)) rethrownException = e;\n    }\n  }\n  if (rethrownException !== null) {\n    throw rethrownException;\n  }\n}\n\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * Returns either a sync callback or a async callback depending on whether\n * fileSync or file was called, which is expressed by the sync parameter.\n *\n * @param {string} name the path of the file\n * @param {number} fd file descriptor\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {fileCallback | fileCallbackSync}\n * @private\n */\nfunction _prepareTmpFileRemoveCallback(name, fd, opts, sync) {\n  const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync);\n  const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync, removeCallbackSync);\n\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n\n  return sync ? removeCallbackSync : removeCallback;\n}\n\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * Returns either a sync callback or a async callback depending on whether\n * tmpFileSync or tmpFile was called, which is expressed by the sync parameter.\n *\n * @param {string} name\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {Function} the callback\n * @private\n */\nfunction _prepareTmpDirRemoveCallback(name, opts, sync) {\n  const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);\n  const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;\n  const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);\n  const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n\n  return sync ? removeCallbackSync : removeCallback;\n}\n\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * The cleanup callback is save to be called multiple times.\n * Subsequent invocations will be ignored.\n *\n * @param {Function} removeFunction\n * @param {string} fileOrDirName\n * @param {boolean} sync\n * @param {cleanupCallbackSync?} cleanupCallbackSync\n * @returns {cleanupCallback | cleanupCallbackSync}\n * @private\n */\nfunction _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {\n  let called = false;\n\n  // if sync is true, the next parameter will be ignored\n  return function _cleanupCallback(next) {\n\n    /* istanbul ignore else */\n    if (!called) {\n      // remove cleanupCallback from cache\n      const toRemove = cleanupCallbackSync || _cleanupCallback;\n      const index = _removeObjects.indexOf(toRemove);\n      /* istanbul ignore else */\n      if (index >= 0) _removeObjects.splice(index, 1);\n\n      called = true;\n      if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {\n        return removeFunction(fileOrDirName);\n      } else {\n        return removeFunction(fileOrDirName, next || function() {});\n      }\n    }\n  };\n}\n\n/**\n * The garbage collector.\n *\n * @private\n */\nfunction _garbageCollector() {\n  /* istanbul ignore else */\n  if (!_gracefulCleanup) return;\n\n  // the function being called removes itself from _removeObjects,\n  // loop until _removeObjects is empty\n  while (_removeObjects.length) {\n    try {\n      _removeObjects[0]();\n    } catch (e) {\n      // already removed?\n    }\n  }\n}\n\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {number} howMany\n * @returns {string} the generated random name\n * @private\n */\nfunction _randomChars(howMany) {\n  let\n    value = [],\n    rnd = null;\n\n  // make sure that we do not fail because we ran out of entropy\n  try {\n    rnd = crypto.randomBytes(howMany);\n  } catch (e) {\n    rnd = crypto.pseudoRandomBytes(howMany);\n  }\n\n  for (var i = 0; i < howMany; i++) {\n    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n  }\n\n  return value.join('');\n}\n\n/**\n * Helper which determines whether a string s is blank, that is undefined, or empty or null.\n *\n * @private\n * @param {string} s\n * @returns {Boolean} true whether the string s is blank, false otherwise\n */\nfunction _isBlank(s) {\n  return s === null || _isUndefined(s) || !s.trim();\n}\n\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @returns {boolean} true if the object is undefined\n * @private\n */\nfunction _isUndefined(obj) {\n  return typeof obj === 'undefined';\n}\n\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {(Options|null|undefined|Function)} options\n * @param {?Function} callback\n * @returns {Array} parsed arguments\n * @private\n */\nfunction _parseArguments(options, callback) {\n  /* istanbul ignore else */\n  if (typeof options === 'function') {\n    return [{}, options];\n  }\n\n  /* istanbul ignore else */\n  if (_isUndefined(options)) {\n    return [{}, callback];\n  }\n\n  // copy options so we do not leak the changes we make internally\n  const actualOptions = {};\n  for (const key of Object.getOwnPropertyNames(options)) {\n    actualOptions[key] = options[key];\n  }\n\n  return [actualOptions, callback];\n}\n\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {string} the new random name according to opts\n * @private\n */\nfunction _generateTmpName(opts) {\n\n  const tmpDir = opts.tmpdir;\n\n  /* istanbul ignore else */\n  if (!_isUndefined(opts.name))\n    return path.join(tmpDir, opts.dir, opts.name);\n\n  /* istanbul ignore else */\n  if (!_isUndefined(opts.template))\n    return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));\n\n  // prefix and postfix\n  const name = [\n    opts.prefix ? opts.prefix : 'tmp',\n    '-',\n    process.pid,\n    '-',\n    _randomChars(12),\n    opts.postfix ? '-' + opts.postfix : ''\n  ].join('');\n\n  return path.join(tmpDir, opts.dir, name);\n}\n\n/**\n * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing\n * options.\n *\n * @param {Options} options\n * @private\n */\nfunction _assertAndSanitizeOptions(options) {\n\n  options.tmpdir = _getTmpDir(options);\n\n  const tmpDir = options.tmpdir;\n\n  /* istanbul ignore else */\n  if (!_isUndefined(options.name))\n    _assertIsRelative(options.name, 'name', tmpDir);\n  /* istanbul ignore else */\n  if (!_isUndefined(options.dir))\n    _assertIsRelative(options.dir, 'dir', tmpDir);\n  /* istanbul ignore else */\n  if (!_isUndefined(options.template)) {\n    _assertIsRelative(options.template, 'template', tmpDir);\n    if (!options.template.match(TEMPLATE_PATTERN))\n      throw new Error(`Invalid template, found \"${options.template}\".`);\n  }\n  /* istanbul ignore else */\n  if (!_isUndefined(options.tries) && isNaN(options.tries) || options.tries < 0)\n    throw new Error(`Invalid tries, found \"${options.tries}\".`);\n\n  // if a name was specified we will try once\n  options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;\n  options.keep = !!options.keep;\n  options.detachDescriptor = !!options.detachDescriptor;\n  options.discardDescriptor = !!options.discardDescriptor;\n  options.unsafeCleanup = !!options.unsafeCleanup;\n\n  // sanitize dir, also keep (multiple) blanks if the user, purportedly sane, requests us to\n  options.dir = _isUndefined(options.dir) ? '' : path.relative(tmpDir, _resolvePath(options.dir, tmpDir));\n  options.template = _isUndefined(options.template) ? undefined : path.relative(tmpDir, _resolvePath(options.template, tmpDir));\n  // sanitize further if template is relative to options.dir\n  options.template = _isBlank(options.template) ? undefined : path.relative(options.dir, options.template);\n\n  // for completeness' sake only, also keep (multiple) blanks if the user, purportedly sane, requests us to\n  options.name = _isUndefined(options.name) ? undefined : _sanitizeName(options.name);\n  options.prefix = _isUndefined(options.prefix) ? '' : options.prefix;\n  options.postfix = _isUndefined(options.postfix) ? '' : options.postfix;\n}\n\n/**\n * Resolve the specified path name in respect to tmpDir.\n *\n * The specified name might include relative path components, e.g. ../\n * so we need to resolve in order to be sure that is is located inside tmpDir\n *\n * @param name\n * @param tmpDir\n * @returns {string}\n * @private\n */\nfunction _resolvePath(name, tmpDir) {\n  const sanitizedName = _sanitizeName(name);\n  if (sanitizedName.startsWith(tmpDir)) {\n    return path.resolve(sanitizedName);\n  } else {\n    return path.resolve(path.join(tmpDir, sanitizedName));\n  }\n}\n\n/**\n * Sanitize the specified path name by removing all quote characters.\n *\n * @param name\n * @returns {string}\n * @private\n */\nfunction _sanitizeName(name) {\n  if (_isBlank(name)) {\n    return name;\n  }\n  return name.replace(/[\"']/g, '');\n}\n\n/**\n * Asserts whether specified name is relative to the specified tmpDir.\n *\n * @param {string} name\n * @param {string} option\n * @param {string} tmpDir\n * @throws {Error}\n * @private\n */\nfunction _assertIsRelative(name, option, tmpDir) {\n  if (option === 'name') {\n    // assert that name is not absolute and does not contain a path\n    if (path.isAbsolute(name))\n      throw new Error(`${option} option must not contain an absolute path, found \"${name}\".`);\n    // must not fail on valid .<name> or ..<name> or similar such constructs\n    let basename = path.basename(name);\n    if (basename === '..' || basename === '.' || basename !== name)\n      throw new Error(`${option} option must not contain a path, found \"${name}\".`);\n  }\n  else { // if (option === 'dir' || option === 'template') {\n    // assert that dir or template are relative to tmpDir\n    if (path.isAbsolute(name) && !name.startsWith(tmpDir)) {\n      throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${name}\".`);\n    }\n    let resolvedPath = _resolvePath(name, tmpDir);\n    if (!resolvedPath.startsWith(tmpDir))\n      throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${resolvedPath}\".`);\n  }\n}\n\n/**\n * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */\nfunction _isEBADF(error) {\n  return _isExpectedError(error, -EBADF, 'EBADF');\n}\n\n/**\n * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */\nfunction _isENOENT(error) {\n  return _isExpectedError(error, -ENOENT, 'ENOENT');\n}\n\n/**\n * Helper to determine whether the expected error code matches the actual code and errno,\n * which will differ between the supported node versions.\n *\n * - Node >= 7.0:\n *   error.code {string}\n *   error.errno {number} any numerical value will be negated\n *\n * CAVEAT\n *\n * On windows, the errno for EBADF is -4083 but os.constants.errno.EBADF is different and we must assume that ENOENT\n * is no different here.\n *\n * @param {SystemError} error\n * @param {number} errno\n * @param {string} code\n * @private\n */\nfunction _isExpectedError(error, errno, code) {\n  return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;\n}\n\n/**\n * Sets the graceful cleanup.\n *\n * If graceful cleanup is set, tmp will remove all controlled temporary objects on process exit, otherwise the\n * temporary objects will remain in place, waiting to be cleaned up on system restart or otherwise scheduled temporary\n * object removals.\n */\nfunction setGracefulCleanup() {\n  _gracefulCleanup = true;\n}\n\n/**\n * Returns the currently configured tmp dir from os.tmpdir().\n *\n * @private\n * @param {?Options} options\n * @returns {string} the currently configured tmp dir\n */\nfunction _getTmpDir(options) {\n  return path.resolve(_sanitizeName(options && options.tmpdir || os.tmpdir()));\n}\n\n// Install process exit listener\nprocess.addListener(EXIT, _garbageCollector);\n\n/**\n * Configuration options.\n *\n * @typedef {Object} Options\n * @property {?boolean} keep the temporary object (file or dir) will not be garbage collected\n * @property {?number} tries the number of tries before give up the name generation\n * @property (?int) mode the access mode, defaults are 0o700 for directories and 0o600 for files\n * @property {?string} template the \"mkstemp\" like filename template\n * @property {?string} name fixed name relative to tmpdir or the specified dir option\n * @property {?string} dir tmp directory relative to the root tmp directory in use\n * @property {?string} prefix prefix for the generated name\n * @property {?string} postfix postfix for the generated name\n * @property {?string} tmpdir the root tmp directory which overrides the os tmpdir\n * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty\n * @property {?boolean} detachDescriptor detaches the file descriptor, caller is responsible for closing the file, tmp will no longer try closing the file during garbage collection\n * @property {?boolean} discardDescriptor discards the file descriptor (closes file, fd is -1), tmp will no longer try closing the file during garbage collection\n */\n\n/**\n * @typedef {Object} FileSyncObject\n * @property {string} name the name of the file\n * @property {string} fd the file descriptor or -1 if the fd has been discarded\n * @property {fileCallback} removeCallback the callback function to remove the file\n */\n\n/**\n * @typedef {Object} DirSyncObject\n * @property {string} name the name of the directory\n * @property {fileCallback} removeCallback the callback function to remove the directory\n */\n\n/**\n * @callback tmpNameCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n */\n\n/**\n * @callback fileCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback fileCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallback\n * @param {simpleCallback} [next] function to call whenever the tmp object needs to be removed\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallbackSync\n */\n\n/**\n * Callback function for function composition.\n * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}\n *\n * @callback simpleCallback\n */\n\n// exporting all the needed methods\n\n// evaluate _getTmpDir() lazily, mainly for simplifying testing but it also will\n// allow users to reconfigure the temporary directory\nObject.defineProperty(module.exports, 'tmpdir', {\n  enumerable: true,\n  configurable: false,\n  get: function () {\n    return _getTmpDir();\n  }\n});\n\nmodule.exports.dir = dir;\nmodule.exports.dirSync = dirSync;\n\nmodule.exports.file = file;\nmodule.exports.fileSync = fileSync;\n\nmodule.exports.tmpName = tmpName;\nmodule.exports.tmpNameSync = tmpNameSync;\n\nmodule.exports.setGracefulCleanup = setGracefulCleanup;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}