{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nconst {\n  EventEmitter\n} = require('node:events');\nconst WebSocket = require('ws');\nconst RESPONSE_TIMEOUT = 1000 * 30;\nclass Index extends EventEmitter {\n  id = 0;\n  isConnected = false;\n  events = [];\n  browsingContexts = [];\n\n  /**\n   * Create a new websocket connection\n   * @param _webSocketUrl\n   */\n  constructor(_webSocketUrl) {\n    super();\n    this.isConnected = false;\n    this._ws = new WebSocket(_webSocketUrl);\n    this._ws.on('open', () => {\n      this.isConnected = true;\n    });\n  }\n\n  /**\n   * Resolve connection\n   * @returns {Promise<unknown>}\n   */\n  async waitForConnection() {\n    return new Promise(resolve => {\n      if (this.isConnected) {\n        resolve();\n      } else {\n        this._ws.once('open', () => {\n          resolve();\n        });\n      }\n    });\n  }\n\n  /**\n   * @returns {WebSocket}\n   */\n  get socket() {\n    return this._ws;\n  }\n\n  /**\n   * @returns {boolean|*}\n   */\n  get isConnected() {\n    return this.isConnected;\n  }\n\n  /**\n   * Sends a bidi request\n   * @param params\n   * @returns {Promise<unknown>}\n   */\n  async send(params) {\n    if (!this.isConnected) {\n      await this.waitForConnection();\n    }\n    const id = ++this.id;\n    this._ws.send(JSON.stringify({\n      id,\n      ...params\n    }));\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new Error(`Request with id ${id} timed out`));\n        handler.off('message', listener);\n      }, RESPONSE_TIMEOUT);\n      const listener = data => {\n        try {\n          const payload = JSON.parse(data.toString());\n          if (payload.id === id) {\n            clearTimeout(timeoutId);\n            handler.off('message', listener);\n            resolve(payload);\n          }\n        } catch (err) {\n          log.error(`Failed parse message: ${err.message}`);\n        }\n      };\n      const handler = this._ws.on('message', listener);\n    });\n  }\n\n  /**\n   * Subscribe to events\n   * @param events\n   * @param browsingContexts\n   * @returns {Promise<void>}\n   */\n  async subscribe(events, browsingContexts) {\n    function toArray(arg) {\n      if (arg === undefined) {\n        return [];\n      }\n      return Array.isArray(arg) ? [...arg] : [arg];\n    }\n    const eventsArray = toArray(events);\n    const contextsArray = toArray(browsingContexts);\n    const params = {\n      method: 'session.subscribe',\n      params: {}\n    };\n    if (eventsArray.length && eventsArray.some(event => typeof event !== 'string')) {\n      throw new TypeError('events should be string or string array');\n    }\n    if (contextsArray.length && contextsArray.some(context => typeof context !== 'string')) {\n      throw new TypeError('browsingContexts should be string or string array');\n    }\n    if (eventsArray.length) {\n      params.params.events = eventsArray;\n    }\n    if (contextsArray.length) {\n      params.params.contexts = contextsArray;\n    }\n    await this.send(params);\n  }\n\n  /**\n   * Unsubscribe to events\n   * @param events\n   * @param browsingContexts\n   * @returns {Promise<void>}\n   */\n  async unsubscribe(events, browsingContexts) {\n    if (typeof events === 'string') {\n      this.events = this.events.filter(event => event !== events);\n    } else if (Array.isArray(events)) {\n      this.events = this.events.filter(event => !events.includes(event));\n    }\n    if (typeof browsingContexts === 'string') {\n      this.browsingContexts.pop();\n    } else if (Array.isArray(browsingContexts)) {\n      this.browsingContexts = this.browsingContexts.filter(id => !browsingContexts.includes(id));\n    }\n    const params = {\n      method: 'session.unsubscribe',\n      params: {\n        events: this.events\n      }\n    };\n    if (this.browsingContexts.length > 0) {\n      params.params.contexts = this.browsingContexts;\n    }\n    await this.send(params);\n  }\n\n  /**\n   * Get Bidi Status\n   * @returns {Promise<*>}\n   */\n  get status() {\n    return this.send({\n      method: 'session.status',\n      params: {}\n    });\n  }\n\n  /**\n   * Close ws connection.\n   * @returns {Promise<unknown>}\n   */\n  close() {\n    const closeWebSocket = callback => {\n      // don't close if it's already closed\n      if (this._ws.readyState === 3) {\n        callback();\n      } else {\n        // don't notify on user-initiated shutdown ('disconnect' event)\n        this._ws.removeAllListeners('close');\n        this._ws.once('close', () => {\n          this._ws.removeAllListeners();\n          callback();\n        });\n        this._ws.close();\n      }\n    };\n    return new Promise((fulfill, reject) => {\n      closeWebSocket(fulfill);\n    });\n  }\n}\n\n/**\n * API\n * @type {function(*): Promise<Index>}\n */\nmodule.exports = Index;","map":{"version":3,"names":["EventEmitter","require","WebSocket","RESPONSE_TIMEOUT","Index","id","isConnected","events","browsingContexts","constructor","_webSocketUrl","_ws","on","waitForConnection","Promise","resolve","once","socket","send","params","JSON","stringify","reject","timeoutId","setTimeout","Error","handler","off","listener","data","payload","parse","toString","clearTimeout","err","log","error","message","subscribe","toArray","arg","undefined","Array","isArray","eventsArray","contextsArray","method","length","some","event","TypeError","context","contexts","unsubscribe","filter","includes","pop","status","close","closeWebSocket","callback","readyState","removeAllListeners","fulfill","module","exports"],"sources":["/Users/Shared/ATS Git/ATSDemo/ReactJs/ReactCaseStudy/my-app/node_modules/selenium-webdriver/bidi/index.js"],"sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nconst { EventEmitter } = require('node:events')\nconst WebSocket = require('ws')\n\nconst RESPONSE_TIMEOUT = 1000 * 30\n\nclass Index extends EventEmitter {\n  id = 0\n  isConnected = false\n  events = []\n  browsingContexts = []\n\n  /**\n   * Create a new websocket connection\n   * @param _webSocketUrl\n   */\n  constructor (_webSocketUrl) {\n    super()\n    this.isConnected = false\n    this._ws = new WebSocket(_webSocketUrl)\n    this._ws.on('open', () => {\n      this.isConnected = true\n    })\n  }\n\n  /**\n   * Resolve connection\n   * @returns {Promise<unknown>}\n   */\n  async waitForConnection () {\n    return new Promise((resolve) => {\n      if (this.isConnected) {\n        resolve()\n      } else {\n        this._ws.once('open', () => {\n          resolve()\n        })\n      }\n    })\n  }\n\n  /**\n   * @returns {WebSocket}\n   */\n  get socket () {\n    return this._ws\n  }\n\n  /**\n   * @returns {boolean|*}\n   */\n  get isConnected () {\n    return this.isConnected\n  }\n\n  /**\n   * Sends a bidi request\n   * @param params\n   * @returns {Promise<unknown>}\n   */\n  async send (params) {\n    if (!this.isConnected) {\n      await this.waitForConnection()\n    }\n\n    const id = ++this.id\n\n    this._ws.send(JSON.stringify({ id, ...params }))\n\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new Error(`Request with id ${id} timed out`))\n        handler.off('message', listener)\n      }, RESPONSE_TIMEOUT)\n\n      const listener = (data) => {\n        try {\n          const payload = JSON.parse(data.toString())\n          if (payload.id === id) {\n            clearTimeout(timeoutId)\n            handler.off('message', listener)\n            resolve(payload)\n          }\n        } catch (err) {\n          log.error(`Failed parse message: ${err.message}`)\n        }\n      }\n\n      const handler = this._ws.on('message', listener)\n    })\n  }\n\n  /**\n   * Subscribe to events\n   * @param events\n   * @param browsingContexts\n   * @returns {Promise<void>}\n   */\n  async subscribe (events, browsingContexts) {\n    function toArray (arg) {\n      if (arg === undefined) {\n        return []\n      }\n\n      return Array.isArray(arg) ? [...arg] : [arg]\n    }\n\n    const eventsArray = toArray(events)\n    const contextsArray = toArray(browsingContexts)\n\n    const params = {\n      method: 'session.subscribe', params: {},\n    }\n\n    if (eventsArray.length && eventsArray.some(\n      event => typeof event !== 'string')) {\n      throw new TypeError('events should be string or string array')\n    }\n\n    if (contextsArray.length && contextsArray.some(\n      context => typeof context !== 'string')) {\n      throw new TypeError('browsingContexts should be string or string array')\n    }\n\n    if (eventsArray.length) {\n      params.params.events = eventsArray\n    }\n\n    if (contextsArray.length) {\n      params.params.contexts = contextsArray\n    }\n\n    await this.send(params)\n  }\n\n  /**\n   * Unsubscribe to events\n   * @param events\n   * @param browsingContexts\n   * @returns {Promise<void>}\n   */\n  async unsubscribe (events, browsingContexts) {\n    if (typeof events === 'string') {\n      this.events = this.events.filter(event => event !== events)\n    } else if (Array.isArray(events)) {\n      this.events = this.events.filter(event => !events.includes(event))\n    }\n\n    if (typeof browsingContexts === 'string') {\n      this.browsingContexts.pop()\n    } else if (Array.isArray(browsingContexts)) {\n      this.browsingContexts =\n        this.browsingContexts.filter(id => !browsingContexts.includes(id))\n    }\n\n    const params = {\n      method: 'session.unsubscribe', params: {\n        events: this.events,\n      }\n    }\n\n    if (this.browsingContexts.length > 0) {\n      params.params.contexts = this.browsingContexts\n    }\n\n    await this.send(params)\n  }\n\n  /**\n   * Get Bidi Status\n   * @returns {Promise<*>}\n   */\n  get status () {\n    return this.send({\n      method: 'session.status', params: {}\n    })\n  }\n\n  /**\n   * Close ws connection.\n   * @returns {Promise<unknown>}\n   */\n  close () {\n    const closeWebSocket = (callback) => {\n      // don't close if it's already closed\n      if (this._ws.readyState === 3) {\n        callback()\n      } else {\n        // don't notify on user-initiated shutdown ('disconnect' event)\n        this._ws.removeAllListeners('close')\n        this._ws.once('close', () => {\n          this._ws.removeAllListeners()\n          callback()\n        })\n        this._ws.close()\n      }\n    }\n    return new Promise((fulfill, reject) => {\n      closeWebSocket(fulfill)\n    })\n  }\n}\n\n/**\n * API\n * @type {function(*): Promise<Index>}\n */\nmodule.exports = Index\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}