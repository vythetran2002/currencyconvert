{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport { isEndOfRange, isStartOfRange } from '../internal/utils/date-utils';\nconst resolveDateFromTarget = (target, utils) => {\n  const timestampString = target.dataset.timestamp;\n  if (!timestampString) {\n    return null;\n  }\n  const timestamp = +timestampString;\n  return utils.date(new Date(timestamp));\n};\nconst isSameAsDraggingDate = event => {\n  const timestampString = event.target.dataset.timestamp;\n  return timestampString === event.dataTransfer.getData('draggingDate');\n};\nconst resolveButtonElement = element => {\n  if (element) {\n    if (element instanceof HTMLButtonElement && !element.disabled) {\n      return element;\n    }\n    if (element.children.length) {\n      return resolveButtonElement(element.children[0]);\n    }\n    return null;\n  }\n  return element;\n};\nconst resolveElementFromTouch = (event, ignoreTouchTarget) => {\n  var _event$changedTouches;\n  // don't parse multi-touch result\n  if (((_event$changedTouches = event.changedTouches) == null ? void 0 : _event$changedTouches.length) === 1 && event.touches.length <= 1) {\n    const element = document.elementFromPoint(event.changedTouches[0].clientX, event.changedTouches[0].clientY);\n    // `elementFromPoint` could have resolved preview div or wrapping div\n    // might need to recursively find the nested button\n    const buttonElement = resolveButtonElement(element);\n    if (ignoreTouchTarget && buttonElement === event.changedTouches[0].target) {\n      return null;\n    }\n    return buttonElement;\n  }\n  return null;\n};\nconst useDragRangeEvents = _ref => {\n  let {\n    utils,\n    setRangeDragDay,\n    setIsDragging,\n    isDragging,\n    onDatePositionChange,\n    onDrop,\n    disableDragEditing,\n    dateRange\n  } = _ref;\n  const emptyDragImgRef = React.useRef(null);\n  React.useEffect(() => {\n    // Preload the image - required for Safari support: https://stackoverflow.com/a/40923520/3303436\n    emptyDragImgRef.current = document.createElement('img');\n    emptyDragImgRef.current.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\n  }, []);\n  const isElementDraggable = day => {\n    if (day == null) {\n      return false;\n    }\n    const shouldInitDragging = !disableDragEditing && !!dateRange[0] && !!dateRange[1];\n    const isSelectedStartDate = isStartOfRange(utils, day, dateRange);\n    const isSelectedEndDate = isEndOfRange(utils, day, dateRange);\n    return shouldInitDragging && (isSelectedStartDate || isSelectedEndDate);\n  };\n  const handleDragStart = useEventCallback(event => {\n    const newDate = resolveDateFromTarget(event.target, utils);\n    if (!isElementDraggable(newDate)) {\n      return;\n    }\n    event.stopPropagation();\n    if (emptyDragImgRef.current) {\n      event.dataTransfer.setDragImage(emptyDragImgRef.current, 0, 0);\n    }\n    setRangeDragDay(newDate);\n    event.dataTransfer.effectAllowed = 'move';\n    setIsDragging(true);\n    const buttonDataset = event.target.dataset;\n    if (buttonDataset.timestamp) {\n      event.dataTransfer.setData('draggingDate', buttonDataset.timestamp);\n    }\n    if (buttonDataset.position) {\n      onDatePositionChange(buttonDataset.position);\n    }\n  });\n  const handleTouchStart = useEventCallback(event => {\n    const target = resolveElementFromTouch(event);\n    if (!target) {\n      return;\n    }\n    const newDate = resolveDateFromTarget(target, utils);\n    if (!isElementDraggable(newDate)) {\n      return;\n    }\n    setRangeDragDay(newDate);\n    setIsDragging(true);\n    const button = event.target;\n    const buttonDataset = button.dataset;\n    if (buttonDataset.position) {\n      onDatePositionChange(buttonDataset.position);\n    }\n  });\n  const handleDragEnter = useEventCallback(event => {\n    if (!isDragging) {\n      return;\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    event.dataTransfer.dropEffect = 'move';\n    setRangeDragDay(resolveDateFromTarget(event.target, utils));\n  });\n  const handleTouchMove = useEventCallback(event => {\n    const target = resolveElementFromTouch(event);\n    if (!isDragging || !target) {\n      return;\n    }\n    const newDate = resolveDateFromTarget(target, utils);\n    if (newDate) {\n      setRangeDragDay(newDate);\n    }\n  });\n  const handleDragLeave = useEventCallback(event => {\n    if (!isDragging) {\n      return;\n    }\n    event.preventDefault();\n    event.stopPropagation();\n  });\n  const handleDragOver = useEventCallback(event => {\n    if (!isDragging) {\n      return;\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    event.dataTransfer.dropEffect = 'move';\n  });\n  const handleTouchEnd = useEventCallback(event => {\n    if (!isDragging) {\n      return;\n    }\n    setRangeDragDay(null);\n    setIsDragging(false);\n    const target = resolveElementFromTouch(event, true);\n    if (!target) {\n      return;\n    }\n\n    // make sure the focused element is the element where touch ended\n    target.focus();\n    const newDate = resolveDateFromTarget(target, utils);\n    if (newDate) {\n      onDrop(newDate);\n    }\n  });\n  const handleDragEnd = useEventCallback(event => {\n    if (!isDragging) {\n      return;\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    setIsDragging(false);\n    setRangeDragDay(null);\n  });\n  const handleDrop = useEventCallback(event => {\n    if (!isDragging) {\n      return;\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    setIsDragging(false);\n    setRangeDragDay(null);\n    // make sure the focused element is the element where drop ended\n    event.currentTarget.focus();\n    if (isSameAsDraggingDate(event)) {\n      return;\n    }\n    const newDate = resolveDateFromTarget(event.target, utils);\n    if (newDate) {\n      onDrop(newDate);\n    }\n  });\n  return {\n    onDragStart: handleDragStart,\n    onDragEnter: handleDragEnter,\n    onDragLeave: handleDragLeave,\n    onDragOver: handleDragOver,\n    onDragEnd: handleDragEnd,\n    onDrop: handleDrop,\n    onTouchStart: handleTouchStart,\n    onTouchMove: handleTouchMove,\n    onTouchEnd: handleTouchEnd\n  };\n};\nexport const useDragRange = _ref2 => {\n  let {\n    disableDragEditing,\n    utils,\n    onDatePositionChange,\n    onDrop,\n    dateRange\n  } = _ref2;\n  const [isDragging, setIsDragging] = React.useState(false);\n  const [rangeDragDay, setRangeDragDay] = React.useState(null);\n  const handleRangeDragDayChange = useEventCallback(val => {\n    if (!utils.isEqual(val, rangeDragDay)) {\n      setRangeDragDay(val);\n    }\n  });\n  const draggingDatePosition = React.useMemo(() => {\n    const [start, end] = dateRange;\n    if (rangeDragDay) {\n      if (start && utils.isBefore(rangeDragDay, start)) {\n        return 'start';\n      }\n      if (end && utils.isAfter(rangeDragDay, end)) {\n        return 'end';\n      }\n    }\n    return null;\n  }, [dateRange, rangeDragDay, utils]);\n  const dragRangeEvents = useDragRangeEvents({\n    utils,\n    onDatePositionChange,\n    onDrop,\n    setIsDragging,\n    isDragging,\n    setRangeDragDay: handleRangeDragDayChange,\n    disableDragEditing,\n    dateRange\n  });\n  return React.useMemo(() => _extends({\n    isDragging,\n    rangeDragDay,\n    draggingDatePosition\n  }, !disableDragEditing ? dragRangeEvents : {}), [isDragging, rangeDragDay, draggingDatePosition, disableDragEditing, dragRangeEvents]);\n};","map":{"version":3,"names":["_extends","React","useEventCallback","isEndOfRange","isStartOfRange","resolveDateFromTarget","target","utils","timestampString","dataset","timestamp","date","Date","isSameAsDraggingDate","event","dataTransfer","getData","resolveButtonElement","element","HTMLButtonElement","disabled","children","length","resolveElementFromTouch","ignoreTouchTarget","_event$changedTouches","changedTouches","touches","document","elementFromPoint","clientX","clientY","buttonElement","useDragRangeEvents","_ref","setRangeDragDay","setIsDragging","isDragging","onDatePositionChange","onDrop","disableDragEditing","dateRange","emptyDragImgRef","useRef","useEffect","current","createElement","src","isElementDraggable","day","shouldInitDragging","isSelectedStartDate","isSelectedEndDate","handleDragStart","newDate","stopPropagation","setDragImage","effectAllowed","buttonDataset","setData","position","handleTouchStart","button","handleDragEnter","preventDefault","dropEffect","handleTouchMove","handleDragLeave","handleDragOver","handleTouchEnd","focus","handleDragEnd","handleDrop","currentTarget","onDragStart","onDragEnter","onDragLeave","onDragOver","onDragEnd","onTouchStart","onTouchMove","onTouchEnd","useDragRange","_ref2","useState","rangeDragDay","handleRangeDragDayChange","val","isEqual","draggingDatePosition","useMemo","start","end","isBefore","isAfter","dragRangeEvents"],"sources":["/Users/Shared/ATS Git/ATSDemo/ReactJs/ReactCaseStudy/my-app/node_modules/@mui/x-date-pickers-pro/DateRangeCalendar/useDragRange.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport { isEndOfRange, isStartOfRange } from '../internal/utils/date-utils';\nconst resolveDateFromTarget = (target, utils) => {\n  const timestampString = target.dataset.timestamp;\n  if (!timestampString) {\n    return null;\n  }\n  const timestamp = +timestampString;\n  return utils.date(new Date(timestamp));\n};\nconst isSameAsDraggingDate = event => {\n  const timestampString = event.target.dataset.timestamp;\n  return timestampString === event.dataTransfer.getData('draggingDate');\n};\nconst resolveButtonElement = element => {\n  if (element) {\n    if (element instanceof HTMLButtonElement && !element.disabled) {\n      return element;\n    }\n    if (element.children.length) {\n      return resolveButtonElement(element.children[0]);\n    }\n    return null;\n  }\n  return element;\n};\nconst resolveElementFromTouch = (event, ignoreTouchTarget) => {\n  var _event$changedTouches;\n  // don't parse multi-touch result\n  if (((_event$changedTouches = event.changedTouches) == null ? void 0 : _event$changedTouches.length) === 1 && event.touches.length <= 1) {\n    const element = document.elementFromPoint(event.changedTouches[0].clientX, event.changedTouches[0].clientY);\n    // `elementFromPoint` could have resolved preview div or wrapping div\n    // might need to recursively find the nested button\n    const buttonElement = resolveButtonElement(element);\n    if (ignoreTouchTarget && buttonElement === event.changedTouches[0].target) {\n      return null;\n    }\n    return buttonElement;\n  }\n  return null;\n};\nconst useDragRangeEvents = ({\n  utils,\n  setRangeDragDay,\n  setIsDragging,\n  isDragging,\n  onDatePositionChange,\n  onDrop,\n  disableDragEditing,\n  dateRange\n}) => {\n  const emptyDragImgRef = React.useRef(null);\n  React.useEffect(() => {\n    // Preload the image - required for Safari support: https://stackoverflow.com/a/40923520/3303436\n    emptyDragImgRef.current = document.createElement('img');\n    emptyDragImgRef.current.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\n  }, []);\n  const isElementDraggable = day => {\n    if (day == null) {\n      return false;\n    }\n    const shouldInitDragging = !disableDragEditing && !!dateRange[0] && !!dateRange[1];\n    const isSelectedStartDate = isStartOfRange(utils, day, dateRange);\n    const isSelectedEndDate = isEndOfRange(utils, day, dateRange);\n    return shouldInitDragging && (isSelectedStartDate || isSelectedEndDate);\n  };\n  const handleDragStart = useEventCallback(event => {\n    const newDate = resolveDateFromTarget(event.target, utils);\n    if (!isElementDraggable(newDate)) {\n      return;\n    }\n    event.stopPropagation();\n    if (emptyDragImgRef.current) {\n      event.dataTransfer.setDragImage(emptyDragImgRef.current, 0, 0);\n    }\n    setRangeDragDay(newDate);\n    event.dataTransfer.effectAllowed = 'move';\n    setIsDragging(true);\n    const buttonDataset = event.target.dataset;\n    if (buttonDataset.timestamp) {\n      event.dataTransfer.setData('draggingDate', buttonDataset.timestamp);\n    }\n    if (buttonDataset.position) {\n      onDatePositionChange(buttonDataset.position);\n    }\n  });\n  const handleTouchStart = useEventCallback(event => {\n    const target = resolveElementFromTouch(event);\n    if (!target) {\n      return;\n    }\n    const newDate = resolveDateFromTarget(target, utils);\n    if (!isElementDraggable(newDate)) {\n      return;\n    }\n    setRangeDragDay(newDate);\n    setIsDragging(true);\n    const button = event.target;\n    const buttonDataset = button.dataset;\n    if (buttonDataset.position) {\n      onDatePositionChange(buttonDataset.position);\n    }\n  });\n  const handleDragEnter = useEventCallback(event => {\n    if (!isDragging) {\n      return;\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    event.dataTransfer.dropEffect = 'move';\n    setRangeDragDay(resolveDateFromTarget(event.target, utils));\n  });\n  const handleTouchMove = useEventCallback(event => {\n    const target = resolveElementFromTouch(event);\n    if (!isDragging || !target) {\n      return;\n    }\n    const newDate = resolveDateFromTarget(target, utils);\n    if (newDate) {\n      setRangeDragDay(newDate);\n    }\n  });\n  const handleDragLeave = useEventCallback(event => {\n    if (!isDragging) {\n      return;\n    }\n    event.preventDefault();\n    event.stopPropagation();\n  });\n  const handleDragOver = useEventCallback(event => {\n    if (!isDragging) {\n      return;\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    event.dataTransfer.dropEffect = 'move';\n  });\n  const handleTouchEnd = useEventCallback(event => {\n    if (!isDragging) {\n      return;\n    }\n    setRangeDragDay(null);\n    setIsDragging(false);\n    const target = resolveElementFromTouch(event, true);\n    if (!target) {\n      return;\n    }\n\n    // make sure the focused element is the element where touch ended\n    target.focus();\n    const newDate = resolveDateFromTarget(target, utils);\n    if (newDate) {\n      onDrop(newDate);\n    }\n  });\n  const handleDragEnd = useEventCallback(event => {\n    if (!isDragging) {\n      return;\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    setIsDragging(false);\n    setRangeDragDay(null);\n  });\n  const handleDrop = useEventCallback(event => {\n    if (!isDragging) {\n      return;\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    setIsDragging(false);\n    setRangeDragDay(null);\n    // make sure the focused element is the element where drop ended\n    event.currentTarget.focus();\n    if (isSameAsDraggingDate(event)) {\n      return;\n    }\n    const newDate = resolveDateFromTarget(event.target, utils);\n    if (newDate) {\n      onDrop(newDate);\n    }\n  });\n  return {\n    onDragStart: handleDragStart,\n    onDragEnter: handleDragEnter,\n    onDragLeave: handleDragLeave,\n    onDragOver: handleDragOver,\n    onDragEnd: handleDragEnd,\n    onDrop: handleDrop,\n    onTouchStart: handleTouchStart,\n    onTouchMove: handleTouchMove,\n    onTouchEnd: handleTouchEnd\n  };\n};\nexport const useDragRange = ({\n  disableDragEditing,\n  utils,\n  onDatePositionChange,\n  onDrop,\n  dateRange\n}) => {\n  const [isDragging, setIsDragging] = React.useState(false);\n  const [rangeDragDay, setRangeDragDay] = React.useState(null);\n  const handleRangeDragDayChange = useEventCallback(val => {\n    if (!utils.isEqual(val, rangeDragDay)) {\n      setRangeDragDay(val);\n    }\n  });\n  const draggingDatePosition = React.useMemo(() => {\n    const [start, end] = dateRange;\n    if (rangeDragDay) {\n      if (start && utils.isBefore(rangeDragDay, start)) {\n        return 'start';\n      }\n      if (end && utils.isAfter(rangeDragDay, end)) {\n        return 'end';\n      }\n    }\n    return null;\n  }, [dateRange, rangeDragDay, utils]);\n  const dragRangeEvents = useDragRangeEvents({\n    utils,\n    onDatePositionChange,\n    onDrop,\n    setIsDragging,\n    isDragging,\n    setRangeDragDay: handleRangeDragDayChange,\n    disableDragEditing,\n    dateRange\n  });\n  return React.useMemo(() => _extends({\n    isDragging,\n    rangeDragDay,\n    draggingDatePosition\n  }, !disableDragEditing ? dragRangeEvents : {}), [isDragging, rangeDragDay, draggingDatePosition, disableDragEditing, dragRangeEvents]);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}