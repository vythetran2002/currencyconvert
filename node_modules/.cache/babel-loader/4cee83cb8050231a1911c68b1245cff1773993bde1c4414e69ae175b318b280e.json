{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview The heart of the WebDriver JavaScript API.\n */\n\n'use strict';\n\nconst by = require('./by');\nconst {\n  RelativeBy\n} = require('./by');\nconst command = require('./command');\nconst error = require('./error');\nconst input = require('./input');\nconst logging = require('./logging');\nconst promise = require('./promise');\nconst Symbols = require('./symbols');\nconst cdp = require('../devtools/CDPConnection');\nconst WebSocket = require('ws');\nconst http = require('../http/index');\nconst fs = require('fs');\nconst {\n  Capabilities\n} = require('./capabilities');\nconst path = require('path');\nconst {\n  NoSuchElementError\n} = require('./error');\nconst cdpTargets = ['page', 'browser'];\nconst {\n  Credential\n} = require('./virtual_authenticator');\nconst webElement = require('./webelement');\nconst {\n  isObject\n} = require('./util');\nconst BIDI = require('../bidi');\nconst {\n  PinnedScript\n} = require('./pinnedScript');\n\n// Capability names that are defined in the W3C spec.\nconst W3C_CAPABILITY_NAMES = new Set(['acceptInsecureCerts', 'browserName', 'browserVersion', 'pageLoadStrategy', 'platformName', 'proxy', 'setWindowRect', 'strictFileInteractability', 'timeouts', 'unhandledPromptBehavior', 'webSocketUrl']);\n\n/**\n * Defines a condition for use with WebDriver's {@linkplain WebDriver#wait wait\n * command}.\n *\n * @template OUT\n */\nclass Condition {\n  /**\n   * @param {string} message A descriptive error message. Should complete the\n   *     sentence \"Waiting [...]\"\n   * @param {function(!WebDriver): OUT} fn The condition function to\n   *     evaluate on each iteration of the wait loop.\n   */\n  constructor(message, fn) {\n    /** @private {string} */\n    this.description_ = 'Waiting ' + message;\n\n    /** @type {function(!WebDriver): OUT} */\n    this.fn = fn;\n  }\n\n  /** @return {string} A description of this condition. */\n  description() {\n    return this.description_;\n  }\n}\n\n/**\n * Defines a condition that will result in a {@link WebElement}.\n *\n * @extends {Condition<!(WebElement|IThenable<!WebElement>)>}\n */\nclass WebElementCondition extends Condition {\n  /**\n   * @param {string} message A descriptive error message. Should complete the\n   *     sentence \"Waiting [...]\"\n   * @param {function(!WebDriver): !(WebElement|IThenable<!WebElement>)}\n   *     fn The condition function to evaluate on each iteration of the wait\n   *     loop.\n   */\n  constructor(message, fn) {\n    super(message, fn);\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  WebDriver\n//\n//////////////////////////////////////////////////////////////////////////////\n\n/**\n * Translates a command to its wire-protocol representation before passing it\n * to the given `executor` for execution.\n * @param {!command.Executor} executor The executor to use.\n * @param {!command.Command} command The command to execute.\n * @return {!Promise} A promise that will resolve with the command response.\n */\nfunction executeCommand(executor, command) {\n  return toWireValue(command.getParameters()).then(function (parameters) {\n    command.setParameters(parameters);\n    return executor.execute(command);\n  });\n}\n\n/**\n * Converts an object to its JSON representation in the WebDriver wire protocol.\n * When converting values of type object, the following steps will be taken:\n * <ol>\n * <li>if the object is a WebElement, the return value will be the element's\n *     server ID\n * <li>if the object defines a {@link Symbols.serialize} method, this algorithm\n *     will be recursively applied to the object's serialized representation\n * <li>if the object provides a \"toJSON\" function, this algorithm will\n *     recursively be applied to the result of that function\n * <li>otherwise, the value of each key will be recursively converted according\n *     to the rules above.\n * </ol>\n *\n * @param {*} obj The object to convert.\n * @return {!Promise<?>} A promise that will resolve to the input value's JSON\n *     representation.\n */\nasync function toWireValue(obj) {\n  let value = await Promise.resolve(obj);\n  if (value === void 0 || value === null) {\n    return value;\n  }\n  if (typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string') {\n    return value;\n  }\n  if (Array.isArray(value)) {\n    return convertKeys(value);\n  }\n  if (typeof value === 'function') {\n    return '' + value;\n  }\n  if (typeof value[Symbols.serialize] === 'function') {\n    return toWireValue(value[Symbols.serialize]());\n  } else if (typeof value.toJSON === 'function') {\n    return toWireValue(value.toJSON());\n  }\n  return convertKeys(value);\n}\nasync function convertKeys(obj) {\n  const isArray = Array.isArray(obj);\n  const numKeys = isArray ? obj.length : Object.keys(obj).length;\n  const ret = isArray ? new Array(numKeys) : {};\n  if (!numKeys) {\n    return ret;\n  }\n  async function forEachKey(obj, fn) {\n    if (Array.isArray(obj)) {\n      for (let i = 0, n = obj.length; i < n; i++) {\n        await fn(obj[i], i);\n      }\n    } else {\n      for (let key in obj) {\n        await fn(obj[key], key);\n      }\n    }\n  }\n  await forEachKey(obj, async function (value, key) {\n    ret[key] = await toWireValue(value);\n  });\n  return ret;\n}\n\n/**\n * Converts a value from its JSON representation according to the WebDriver wire\n * protocol. Any JSON object that defines a WebElement ID will be decoded to a\n * {@link WebElement} object. All other values will be passed through as is.\n *\n * @param {!WebDriver} driver The driver to use as the parent of any unwrapped\n *     {@link WebElement} values.\n * @param {*} value The value to convert.\n * @return {*} The converted value.\n */\nfunction fromWireValue(driver, value) {\n  if (Array.isArray(value)) {\n    value = value.map(v => fromWireValue(driver, v));\n  } else if (WebElement.isId(value)) {\n    let id = WebElement.extractId(value);\n    value = new WebElement(driver, id);\n  } else if (ShadowRoot.isId(value)) {\n    let id = ShadowRoot.extractId(value);\n    value = new ShadowRoot(driver, id);\n  } else if (isObject(value)) {\n    let result = {};\n    for (let key in value) {\n      if (Object.prototype.hasOwnProperty.call(value, key)) {\n        result[key] = fromWireValue(driver, value[key]);\n      }\n    }\n    value = result;\n  }\n  return value;\n}\n\n/**\n * Resolves a wait message from either a function or a string.\n * @param {(string|Function)=} message An optional message to use if the wait times out.\n * @return {string} The resolved message\n */\nfunction resolveWaitMessage(message) {\n  return message ? `${typeof message === 'function' ? message() : message}\\n` : '';\n}\n\n/**\n * Structural interface for a WebDriver client.\n *\n * @record\n */\nclass IWebDriver {\n  /**\n   * Executes the provided {@link command.Command} using this driver's\n   * {@link command.Executor}.\n   *\n   * @param {!command.Command} command The command to schedule.\n   * @return {!Promise<T>} A promise that will be resolved with the command\n   *     result.\n   * @template T\n   */\n  execute(command) {} // eslint-disable-line\n\n  /**\n   * Sets the {@linkplain input.FileDetector file detector} that should be\n   * used with this instance.\n   * @param {input.FileDetector} detector The detector to use or `null`.\n   */\n  setFileDetector(detector) {} // eslint-disable-line\n\n  /**\n   * @return {!command.Executor} The command executor used by this instance.\n   */\n  getExecutor() {}\n\n  /**\n   * @return {!Promise<!Session>} A promise for this client's session.\n   */\n  getSession() {}\n\n  /**\n   * @return {!Promise<!Capabilities>} A promise that will resolve with\n   *     the instance's capabilities.\n   */\n  getCapabilities() {}\n\n  /**\n   * Terminates the browser session. After calling quit, this instance will be\n   * invalidated and may no longer be used to issue commands against the\n   * browser.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the\n   *     command has completed.\n   */\n  quit() {}\n\n  /**\n   * Creates a new action sequence using this driver. The sequence will not be\n   * submitted for execution until\n   * {@link ./input.Actions#perform Actions.perform()} is called.\n   *\n   * @param {{async: (boolean|undefined),\n   *          bridge: (boolean|undefined)}=} options Configuration options for\n   *     the action sequence (see {@link ./input.Actions Actions} documentation\n   *     for details).\n   * @return {!input.Actions} A new action sequence for this instance.\n   */\n  actions(options) {} // eslint-disable-line\n\n  /**\n   * Executes a snippet of JavaScript in the context of the currently selected\n   * frame or window. The script fragment will be executed as the body of an\n   * anonymous function. If the script is provided as a function object, that\n   * function will be converted to a string for injection into the target\n   * window.\n   *\n   * Any arguments provided in addition to the script will be included as script\n   * arguments and may be referenced using the `arguments` object. Arguments may\n   * be a boolean, number, string, or {@linkplain WebElement}. Arrays and\n   * objects may also be used as script arguments as long as each item adheres\n   * to the types previously mentioned.\n   *\n   * The script may refer to any variables accessible from the current window.\n   * Furthermore, the script will execute in the window's context, thus\n   * `document` may be used to refer to the current document. Any local\n   * variables will not be available once the script has finished executing,\n   * though global variables will persist.\n   *\n   * If the script has a return value (i.e. if the script contains a return\n   * statement), then the following steps will be taken for resolving this\n   * functions return value:\n   *\n   * - For a HTML element, the value will resolve to a {@linkplain WebElement}\n   * - Null and undefined return values will resolve to null</li>\n   * - Booleans, numbers, and strings will resolve as is</li>\n   * - Functions will resolve to their string representation</li>\n   * - For arrays and objects, each member item will be converted according to\n   *     the rules above\n   *\n   * @param {!(string|Function)} script The script to execute.\n   * @param {...*} args The arguments to pass to the script.\n   * @return {!IThenable<T>} A promise that will resolve to the\n   *    scripts return value.\n   * @template T\n   */\n  executeScript(script) {} // eslint-disable-line\n\n  /**\n   * Executes a snippet of asynchronous JavaScript in the context of the\n   * currently selected frame or window. The script fragment will be executed as\n   * the body of an anonymous function. If the script is provided as a function\n   * object, that function will be converted to a string for injection into the\n   * target window.\n   *\n   * Any arguments provided in addition to the script will be included as script\n   * arguments and may be referenced using the `arguments` object. Arguments may\n   * be a boolean, number, string, or {@linkplain WebElement}. Arrays and\n   * objects may also be used as script arguments as long as each item adheres\n   * to the types previously mentioned.\n   *\n   * Unlike executing synchronous JavaScript with {@link #executeScript},\n   * scripts executed with this function must explicitly signal they are\n   * finished by invoking the provided callback. This callback will always be\n   * injected into the executed function as the last argument, and thus may be\n   * referenced with  `arguments[arguments.length - 1]`. The following steps\n   * will be taken for resolving this functions return value against the first\n   * argument to the script's callback function:\n   *\n   * - For a HTML element, the value will resolve to a {@link WebElement}\n   * - Null and undefined return values will resolve to null\n   * - Booleans, numbers, and strings will resolve as is\n   * - Functions will resolve to their string representation\n   * - For arrays and objects, each member item will be converted according to\n   *     the rules above\n   *\n   * __Example #1:__ Performing a sleep that is synchronized with the currently\n   * selected window:\n   *\n   *     var start = new Date().getTime();\n   *     driver.executeAsyncScript(\n   *         'window.setTimeout(arguments[arguments.length - 1], 500);').\n   *         then(function() {\n   *           console.log(\n   *               'Elapsed time: ' + (new Date().getTime() - start) + ' ms');\n   *         });\n   *\n   * __Example #2:__ Synchronizing a test with an AJAX application:\n   *\n   *     var button = driver.findElement(By.id('compose-button'));\n   *     button.click();\n   *     driver.executeAsyncScript(\n   *         'var callback = arguments[arguments.length - 1];' +\n   *         'mailClient.getComposeWindowWidget().onload(callback);');\n   *     driver.switchTo().frame('composeWidget');\n   *     driver.findElement(By.id('to')).sendKeys('dog@example.com');\n   *\n   * __Example #3:__ Injecting a XMLHttpRequest and waiting for the result. In\n   * this example, the inject script is specified with a function literal. When\n   * using this format, the function is converted to a string for injection, so\n   * it should not reference any symbols not defined in the scope of the page\n   * under test.\n   *\n   *     driver.executeAsyncScript(function() {\n   *       var callback = arguments[arguments.length - 1];\n   *       var xhr = new XMLHttpRequest();\n   *       xhr.open(\"GET\", \"/resource/data.json\", true);\n   *       xhr.onreadystatechange = function() {\n   *         if (xhr.readyState == 4) {\n   *           callback(xhr.responseText);\n   *         }\n   *       };\n   *       xhr.send('');\n   *     }).then(function(str) {\n   *       console.log(JSON.parse(str)['food']);\n   *     });\n   *\n   * @param {!(string|Function)} script The script to execute.\n   * @param {...*} args The arguments to pass to the script.\n   * @return {!IThenable<T>} A promise that will resolve to the scripts return\n   *     value.\n   * @template T\n   */\n  executeAsyncScript(script) {} // eslint-disable-line\n\n  /**\n   * Waits for a condition to evaluate to a \"truthy\" value. The condition may be\n   * specified by a {@link Condition}, as a custom function, or as any\n   * promise-like thenable.\n   *\n   * For a {@link Condition} or function, the wait will repeatedly\n   * evaluate the condition until it returns a truthy value. If any errors occur\n   * while evaluating the condition, they will be allowed to propagate. In the\n   * event a condition returns a {@linkplain Promise}, the polling loop will\n   * wait for it to be resolved and use the resolved value for whether the\n   * condition has been satisfied. The resolution time for a promise is always\n   * factored into whether a wait has timed out.\n   *\n   * If the provided condition is a {@link WebElementCondition}, then\n   * the wait will return a {@link WebElementPromise} that will resolve to the\n   * element that satisfied the condition.\n   *\n   * _Example:_ waiting up to 10 seconds for an element to be present on the\n   * page.\n   *\n   *     async function example() {\n   *       let button =\n   *           await driver.wait(until.elementLocated(By.id('foo')), 10000);\n   *       await button.click();\n   *     }\n   *\n   * @param {!(IThenable<T>|\n   *           Condition<T>|\n   *           function(!WebDriver): T)} condition The condition to\n   *     wait on, defined as a promise, condition object, or  a function to\n   *     evaluate as a condition.\n   * @param {number=} timeout The duration in milliseconds, how long to wait\n   *     for the condition to be true.\n   * @param {(string|Function)=} message An optional message to use if the wait times out.\n   * @param {number=} pollTimeout The duration in milliseconds, how long to\n   *     wait between polling the condition.\n   * @return {!(IThenable<T>|WebElementPromise)} A promise that will be\n   *     resolved with the first truthy value returned by the condition\n   *     function, or rejected if the condition times out. If the input\n   *     condition is an instance of a {@link WebElementCondition},\n   *     the returned value will be a {@link WebElementPromise}.\n   * @throws {TypeError} if the provided `condition` is not a valid type.\n   * @template T\n   */\n  wait(condition) {\n    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    let pollTimeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n  }\n\n  /**\n   * Makes the driver sleep for the given amount of time.\n   *\n   * @param {number} ms The amount of time, in milliseconds, to sleep.\n   * @return {!Promise<void>} A promise that will be resolved when the sleep has\n   *     finished.\n   */\n  sleep(ms) {} // eslint-disable-line\n\n  /**\n   * Retrieves the current window handle.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the current\n   *     window handle.\n   */\n  getWindowHandle() {}\n\n  /**\n   * Retrieves a list of all available window handles.\n   *\n   * @return {!Promise<!Array<string>>} A promise that will be resolved with an\n   *     array of window handles.\n   */\n  getAllWindowHandles() {}\n\n  /**\n   * Retrieves the current page's source. The returned source is a representation\n   * of the underlying DOM: do not expect it to be formatted or escaped in the\n   * same way as the raw response sent from the web server.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the current\n   *     page source.\n   */\n  getPageSource() {}\n\n  /**\n   * Closes the current window.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when this command\n   *     has completed.\n   */\n  close() {}\n\n  /**\n   * Navigates to the given URL.\n   *\n   * @param {string} url The fully qualified URL to open.\n   * @return {!Promise<void>} A promise that will be resolved when the document\n   *     has finished loading.\n   */\n  get(url) {} // eslint-disable-line\n\n  /**\n   * Retrieves the URL for the current page.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the\n   *     current URL.\n   */\n  getCurrentUrl() {}\n\n  /**\n   * Retrieves the current page title.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the current\n   *     page's title.\n   */\n  getTitle() {}\n\n  /**\n   * Locates an element on the page. If the element cannot be found, a\n   * {@link error.NoSuchElementError} will be returned by the driver.\n   *\n   * This function should not be used to test whether an element is present on\n   * the page. Rather, you should use {@link #findElements}:\n   *\n   *     driver.findElements(By.id('foo'))\n   *         .then(found => console.log('Element found? %s', !!found.length));\n   *\n   * The search criteria for an element may be defined using one of the\n   * factories in the {@link webdriver.By} namespace, or as a short-hand\n   * {@link webdriver.By.Hash} object. For example, the following two statements\n   * are equivalent:\n   *\n   *     var e1 = driver.findElement(By.id('foo'));\n   *     var e2 = driver.findElement({id:'foo'});\n   *\n   * You may also provide a custom locator function, which takes as input this\n   * instance and returns a {@link WebElement}, or a promise that will resolve\n   * to a WebElement. If the returned promise resolves to an array of\n   * WebElements, WebDriver will use the first element. For example, to find the\n   * first visible link on a page, you could write:\n   *\n   *     var link = driver.findElement(firstVisibleLink);\n   *\n   *     function firstVisibleLink(driver) {\n   *       var links = driver.findElements(By.tagName('a'));\n   *       return promise.filter(links, function(link) {\n   *         return link.isDisplayed();\n   *       });\n   *     }\n   *\n   * @param {!(by.By|Function)} locator The locator to use.\n   * @return {!WebElementPromise} A WebElement that can be used to issue\n   *     commands against the located element. If the element is not found, the\n   *     element will be invalidated and all scheduled commands aborted.\n   */\n  findElement(locator) {} // eslint-disable-line\n\n  /**\n   * Search for multiple elements on the page. Refer to the documentation on\n   * {@link #findElement(by)} for information on element locator strategies.\n   *\n   * @param {!(by.By|Function)} locator The locator to use.\n   * @return {!Promise<!Array<!WebElement>>} A promise that will resolve to an\n   *     array of WebElements.\n   */\n  findElements(locator) {} // eslint-disable-line\n\n  /**\n   * Takes a screenshot of the current page. The driver makes the best effort to\n   * return a screenshot of the following, in order of preference:\n   *\n   * 1. Entire page\n   * 2. Current window\n   * 3. Visible portion of the current frame\n   * 4. The entire display containing the browser\n   *\n   * @return {!Promise<string>} A promise that will be resolved to the\n   *     screenshot as a base-64 encoded PNG.\n   */\n  takeScreenshot() {}\n\n  /**\n   * @return {!Options} The options interface for this instance.\n   */\n  manage() {}\n\n  /**\n   * @return {!Navigation} The navigation interface for this instance.\n   */\n  navigate() {}\n\n  /**\n   * @return {!TargetLocator} The target locator interface for this\n   *     instance.\n   */\n  switchTo() {}\n\n  /**\n   *\n   * Takes a PDF of the current page. The driver makes a best effort to\n   * return a PDF based on the provided parameters.\n   *\n   * @param {{orientation:(string|undefined),\n   *         scale:(number|undefined),\n   *         background:(boolean|undefined),\n   *         width:(number|undefined),\n   *         height:(number|undefined),\n   *         top:(number|undefined),\n   *         bottom:(number|undefined),\n   *         left:(number|undefined),\n   *         right:(number|undefined),\n   *         shrinkToFit:(boolean|undefined),\n   *         pageRanges:(Array|undefined)}} options\n   */\n  printPage(options) {} // eslint-disable-line\n}\n\n/**\n * @param {!Capabilities} capabilities A capabilities object.\n * @return {!Capabilities} A copy of the parameter capabilities, omitting\n *     capability names that are not valid W3C names.\n */\nfunction filterNonW3CCaps(capabilities) {\n  let newCaps = new Capabilities(capabilities);\n  for (let k of newCaps.keys()) {\n    // Any key containing a colon is a vendor-prefixed capability.\n    if (!(W3C_CAPABILITY_NAMES.has(k) || k.indexOf(':') >= 0)) {\n      newCaps.delete(k);\n    }\n  }\n  return newCaps;\n}\n\n/**\n * Each WebDriver instance provides automated control over a browser session.\n *\n * @implements {IWebDriver}\n */\nclass WebDriver {\n  /**\n   * @param {!(./session.Session|IThenable<!./session.Session>)} session Either\n   *     a known session or a promise that will be resolved to a session.\n   * @param {!command.Executor} executor The executor to use when sending\n   *     commands to the browser.\n   * @param {(function(this: void): ?)=} onQuit A function to call, if any,\n   *     when the session is terminated.\n   */\n  constructor(session, executor) {\n    let onQuit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    /** @private {!Promise<!Session>} */\n    this.session_ = Promise.resolve(session);\n\n    // If session is a rejected promise, add a no-op rejection handler.\n    // This effectively hides setup errors until users attempt to interact\n    // with the session.\n    this.session_.catch(function () {});\n\n    /** @private {!command.Executor} */\n    this.executor_ = executor;\n\n    /** @private {input.FileDetector} */\n    this.fileDetector_ = null;\n\n    /** @private @const {(function(this: void): ?|undefined)} */\n    this.onQuit_ = onQuit;\n\n    /** @private {./virtual_authenticator}*/\n    this.authenticatorId_ = null;\n    this.pinnedScripts_ = {};\n  }\n\n  /**\n   * Creates a new WebDriver session.\n   *\n   * This function will always return a WebDriver instance. If there is an error\n   * creating the session, such as the aforementioned SessionNotCreatedError,\n   * the driver will have a rejected {@linkplain #getSession session} promise.\n   * This rejection will propagate through any subsequent commands scheduled\n   * on the returned WebDriver instance.\n   *\n   *     let required = Capabilities.firefox();\n   *     let driver = WebDriver.createSession(executor, {required});\n   *\n   *     // If the createSession operation failed, then this command will also\n   *     // also fail, propagating the creation failure.\n   *     driver.get('http://www.google.com').catch(e => console.log(e));\n   *\n   * @param {!command.Executor} executor The executor to create the new session\n   *     with.\n   * @param {!Capabilities} capabilities The desired capabilities for the new\n   *     session.\n   * @param {(function(this: void): ?)=} onQuit A callback to invoke when\n   *    the newly created session is terminated. This should be used to clean\n   *    up any resources associated with the session.\n   * @return {!WebDriver} The driver for the newly created session.\n   */\n  static createSession(executor, capabilities) {\n    let onQuit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    let cmd = new command.Command(command.Name.NEW_SESSION);\n\n    // For W3C remote ends.\n    cmd.setParameter('capabilities', {\n      firstMatch: [{}],\n      alwaysMatch: filterNonW3CCaps(capabilities)\n    });\n    let session = executeCommand(executor, cmd);\n    if (typeof onQuit === 'function') {\n      session = session.catch(err => {\n        return Promise.resolve(onQuit.call(void 0)).then(_ => {\n          throw err;\n        });\n      });\n    }\n    return new this(session, executor, onQuit);\n  }\n\n  /** @override */\n  async execute(command) {\n    command.setParameter('sessionId', this.session_);\n    let parameters = await toWireValue(command.getParameters());\n    command.setParameters(parameters);\n    let value = await this.executor_.execute(command);\n    return fromWireValue(this, value);\n  }\n\n  /** @override */\n  setFileDetector(detector) {\n    this.fileDetector_ = detector;\n  }\n\n  /** @override */\n  getExecutor() {\n    return this.executor_;\n  }\n\n  /** @override */\n  getSession() {\n    return this.session_;\n  }\n\n  /** @override */\n  getCapabilities() {\n    return this.session_.then(s => s.getCapabilities());\n  }\n\n  /** @override */\n  quit() {\n    let result = this.execute(new command.Command(command.Name.QUIT));\n    // Delete our session ID when the quit command finishes; this will allow us\n    // to throw an error when attempting to use a driver post-quit.\n    return promise.finally(result, () => {\n      this.session_ = Promise.reject(new error.NoSuchSessionError('This driver instance does not have a valid session ID ' + '(did you call WebDriver.quit()?) and may no longer be used.'));\n\n      // Only want the session rejection to bubble if accessed.\n      this.session_.catch(function () {});\n      if (this.onQuit_) {\n        return this.onQuit_.call(void 0);\n      }\n    });\n  }\n\n  /** @override */\n  actions(options) {\n    return new input.Actions(this, options || undefined);\n  }\n\n  /** @override */\n  executeScript(script) {\n    if (typeof script === 'function') {\n      script = 'return (' + script + ').apply(null, arguments);';\n    }\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    if (script && script instanceof PinnedScript) {\n      return this.execute(new command.Command(command.Name.EXECUTE_SCRIPT).setParameter('script', script.executionScript()).setParameter('args', args));\n    }\n    return this.execute(new command.Command(command.Name.EXECUTE_SCRIPT).setParameter('script', script).setParameter('args', args));\n  }\n\n  /** @override */\n  executeAsyncScript(script) {\n    if (typeof script === 'function') {\n      script = 'return (' + script + ').apply(null, arguments);';\n    }\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    if (script && script instanceof PinnedScript) {\n      return this.execute(new command.Command(command.Name.EXECUTE_ASYNC_SCRIPT).setParameter('script', script.executionScript()).setParameter('args', args));\n    }\n    return this.execute(new command.Command(command.Name.EXECUTE_ASYNC_SCRIPT).setParameter('script', script).setParameter('args', args));\n  }\n\n  /** @override */\n  wait(condition) {\n    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    let pollTimeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 200;\n    if (typeof timeout !== 'number' || timeout < 0) {\n      throw TypeError('timeout must be a number >= 0: ' + timeout);\n    }\n    if (typeof pollTimeout !== 'number' || pollTimeout < 0) {\n      throw TypeError('pollTimeout must be a number >= 0: ' + pollTimeout);\n    }\n    if (promise.isPromise(condition)) {\n      return new Promise((resolve, reject) => {\n        if (!timeout) {\n          resolve(condition);\n          return;\n        }\n        let start = Date.now();\n        let timer = setTimeout(function () {\n          timer = null;\n          try {\n            let timeoutMessage = resolveWaitMessage(message);\n            reject(new error.TimeoutError(`${timeoutMessage}Timed out waiting for promise to resolve after ${Date.now() - start}ms`));\n          } catch (ex) {\n            reject(new error.TimeoutError(`${ex.message}\\nTimed out waiting for promise to resolve after ${Date.now() - start}ms`));\n          }\n        }, timeout);\n        const clearTimer = () => timer && clearTimeout(timer);\n\n        /** @type {!IThenable} */\n        condition.then(function (value) {\n          clearTimer();\n          resolve(value);\n        }, function (error) {\n          clearTimer();\n          reject(error);\n        });\n      });\n    }\n    let fn = /** @type {!Function} */condition;\n    if (condition instanceof Condition) {\n      message = message || condition.description();\n      fn = condition.fn;\n    }\n    if (typeof fn !== 'function') {\n      throw TypeError('Wait condition must be a promise-like object, function, or a ' + 'Condition object');\n    }\n    const driver = this;\n    function evaluateCondition() {\n      return new Promise((resolve, reject) => {\n        try {\n          resolve(fn(driver));\n        } catch (ex) {\n          reject(ex);\n        }\n      });\n    }\n    let result = new Promise((resolve, reject) => {\n      const startTime = Date.now();\n      const pollCondition = async () => {\n        evaluateCondition().then(function (value) {\n          const elapsed = Date.now() - startTime;\n          if (value) {\n            resolve(value);\n          } else if (timeout && elapsed >= timeout) {\n            try {\n              let timeoutMessage = resolveWaitMessage(message);\n              reject(new error.TimeoutError(`${timeoutMessage}Wait timed out after ${elapsed}ms`));\n            } catch (ex) {\n              reject(new error.TimeoutError(`${ex.message}\\nWait timed out after ${elapsed}ms`));\n            }\n          } else {\n            setTimeout(pollCondition, pollTimeout);\n          }\n        }, reject);\n      };\n      pollCondition();\n    });\n    if (condition instanceof WebElementCondition) {\n      result = new WebElementPromise(this, result.then(function (value) {\n        if (!(value instanceof WebElement)) {\n          throw TypeError('WebElementCondition did not resolve to a WebElement: ' + Object.prototype.toString.call(value));\n        }\n        return value;\n      }));\n    }\n    return result;\n  }\n\n  /** @override */\n  sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /** @override */\n  getWindowHandle() {\n    return this.execute(new command.Command(command.Name.GET_CURRENT_WINDOW_HANDLE));\n  }\n\n  /** @override */\n  getAllWindowHandles() {\n    return this.execute(new command.Command(command.Name.GET_WINDOW_HANDLES));\n  }\n\n  /** @override */\n  getPageSource() {\n    return this.execute(new command.Command(command.Name.GET_PAGE_SOURCE));\n  }\n\n  /** @override */\n  close() {\n    return this.execute(new command.Command(command.Name.CLOSE));\n  }\n\n  /** @override */\n  get(url) {\n    return this.navigate().to(url);\n  }\n\n  /** @override */\n  getCurrentUrl() {\n    return this.execute(new command.Command(command.Name.GET_CURRENT_URL));\n  }\n\n  /** @override */\n  getTitle() {\n    return this.execute(new command.Command(command.Name.GET_TITLE));\n  }\n\n  /** @override */\n  findElement(locator) {\n    let id;\n    let cmd = null;\n    if (locator instanceof RelativeBy) {\n      cmd = new command.Command(command.Name.FIND_ELEMENTS_RELATIVE).setParameter('args', locator.marshall());\n    } else {\n      locator = by.checkedLocator(locator);\n    }\n    if (typeof locator === 'function') {\n      id = this.findElementInternal_(locator, this);\n      return new WebElementPromise(this, id);\n    } else if (cmd === null) {\n      cmd = new command.Command(command.Name.FIND_ELEMENT).setParameter('using', locator.using).setParameter('value', locator.value);\n    }\n    id = this.execute(cmd);\n    if (locator instanceof RelativeBy) {\n      return this.normalize_(id);\n    } else {\n      return new WebElementPromise(this, id);\n    }\n  }\n\n  /**\n   * @param {!Function} webElementPromise The webElement in unresolved state\n   * @return {!Promise<!WebElement>} First single WebElement from array of resolved promises\n   */\n  async normalize_(webElementPromise) {\n    let result = await webElementPromise;\n    if (result.length === 0) {\n      throw new NoSuchElementError('Cannot locate an element with provided parameters');\n    } else {\n      return result[0];\n    }\n  }\n\n  /**\n   * @param {!Function} locatorFn The locator function to use.\n   * @param {!(WebDriver|WebElement)} context The search context.\n   * @return {!Promise<!WebElement>} A promise that will resolve to a list of\n   *     WebElements.\n   * @private\n   */\n  async findElementInternal_(locatorFn, context) {\n    let result = await locatorFn(context);\n    if (Array.isArray(result)) {\n      result = result[0];\n    }\n    if (!(result instanceof WebElement)) {\n      throw new TypeError('Custom locator did not return a WebElement');\n    }\n    return result;\n  }\n\n  /** @override */\n  async findElements(locator) {\n    let cmd = null;\n    if (locator instanceof RelativeBy) {\n      cmd = new command.Command(command.Name.FIND_ELEMENTS_RELATIVE).setParameter('args', locator.marshall());\n    } else {\n      locator = by.checkedLocator(locator);\n    }\n    if (typeof locator === 'function') {\n      return this.findElementsInternal_(locator, this);\n    } else if (cmd === null) {\n      cmd = new command.Command(command.Name.FIND_ELEMENTS).setParameter('using', locator.using).setParameter('value', locator.value);\n    }\n    try {\n      let res = await this.execute(cmd);\n      return Array.isArray(res) ? res : [];\n    } catch (ex) {\n      if (ex instanceof error.NoSuchElementError) {\n        return [];\n      }\n      throw ex;\n    }\n  }\n\n  /**\n   * @param {!Function} locatorFn The locator function to use.\n   * @param {!(WebDriver|WebElement)} context The search context.\n   * @return {!Promise<!Array<!WebElement>>} A promise that will resolve to an\n   *     array of WebElements.\n   * @private\n   */\n  async findElementsInternal_(locatorFn, context) {\n    const result = await locatorFn(context);\n    if (result instanceof WebElement) {\n      return [result];\n    }\n    if (!Array.isArray(result)) {\n      return [];\n    }\n    return result.filter(function (item) {\n      return item instanceof WebElement;\n    });\n  }\n\n  /** @override */\n  takeScreenshot() {\n    return this.execute(new command.Command(command.Name.SCREENSHOT));\n  }\n\n  /** @override */\n  manage() {\n    return new Options(this);\n  }\n\n  /** @override */\n  navigate() {\n    return new Navigation(this);\n  }\n\n  /** @override */\n  switchTo() {\n    return new TargetLocator(this);\n  }\n  validatePrintPageParams(keys, object) {\n    let page = {};\n    let margin = {};\n    let data;\n    Object.keys(keys).forEach(function (key) {\n      data = keys[key];\n      let obj = {\n        orientation: function () {\n          object.orientation = data;\n        },\n        scale: function () {\n          object.scale = data;\n        },\n        background: function () {\n          object.background = data;\n        },\n        width: function () {\n          page.width = data;\n          object.page = page;\n        },\n        height: function () {\n          page.height = data;\n          object.page = page;\n        },\n        top: function () {\n          margin.top = data;\n          object.margin = margin;\n        },\n        left: function () {\n          margin.left = data;\n          object.margin = margin;\n        },\n        bottom: function () {\n          margin.bottom = data;\n          object.margin = margin;\n        },\n        right: function () {\n          margin.right = data;\n          object.margin = margin;\n        },\n        shrinkToFit: function () {\n          object.shrinkToFit = data;\n        },\n        pageRanges: function () {\n          object.pageRanges = data;\n        }\n      };\n      if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n        throw new error.InvalidArgumentError(`Invalid Argument '${key}'`);\n      } else {\n        obj[key]();\n      }\n    });\n    return object;\n  }\n\n  /** @override */\n  printPage() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let keys = options;\n    let params = {};\n    let resultObj;\n    let self = this;\n    resultObj = self.validatePrintPageParams(keys, params);\n    return this.execute(new command.Command(command.Name.PRINT_PAGE).setParameters(resultObj));\n  }\n\n  /**\n   * Creates a new WebSocket connection.\n   * @return {!Promise<resolved>} A new CDP instance.\n   */\n  async createCDPConnection(target) {\n    let debuggerUrl = null;\n    const caps = await this.getCapabilities();\n    if (process.env.SELENIUM_REMOTE_URL) {\n      const host = new URL(process.env.SELENIUM_REMOTE_URL).host;\n      const sessionId = await this.getSession().then(session => session.getId());\n      debuggerUrl = `ws://${host}/session/${sessionId}/se/cdp`;\n    } else {\n      const seCdp = caps['map_'].get('se:cdp');\n      const vendorInfo = caps['map_'].get(this.VENDOR_COMMAND_PREFIX + ':chromeOptions') || caps['map_'].get(this.VENDOR_CAPABILITY_PREFIX + ':edgeOptions') || caps['map_'].get('moz:debuggerAddress') || new Map();\n      debuggerUrl = seCdp || vendorInfo['debuggerAddress'] || vendorInfo;\n    }\n    this._wsUrl = await this.getWsUrl(debuggerUrl, target, caps);\n    return new Promise((resolve, reject) => {\n      try {\n        this._wsConnection = new WebSocket(this._wsUrl.replace('localhost', '127.0.0.1'));\n        this._cdpConnection = new cdp.CdpConnection(this._wsConnection);\n      } catch (err) {\n        reject(err);\n        return;\n      }\n      this._wsConnection.on('open', async () => {\n        await this.getCdpTargets();\n      });\n      this._wsConnection.on('message', async message => {\n        const params = JSON.parse(message);\n        if (params.result) {\n          if (params.result.targetInfos) {\n            const targets = params.result.targetInfos;\n            const page = targets.find(info => info.type === 'page');\n            if (page) {\n              this.targetID = page.targetId;\n              this._cdpConnection.execute('Target.attachToTarget', {\n                targetId: this.targetID,\n                flatten: true\n              }, null);\n            } else {\n              reject('Unable to find Page target.');\n            }\n          }\n          if (params.result.sessionId) {\n            this.sessionId = params.result.sessionId;\n            this._cdpConnection.sessionId = this.sessionId;\n            resolve(this._cdpConnection);\n          }\n        }\n      });\n      this._wsConnection.on('error', error => {\n        reject(error);\n      });\n    });\n  }\n  async getCdpTargets() {\n    this._cdpConnection.execute('Target.getTargets');\n  }\n\n  /**\n   * Initiates bidi connection using 'webSocketUrl'\n   * @returns {BIDI}\n   */\n  async getBidi() {\n    const caps = await this.getCapabilities();\n    let WebSocketUrl = caps['map_'].get('webSocketUrl');\n    return new BIDI(WebSocketUrl.replace('localhost', '127.0.0.1'));\n  }\n\n  /**\n   * Retrieves 'webSocketDebuggerUrl' by sending a http request using debugger address\n   * @param {string} debuggerAddress\n   * @param target\n   * @param caps\n   * @return {string} Returns parsed webSocketDebuggerUrl obtained from the http request\n   */\n  async getWsUrl(debuggerAddress, target, caps) {\n    if (target && cdpTargets.indexOf(target.toLowerCase()) === -1) {\n      throw new error.InvalidArgumentError('invalid target value');\n    }\n    if (debuggerAddress.match(/\\/se\\/cdp/)) {\n      return debuggerAddress;\n    }\n    let path;\n    if (target === 'page' && caps['map_'].get('browserName') !== 'firefox') {\n      path = '/json';\n    } else if (target === 'page' && caps['map_'].get('browserName') === 'firefox') {\n      path = '/json/list';\n    } else {\n      path = '/json/version';\n    }\n    let request = new http.Request('GET', path);\n    let client = new http.HttpClient('http://' + debuggerAddress);\n    let response = await client.send(request);\n    if (target.toLowerCase() === 'page') {\n      return JSON.parse(response.body)[0]['webSocketDebuggerUrl'];\n    } else {\n      return JSON.parse(response.body)['webSocketDebuggerUrl'];\n    }\n  }\n\n  /**\n   * Sets a listener for Fetch.authRequired event from CDP\n   * If event is triggered, it enters username and password\n   * and allows the test to move forward\n   * @param {string} username\n   * @param {string} password\n   * @param connection CDP Connection\n   */\n  async register(username, password, connection) {\n    this._wsConnection.on('message', message => {\n      const params = JSON.parse(message);\n      if (params.method === 'Fetch.authRequired') {\n        const requestParams = params['params'];\n        connection.execute('Fetch.continueWithAuth', {\n          requestId: requestParams['requestId'],\n          authChallengeResponse: {\n            response: 'ProvideCredentials',\n            username: username,\n            password: password\n          }\n        });\n      } else if (params.method === 'Fetch.requestPaused') {\n        const requestPausedParams = params['params'];\n        connection.execute('Fetch.continueRequest', {\n          requestId: requestPausedParams['requestId']\n        });\n      }\n    });\n    await connection.execute('Fetch.enable', {\n      handleAuthRequests: true\n    }, null);\n    await connection.execute('Network.setCacheDisabled', {\n      cacheDisabled: true\n    }, null);\n  }\n\n  /**\n   * Handle Network interception requests\n   * @param connection WebSocket connection to the browser\n   * @param httpResponse Object representing what we are intercepting\n   *                     as well as what should be returned.\n   * @param callback callback called when we intercept requests.\n   */\n  async onIntercept(connection, httpResponse, callback) {\n    this._wsConnection.on('message', message => {\n      const params = JSON.parse(message);\n      if (params.method === 'Fetch.requestPaused') {\n        const requestPausedParams = params['params'];\n        if (requestPausedParams.request.url == httpResponse.urlToIntercept) {\n          connection.execute('Fetch.fulfillRequest', {\n            requestId: requestPausedParams['requestId'],\n            responseCode: httpResponse.status,\n            responseHeaders: httpResponse.headers,\n            body: httpResponse.body\n          });\n          callback();\n        } else {\n          connection.execute('Fetch.continueRequest', {\n            requestId: requestPausedParams['requestId']\n          });\n        }\n      }\n    });\n    await connection.execute('Fetch.enable', {}, null);\n    await connection.execute('Network.setCacheDisabled', {\n      cacheDisabled: true\n    }, null);\n  }\n  /**\n   *\n   * @param connection\n   * @param callback\n   * @returns {Promise<void>}\n   */\n  async onLogEvent(connection, callback) {\n    this._wsConnection.on('message', message => {\n      const params = JSON.parse(message);\n      if (params.method === 'Runtime.consoleAPICalled') {\n        const consoleEventParams = params['params'];\n        let event = {\n          type: consoleEventParams['type'],\n          timestamp: new Date(consoleEventParams['timestamp']),\n          args: consoleEventParams['args']\n        };\n        callback(event);\n      }\n      if (params.method === 'Log.entryAdded') {\n        const logEventParams = params['params'];\n        const logEntry = logEventParams['entry'];\n        let event = {\n          level: logEntry['level'],\n          timestamp: new Date(logEntry['timestamp']),\n          message: logEntry['text']\n        };\n        callback(event);\n      }\n    });\n    await connection.execute('Runtime.enable', {}, null);\n  }\n\n  /**\n   *\n   * @param connection\n   * @param callback\n   * @returns {Promise<void>}\n   */\n  async onLogException(connection, callback) {\n    await connection.execute('Runtime.enable', {}, null);\n    this._wsConnection.on('message', message => {\n      const params = JSON.parse(message);\n      if (params.method === 'Runtime.exceptionThrown') {\n        const exceptionEventParams = params['params'];\n        let event = {\n          exceptionDetails: exceptionEventParams['exceptionDetails'],\n          timestamp: new Date(exceptionEventParams['timestamp'])\n        };\n        callback(event);\n      }\n    });\n  }\n\n  /**\n   * @param connection\n   * @param callback\n   * @returns {Promise<void>}\n   */\n  async logMutationEvents(connection, callback) {\n    await connection.execute('Runtime.enable', {}, null);\n    await connection.execute('Page.enable', {}, null);\n    await connection.execute('Runtime.addBinding', {\n      name: '__webdriver_attribute'\n    }, null);\n    let mutationListener = '';\n    try {\n      // Depending on what is running the code it could appear in 2 different places which is why we try\n      // here and then the other location\n      mutationListener = fs.readFileSync('./javascript/node/selenium-webdriver/lib/atoms/mutation-listener.js', 'utf-8').toString();\n    } catch {\n      mutationListener = fs.readFileSync(path.resolve(__dirname, './atoms/mutation-listener.js'), 'utf-8').toString();\n    }\n    this.executeScript(mutationListener);\n    await connection.execute('Page.addScriptToEvaluateOnNewDocument', {\n      source: mutationListener\n    }, null);\n    this._wsConnection.on('message', async message => {\n      const params = JSON.parse(message);\n      if (params.method === 'Runtime.bindingCalled') {\n        let payload = JSON.parse(params['params']['payload']);\n        let elements = await this.findElements({\n          css: '*[data-__webdriver_id=' + by.escapeCss(payload['target']) + ']'\n        });\n        if (elements.length === 0) {\n          return;\n        }\n        let event = {\n          element: elements[0],\n          attribute_name: payload['name'],\n          current_value: payload['value'],\n          old_value: payload['oldValue']\n        };\n        callback(event);\n      }\n    });\n  }\n  async pinScript(script) {\n    let pinnedScript = new PinnedScript(script);\n    let connection;\n    if (Object.is(this._cdpConnection, undefined)) {\n      connection = await this.createCDPConnection('page');\n    } else {\n      connection = this._cdpConnection;\n    }\n    await connection.execute('Page.enable', {}, null);\n    await connection.execute('Runtime.evaluate', {\n      expression: pinnedScript.creationScript()\n    }, null);\n    let result = await connection.send('Page.addScriptToEvaluateOnNewDocument', {\n      source: pinnedScript.creationScript()\n    });\n    pinnedScript.scriptId = result['result']['identifier'];\n    this.pinnedScripts_[pinnedScript.handle] = pinnedScript;\n    return pinnedScript;\n  }\n  async unpinScript(script) {\n    if (script && !(script instanceof PinnedScript)) {\n      throw Error(`Pass valid PinnedScript object. Received: ${script}`);\n    }\n    if (script.handle in this.pinnedScripts_) {\n      let connection;\n      if (Object.is(this._cdpConnection, undefined)) {\n        connection = this.createCDPConnection('page');\n      } else {\n        connection = this._cdpConnection;\n      }\n      await connection.execute('Page.enable', {}, null);\n      await connection.execute('Runtime.evaluate', {\n        expression: script.removalScript()\n      }, null);\n      await connection.execute('Page.removeScriptToEvaluateOnLoad', {\n        identifier: script.scriptId\n      }, null);\n      delete this.pinnedScripts_[script.handle];\n    }\n  }\n\n  /**\n   *\n   * @returns The value of authenticator ID added\n   */\n  virtualAuthenticatorId() {\n    return this.authenticatorId_;\n  }\n\n  /**\n   * Adds a virtual authenticator with the given options.\n   * @param options VirtualAuthenticatorOptions object to set authenticator options.\n   */\n  async addVirtualAuthenticator(options) {\n    this.authenticatorId_ = await this.execute(new command.Command(command.Name.ADD_VIRTUAL_AUTHENTICATOR).setParameters(options.toDict()));\n  }\n\n  /**\n   * Removes a previously added virtual authenticator. The authenticator is no\n   * longer valid after removal, so no methods may be called.\n   */\n  async removeVirtualAuthenticator() {\n    await this.execute(new command.Command(command.Name.REMOVE_VIRTUAL_AUTHENTICATOR).setParameter('authenticatorId', this.authenticatorId_));\n    this.authenticatorId_ = null;\n  }\n\n  /**\n   * Injects a credential into the authenticator.\n   * @param credential Credential to be added\n   */\n  async addCredential(credential) {\n    credential = credential.toDict();\n    credential['authenticatorId'] = this.authenticatorId_;\n    await this.execute(new command.Command(command.Name.ADD_CREDENTIAL).setParameters(credential));\n  }\n\n  /**\n   *\n   * @returns The list of credentials owned by the authenticator.\n   */\n  async getCredentials() {\n    let credential_data = await this.execute(new command.Command(command.Name.GET_CREDENTIALS).setParameter('authenticatorId', this.virtualAuthenticatorId()));\n    var credential_list = [];\n    for (var i = 0; i < credential_data.length; i++) {\n      credential_list.push(new Credential().fromDict(credential_data[i]));\n    }\n    return credential_list;\n  }\n\n  /**\n   * Removes a credential from the authenticator.\n   * @param credential_id The ID of the credential to be removed.\n   */\n  async removeCredential(credential_id) {\n    // If credential_id is not a base64url, then convert it to base64url.\n    if (Array.isArray(credential_id)) {\n      credential_id = Buffer.from(credential_id).toString('base64url');\n    }\n    await this.execute(new command.Command(command.Name.REMOVE_CREDENTIAL).setParameter('credentialId', credential_id).setParameter('authenticatorId', this.authenticatorId_));\n  }\n\n  /**\n   * Removes all the credentials from the authenticator.\n   */\n  async removeAllCredentials() {\n    await this.execute(new command.Command(command.Name.REMOVE_ALL_CREDENTIALS).setParameter('authenticatorId', this.authenticatorId_));\n  }\n\n  /**\n   * Sets whether the authenticator will simulate success or fail on user verification.\n   * @param verified true if the authenticator will pass user verification, false otherwise.\n   */\n  async setUserVerified(verified) {\n    await this.execute(new command.Command(command.Name.SET_USER_VERIFIED).setParameter('authenticatorId', this.authenticatorId_).setParameter('isUserVerified', verified));\n  }\n}\n\n/**\n * Interface for navigating back and forth in the browser history.\n *\n * This class should never be instantiated directly. Instead, obtain an instance\n * with\n *\n *    webdriver.navigate()\n *\n * @see WebDriver#navigate()\n */\nclass Navigation {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n\n  /**\n   * Navigates to a new URL.\n   *\n   * @param {string} url The URL to navigate to.\n   * @return {!Promise<void>} A promise that will be resolved when the URL\n   *     has been loaded.\n   */\n  to(url) {\n    return this.driver_.execute(new command.Command(command.Name.GET).setParameter('url', url));\n  }\n\n  /**\n   * Moves backwards in the browser history.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the\n   *     navigation event has completed.\n   */\n  back() {\n    return this.driver_.execute(new command.Command(command.Name.GO_BACK));\n  }\n\n  /**\n   * Moves forwards in the browser history.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the\n   *     navigation event has completed.\n   */\n  forward() {\n    return this.driver_.execute(new command.Command(command.Name.GO_FORWARD));\n  }\n\n  /**\n   * Refreshes the current page.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the\n   *     navigation event has completed.\n   */\n  refresh() {\n    return this.driver_.execute(new command.Command(command.Name.REFRESH));\n  }\n}\n\n/**\n * Provides methods for managing browser and driver state.\n *\n * This class should never be instantiated directly. Instead, obtain an instance\n * with {@linkplain WebDriver#manage() webdriver.manage()}.\n */\nclass Options {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n\n  /**\n   * Adds a cookie.\n   *\n   * __Sample Usage:__\n   *\n   *     // Set a basic cookie.\n   *     driver.manage().addCookie({name: 'foo', value: 'bar'});\n   *\n   *     // Set a cookie that expires in 10 minutes.\n   *     let expiry = new Date(Date.now() + (10 * 60 * 1000));\n   *     driver.manage().addCookie({name: 'foo', value: 'bar', expiry});\n   *\n   *     // The cookie expiration may also be specified in seconds since epoch.\n   *     driver.manage().addCookie({\n   *       name: 'foo',\n   *       value: 'bar',\n   *       expiry: Math.floor(Date.now() / 1000)\n   *     });\n   *\n   * @param {!Options.Cookie} spec Defines the cookie to add.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the cookie has been added to the page.\n   * @throws {error.InvalidArgumentError} if any of the cookie parameters are\n   *     invalid.\n   * @throws {TypeError} if `spec` is not a cookie object.\n   */\n  addCookie(_ref) {\n    let {\n      name,\n      value,\n      path,\n      domain,\n      secure,\n      httpOnly,\n      expiry,\n      sameSite\n    } = _ref;\n    // We do not allow '=' or ';' in the name.\n    if (/[;=]/.test(name)) {\n      throw new error.InvalidArgumentError('Invalid cookie name \"' + name + '\"');\n    }\n\n    // We do not allow ';' in value.\n    if (/;/.test(value)) {\n      throw new error.InvalidArgumentError('Invalid cookie value \"' + value + '\"');\n    }\n    if (typeof expiry === 'number') {\n      expiry = Math.floor(expiry);\n    } else if (expiry instanceof Date) {\n      let date = /** @type {!Date} */expiry;\n      expiry = Math.floor(date.getTime() / 1000);\n    }\n    if (sameSite && !['Strict', 'Lax', 'None'].includes(sameSite)) {\n      throw new error.InvalidArgumentError(`Invalid sameSite cookie value '${sameSite}'. It should be one of \"Lax\", \"Strict\" or \"None\"`);\n    }\n    if (sameSite === 'None' && !secure) {\n      throw new error.InvalidArgumentError('Invalid cookie configuration: SameSite=None must be Secure');\n    }\n    return this.driver_.execute(new command.Command(command.Name.ADD_COOKIE).setParameter('cookie', {\n      name: name,\n      value: value,\n      path: path,\n      domain: domain,\n      secure: !!secure,\n      httpOnly: !!httpOnly,\n      expiry: expiry,\n      sameSite: sameSite\n    }));\n  }\n\n  /**\n   * Deletes all cookies visible to the current page.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when all cookies have been deleted.\n   */\n  deleteAllCookies() {\n    return this.driver_.execute(new command.Command(command.Name.DELETE_ALL_COOKIES));\n  }\n\n  /**\n   * Deletes the cookie with the given name. This command is a no-op if there is\n   * no cookie with the given name visible to the current page.\n   *\n   * @param {string} name The name of the cookie to delete.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the cookie has been deleted.\n   */\n  deleteCookie(name) {\n    return this.driver_.execute(new command.Command(command.Name.DELETE_COOKIE).setParameter('name', name));\n  }\n\n  /**\n   * Retrieves all cookies visible to the current page. Each cookie will be\n   * returned as a JSON object as described by the WebDriver wire protocol.\n   *\n   * @return {!Promise<!Array<!Options.Cookie>>} A promise that will be\n   *     resolved with the cookies visible to the current browsing context.\n   */\n  getCookies() {\n    return this.driver_.execute(new command.Command(command.Name.GET_ALL_COOKIES));\n  }\n\n  /**\n   * Retrieves the cookie with the given name. Returns null if there is no such\n   * cookie. The cookie will be returned as a JSON object as described by the\n   * WebDriver wire protocol.\n   *\n   * @param {string} name The name of the cookie to retrieve.\n   * @return {!Promise<?Options.Cookie>} A promise that will be resolved\n   *     with the named cookie\n   * @throws {error.NoSuchCookieError} if there is no such cookie.\n   */\n  async getCookie(name) {\n    try {\n      const cookie = await this.driver_.execute(new command.Command(command.Name.GET_COOKIE).setParameter('name', name));\n      return cookie;\n    } catch (err) {\n      if (!(err instanceof error.UnknownCommandError) && !(err instanceof error.UnsupportedOperationError)) {\n        throw err;\n      }\n      const cookies = await this.getCookies();\n      for (let cookie of cookies) {\n        if (cookie && cookie['name'] === name) {\n          return cookie;\n        }\n      }\n      return null;\n    }\n  }\n\n  /**\n   * Fetches the timeouts currently configured for the current session.\n   *\n   * @return {!Promise<{script: number,\n   *                             pageLoad: number,\n   *                             implicit: number}>} A promise that will be\n   *     resolved with the timeouts currently configured for the current\n   *     session.\n   * @see #setTimeouts()\n   */\n  getTimeouts() {\n    return this.driver_.execute(new command.Command(command.Name.GET_TIMEOUT));\n  }\n\n  /**\n   * Sets the timeout durations associated with the current session.\n   *\n   * The following timeouts are supported (all timeouts are specified in\n   * milliseconds):\n   *\n   * -  `implicit` specifies the maximum amount of time to wait for an element\n   *    locator to succeed when {@linkplain WebDriver#findElement locating}\n   *    {@linkplain WebDriver#findElements elements} on the page.\n   *    Defaults to 0 milliseconds.\n   *\n   * -  `pageLoad` specifies the maximum amount of time to wait for a page to\n   *    finishing loading. Defaults to 300000 milliseconds.\n   *\n   * -  `script` specifies the maximum amount of time to wait for an\n   *    {@linkplain WebDriver#executeScript evaluated script} to run. If set to\n   *    `null`, the script timeout will be indefinite.\n   *    Defaults to 30000 milliseconds.\n   *\n   * @param {{script: (number|null|undefined),\n   *          pageLoad: (number|null|undefined),\n   *          implicit: (number|null|undefined)}} conf\n   *     The desired timeout configuration.\n   * @return {!Promise<void>} A promise that will be resolved when the timeouts\n   *     have been set.\n   * @throws {!TypeError} if an invalid options object is provided.\n   * @see #getTimeouts()\n   * @see <https://w3c.github.io/webdriver/webdriver-spec.html#dfn-set-timeouts>\n   */\n  setTimeouts() {\n    let {\n      script,\n      pageLoad,\n      implicit\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let cmd = new command.Command(command.Name.SET_TIMEOUT);\n    let valid = false;\n    function setParam(key, value) {\n      if (value === null || typeof value === 'number') {\n        valid = true;\n        cmd.setParameter(key, value);\n      } else if (typeof value !== 'undefined') {\n        throw TypeError('invalid timeouts configuration:' + ` expected \"${key}\" to be a number, got ${typeof value}`);\n      }\n    }\n    setParam('implicit', implicit);\n    setParam('pageLoad', pageLoad);\n    setParam('script', script);\n    if (valid) {\n      return this.driver_.execute(cmd).catch(() => {\n        // Fallback to the legacy method.\n        let cmds = [];\n        if (typeof script === 'number') {\n          cmds.push(legacyTimeout(this.driver_, 'script', script));\n        }\n        if (typeof implicit === 'number') {\n          cmds.push(legacyTimeout(this.driver_, 'implicit', implicit));\n        }\n        if (typeof pageLoad === 'number') {\n          cmds.push(legacyTimeout(this.driver_, 'page load', pageLoad));\n        }\n        return Promise.all(cmds);\n      });\n    }\n    throw TypeError('no timeouts specified');\n  }\n\n  /**\n   * @return {!Logs} The interface for managing driver logs.\n   */\n  logs() {\n    return new Logs(this.driver_);\n  }\n\n  /**\n   * @return {!Window} The interface for managing the current window.\n   */\n  window() {\n    return new Window(this.driver_);\n  }\n}\n\n/**\n * @param {!WebDriver} driver\n * @param {string} type\n * @param {number} ms\n * @return {!Promise<void>}\n */\nfunction legacyTimeout(driver, type, ms) {\n  return driver.execute(new command.Command(command.Name.SET_TIMEOUT).setParameter('type', type).setParameter('ms', ms));\n}\n\n/**\n * A record object describing a browser cookie.\n *\n * @record\n */\nOptions.Cookie = function () {};\n\n/**\n * The name of the cookie.\n *\n * @type {string}\n */\nOptions.Cookie.prototype.name;\n\n/**\n * The cookie value.\n *\n * @type {string}\n */\nOptions.Cookie.prototype.value;\n\n/**\n * The cookie path. Defaults to \"/\" when adding a cookie.\n *\n * @type {(string|undefined)}\n */\nOptions.Cookie.prototype.path;\n\n/**\n * The domain the cookie is visible to. Defaults to the current browsing\n * context's document's URL when adding a cookie.\n *\n * @type {(string|undefined)}\n */\nOptions.Cookie.prototype.domain;\n\n/**\n * Whether the cookie is a secure cookie. Defaults to false when adding a new\n * cookie.\n *\n * @type {(boolean|undefined)}\n */\nOptions.Cookie.prototype.secure;\n\n/**\n * Whether the cookie is an HTTP only cookie. Defaults to false when adding a\n * new cookie.\n *\n * @type {(boolean|undefined)}\n */\nOptions.Cookie.prototype.httpOnly;\n\n/**\n * When the cookie expires.\n *\n * When {@linkplain Options#addCookie() adding a cookie}, this may be specified\n * as a {@link Date} object, or in _seconds_ since Unix epoch (January 1, 1970).\n *\n * The expiry is always returned in seconds since epoch when\n * {@linkplain Options#getCookies() retrieving cookies} from the browser.\n *\n * @type {(!Date|number|undefined)}\n */\nOptions.Cookie.prototype.expiry;\n\n/**\n * When the cookie applies to a SameSite policy.\n *\n * When {@linkplain Options#addCookie() adding a cookie}, this may be specified\n * as a {@link string} object which is one of 'Lax', 'Strict' or 'None'.\n *\n *\n * @type {(string|undefined)}\n */\nOptions.Cookie.prototype.sameSite;\n\n/**\n * An interface for managing the current window.\n *\n * This class should never be instantiated directly. Instead, obtain an instance\n * with\n *\n *    webdriver.manage().window()\n *\n * @see WebDriver#manage()\n * @see Options#window()\n */\nclass Window {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n\n  /**\n   * Retrieves a rect describing the current top-level window's size and\n   * position.\n   *\n   * @return {!Promise<{x: number, y: number, width: number, height: number}>}\n   *     A promise that will resolve to the window rect of the current window.\n   */\n  getRect() {\n    return this.driver_.execute(new command.Command(command.Name.GET_WINDOW_RECT));\n  }\n\n  /**\n   * Sets the current top-level window's size and position. You may update just\n   * the size by omitting `x` & `y`, or just the position by omitting\n   * `width` & `height` options.\n   *\n   * @param {{x: (number|undefined),\n   *          y: (number|undefined),\n   *          width: (number|undefined),\n   *          height: (number|undefined)}} options\n   *     The desired window size and position.\n   * @return {!Promise<{x: number, y: number, width: number, height: number}>}\n   *     A promise that will resolve to the current window's updated window\n   *     rect.\n   */\n  setRect(_ref2) {\n    let {\n      x,\n      y,\n      width,\n      height\n    } = _ref2;\n    return this.driver_.execute(new command.Command(command.Name.SET_WINDOW_RECT).setParameters({\n      x,\n      y,\n      width,\n      height\n    }));\n  }\n\n  /**\n   * Maximizes the current window. The exact behavior of this command is\n   * specific to individual window managers, but typically involves increasing\n   * the window to the maximum available size without going full-screen.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the command\n   *     has completed.\n   */\n  maximize() {\n    return this.driver_.execute(new command.Command(command.Name.MAXIMIZE_WINDOW).setParameter('windowHandle', 'current'));\n  }\n\n  /**\n   * Minimizes the current window. The exact behavior of this command is\n   * specific to individual window managers, but typically involves hiding\n   * the window in the system tray.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the command\n   *     has completed.\n   */\n  minimize() {\n    return this.driver_.execute(new command.Command(command.Name.MINIMIZE_WINDOW));\n  }\n\n  /**\n   * Invokes the \"full screen\" operation on the current window. The exact\n   * behavior of this command is specific to individual window managers, but\n   * this will typically increase the window size to the size of the physical\n   * display and hide the browser chrome.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the command\n   *     has completed.\n   * @see <https://fullscreen.spec.whatwg.org/#fullscreen-an-element>\n   */\n  fullscreen() {\n    return this.driver_.execute(new command.Command(command.Name.FULLSCREEN_WINDOW));\n  }\n\n  /**\n   * Gets the width and height of the current window\n   * @param windowHandle\n   * @returns {Promise<{width: *, height: *}>}\n   */\n  async getSize() {\n    let windowHandle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'current';\n    if (windowHandle !== 'current') {\n      console.warn(`Only 'current' window is supported for W3C compatible browsers.`);\n    }\n    const rect = await this.getRect();\n    return {\n      height: rect.height,\n      width: rect.width\n    };\n  }\n\n  /**\n   * Sets the width and height of the current window. (window.resizeTo)\n   * @param x\n   * @param y\n   * @param width\n   * @param height\n   * @param windowHandle\n   * @returns {Promise<void>}\n   */\n  async setSize(_ref3) {\n    let {\n      x = 0,\n      y = 0,\n      width = 0,\n      height = 0\n    } = _ref3;\n    let windowHandle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'current';\n    if (windowHandle !== 'current') {\n      console.warn(`Only 'current' window is supported for W3C compatible browsers.`);\n    }\n    await this.setRect({\n      x,\n      y,\n      width,\n      height\n    });\n  }\n}\n\n/**\n * Interface for managing WebDriver log records.\n *\n * This class should never be instantiated directly. Instead, obtain an\n * instance with\n *\n *     webdriver.manage().logs()\n *\n * @see WebDriver#manage()\n * @see Options#logs()\n */\nclass Logs {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n\n  /**\n   * Fetches available log entries for the given type.\n   *\n   * Note that log buffers are reset after each call, meaning that available\n   * log entries correspond to those entries not yet returned for a given log\n   * type. In practice, this means that this call will return the available log\n   * entries since the last call, or from the start of the session.\n   *\n   * @param {!logging.Type} type The desired log type.\n   * @return {!Promise<!Array.<!logging.Entry>>} A\n   *   promise that will resolve to a list of log entries for the specified\n   *   type.\n   */\n  get(type) {\n    let cmd = new command.Command(command.Name.GET_LOG).setParameter('type', type);\n    return this.driver_.execute(cmd).then(function (entries) {\n      return entries.map(function (entry) {\n        if (!(entry instanceof logging.Entry)) {\n          return new logging.Entry(entry['level'], entry['message'], entry['timestamp'], entry['type']);\n        }\n        return entry;\n      });\n    });\n  }\n\n  /**\n   * Retrieves the log types available to this driver.\n   * @return {!Promise<!Array<!logging.Type>>} A\n   *     promise that will resolve to a list of available log types.\n   */\n  getAvailableLogTypes() {\n    return this.driver_.execute(new command.Command(command.Name.GET_AVAILABLE_LOG_TYPES));\n  }\n}\n\n/**\n * An interface for changing the focus of the driver to another frame or window.\n *\n * This class should never be instantiated directly. Instead, obtain an\n * instance with\n *\n *     webdriver.switchTo()\n *\n * @see WebDriver#switchTo()\n */\nclass TargetLocator {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n\n  /**\n   * Locates the DOM element on the current page that corresponds to\n   * `document.activeElement` or `document.body` if the active element is not\n   * available.\n   *\n   * @return {!WebElementPromise} The active element.\n   */\n  activeElement() {\n    const id = this.driver_.execute(new command.Command(command.Name.GET_ACTIVE_ELEMENT));\n    return new WebElementPromise(this.driver_, id);\n  }\n\n  /**\n   * Switches focus of all future commands to the topmost frame in the current\n   * window.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the driver has changed focus to the default content.\n   */\n  defaultContent() {\n    return this.driver_.execute(new command.Command(command.Name.SWITCH_TO_FRAME).setParameter('id', null));\n  }\n\n  /**\n   * Changes the focus of all future commands to another frame on the page. The\n   * target frame may be specified as one of the following:\n   *\n   * - A number that specifies a (zero-based) index into [window.frames](\n   *   https://developer.mozilla.org/en-US/docs/Web/API/Window.frames).\n   * - A {@link WebElement} reference, which correspond to a `frame` or `iframe`\n   *   DOM element.\n   * - The `null` value, to select the topmost frame on the page. Passing `null`\n   *   is the same as calling {@link #defaultContent defaultContent()}.\n   *\n   * If the specified frame can not be found, the returned promise will be\n   * rejected with a {@linkplain error.NoSuchFrameError}.\n   *\n   * @param {(number|string|WebElement|null)} id The frame locator.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the driver has changed focus to the specified frame.\n   */\n  frame(id) {\n    let frameReference = id;\n    if (typeof id === 'string') {\n      frameReference = this.driver_.findElement({\n        id\n      }).catch(_ => this.driver_.findElement({\n        name: id\n      }));\n    }\n    return this.driver_.execute(new command.Command(command.Name.SWITCH_TO_FRAME).setParameter('id', frameReference));\n  }\n\n  /**\n   * Changes the focus of all future commands to the parent frame of the\n   * currently selected frame. This command has no effect if the driver is\n   * already focused on the top-level browsing context.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the command\n   *     has completed.\n   */\n  parentFrame() {\n    return this.driver_.execute(new command.Command(command.Name.SWITCH_TO_FRAME_PARENT));\n  }\n\n  /**\n   * Changes the focus of all future commands to another window. Windows may be\n   * specified by their {@code window.name} attribute or by its handle\n   * (as returned by {@link WebDriver#getWindowHandles}).\n   *\n   * If the specified window cannot be found, the returned promise will be\n   * rejected with a {@linkplain error.NoSuchWindowError}.\n   *\n   * @param {string} nameOrHandle The name or window handle of the window to\n   *     switch focus to.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the driver has changed focus to the specified window.\n   */\n  window(nameOrHandle) {\n    return this.driver_.execute(new command.Command(command.Name.SWITCH_TO_WINDOW)\n    // \"name\" supports the legacy drivers. \"handle\" is the W3C\n    // compliant parameter.\n    .setParameter('name', nameOrHandle).setParameter('handle', nameOrHandle));\n  }\n\n  /**\n   * Creates a new browser window and switches the focus for future\n   * commands of this driver to the new window.\n   *\n   * @param {string} typeHint 'window' or 'tab'. The created window is not\n   *     guaranteed to be of the requested type; if the driver does not support\n   *     the requested type, a new browser window will be created of whatever type\n   *     the driver does support.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the driver has changed focus to the new window.\n   */\n  newWindow(typeHint) {\n    const driver = this.driver_;\n    return this.driver_.execute(new command.Command(command.Name.SWITCH_TO_NEW_WINDOW).setParameter('type', typeHint)).then(function (response) {\n      return driver.switchTo().window(response.handle);\n    });\n  }\n\n  /**\n   * Changes focus to the active modal dialog, such as those opened by\n   * `window.alert()`, `window.confirm()`, and `window.prompt()`. The returned\n   * promise will be rejected with a\n   * {@linkplain error.NoSuchAlertError} if there are no open alerts.\n   *\n   * @return {!AlertPromise} The open alert.\n   */\n  alert() {\n    const text = this.driver_.execute(new command.Command(command.Name.GET_ALERT_TEXT));\n    const driver = this.driver_;\n    return new AlertPromise(driver, text.then(function (text) {\n      return new Alert(driver, text);\n    }));\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  WebElement\n//\n//////////////////////////////////////////////////////////////////////////////\n\nconst LEGACY_ELEMENT_ID_KEY = 'ELEMENT';\nconst ELEMENT_ID_KEY = 'element-6066-11e4-a52e-4f735466cecf';\nconst SHADOW_ROOT_ID_KEY = 'shadow-6066-11e4-a52e-4f735466cecf';\n\n/**\n * Represents a DOM element. WebElements can be found by searching from the\n * document root using a {@link WebDriver} instance, or by searching\n * under another WebElement:\n *\n *     driver.get('http://www.google.com');\n *     var searchForm = driver.findElement(By.tagName('form'));\n *     var searchBox = searchForm.findElement(By.name('q'));\n *     searchBox.sendKeys('webdriver');\n */\nclass WebElement {\n  /**\n   * @param {!WebDriver} driver the parent WebDriver instance for this element.\n   * @param {(!IThenable<string>|string)} id The server-assigned opaque ID for\n   *     the underlying DOM element.\n   */\n  constructor(driver, id) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n\n    /** @private {!Promise<string>} */\n    this.id_ = Promise.resolve(id);\n  }\n\n  /**\n   * @param {string} id The raw ID.\n   * @param {boolean=} noLegacy Whether to exclude the legacy element key.\n   * @return {!Object} The element ID for use with WebDriver's wire protocol.\n   */\n  static buildId(id) {\n    let noLegacy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return noLegacy ? {\n      [ELEMENT_ID_KEY]: id\n    } : {\n      [ELEMENT_ID_KEY]: id,\n      [LEGACY_ELEMENT_ID_KEY]: id\n    };\n  }\n\n  /**\n   * Extracts the encoded WebElement ID from the object.\n   *\n   * @param {?} obj The object to extract the ID from.\n   * @return {string} the extracted ID.\n   * @throws {TypeError} if the object is not a valid encoded ID.\n   */\n  static extractId(obj) {\n    return webElement.extractId(obj);\n  }\n\n  /**\n   * @param {?} obj the object to test.\n   * @return {boolean} whether the object is a valid encoded WebElement ID.\n   */\n  static isId(obj) {\n    return webElement.isId(obj);\n  }\n\n  /**\n   * Compares two WebElements for equality.\n   *\n   * @param {!WebElement} a A WebElement.\n   * @param {!WebElement} b A WebElement.\n   * @return {!Promise<boolean>} A promise that will be\n   *     resolved to whether the two WebElements are equal.\n   */\n  static async equals(a, b) {\n    if (a === b) {\n      return true;\n    }\n    return a.driver_.executeScript('return arguments[0] === arguments[1]', a, b);\n  }\n\n  /** @return {!WebDriver} The parent driver for this instance. */\n  getDriver() {\n    return this.driver_;\n  }\n\n  /**\n   * @return {!Promise<string>} A promise that resolves to\n   *     the server-assigned opaque ID assigned to this element.\n   */\n  getId() {\n    return this.id_;\n  }\n\n  /**\n   * @return {!Object} Returns the serialized representation of this WebElement.\n   */\n  [Symbols.serialize]() {\n    return this.getId().then(WebElement.buildId);\n  }\n\n  /**\n   * Schedules a command that targets this element with the parent WebDriver\n   * instance. Will ensure this element's ID is included in the command\n   * parameters under the \"id\" key.\n   *\n   * @param {!command.Command} command The command to schedule.\n   * @return {!Promise<T>} A promise that will be resolved with the result.\n   * @template T\n   * @see WebDriver#schedule\n   * @private\n   */\n  execute_(command) {\n    command.setParameter('id', this);\n    return this.driver_.execute(command);\n  }\n\n  /**\n   * Schedule a command to find a descendant of this element. If the element\n   * cannot be found, the returned promise will be rejected with a\n   * {@linkplain error.NoSuchElementError NoSuchElementError}.\n   *\n   * The search criteria for an element may be defined using one of the static\n   * factories on the {@link by.By} class, or as a short-hand\n   * {@link ./by.ByHash} object. For example, the following two statements\n   * are equivalent:\n   *\n   *     var e1 = element.findElement(By.id('foo'));\n   *     var e2 = element.findElement({id:'foo'});\n   *\n   * You may also provide a custom locator function, which takes as input this\n   * instance and returns a {@link WebElement}, or a promise that will resolve\n   * to a WebElement. If the returned promise resolves to an array of\n   * WebElements, WebDriver will use the first element. For example, to find the\n   * first visible link on a page, you could write:\n   *\n   *     var link = element.findElement(firstVisibleLink);\n   *\n   *     function firstVisibleLink(element) {\n   *       var links = element.findElements(By.tagName('a'));\n   *       return promise.filter(links, function(link) {\n   *         return link.isDisplayed();\n   *       });\n   *     }\n   *\n   * @param {!(by.By|Function)} locator The locator strategy to use when\n   *     searching for the element.\n   * @return {!WebElementPromise} A WebElement that can be used to issue\n   *     commands against the located element. If the element is not found, the\n   *     element will be invalidated and all scheduled commands aborted.\n   */\n  findElement(locator) {\n    locator = by.checkedLocator(locator);\n    let id;\n    if (typeof locator === 'function') {\n      id = this.driver_.findElementInternal_(locator, this);\n    } else {\n      let cmd = new command.Command(command.Name.FIND_CHILD_ELEMENT).setParameter('using', locator.using).setParameter('value', locator.value);\n      id = this.execute_(cmd);\n    }\n    return new WebElementPromise(this.driver_, id);\n  }\n\n  /**\n   * Locates all the descendants of this element that match the given search\n   * criteria.\n   *\n   * @param {!(by.By|Function)} locator The locator strategy to use when\n   *     searching for the element.\n   * @return {!Promise<!Array<!WebElement>>} A promise that will resolve to an\n   *     array of WebElements.\n   */\n  async findElements(locator) {\n    locator = by.checkedLocator(locator);\n    if (typeof locator === 'function') {\n      return this.driver_.findElementsInternal_(locator, this);\n    } else {\n      let cmd = new command.Command(command.Name.FIND_CHILD_ELEMENTS).setParameter('using', locator.using).setParameter('value', locator.value);\n      let result = await this.execute_(cmd);\n      return Array.isArray(result) ? result : [];\n    }\n  }\n\n  /**\n   * Clicks on this element.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the click\n   *     command has completed.\n   */\n  click() {\n    return this.execute_(new command.Command(command.Name.CLICK_ELEMENT));\n  }\n\n  /**\n   * Types a key sequence on the DOM element represented by this instance.\n   *\n   * Modifier keys (SHIFT, CONTROL, ALT, META) are stateful; once a modifier is\n   * processed in the key sequence, that key state is toggled until one of the\n   * following occurs:\n   *\n   * - The modifier key is encountered again in the sequence. At this point the\n   *   state of the key is toggled (along with the appropriate keyup/down\n   *   events).\n   * - The {@link input.Key.NULL} key is encountered in the sequence. When\n   *   this key is encountered, all modifier keys current in the down state are\n   *   released (with accompanying keyup events). The NULL key can be used to\n   *   simulate common keyboard shortcuts:\n   *\n   *         element.sendKeys(\"text was\",\n   *                          Key.CONTROL, \"a\", Key.NULL,\n   *                          \"now text is\");\n   *         // Alternatively:\n   *         element.sendKeys(\"text was\",\n   *                          Key.chord(Key.CONTROL, \"a\"),\n   *                          \"now text is\");\n   *\n   * - The end of the key sequence is encountered. When there are no more keys\n   *   to type, all depressed modifier keys are released (with accompanying\n   *   keyup events).\n   *\n   * If this element is a file input ({@code <input type=\"file\">}), the\n   * specified key sequence should specify the path to the file to attach to\n   * the element. This is analogous to the user clicking \"Browse...\" and entering\n   * the path into the file select dialog.\n   *\n   *     var form = driver.findElement(By.css('form'));\n   *     var element = form.findElement(By.css('input[type=file]'));\n   *     element.sendKeys('/path/to/file.txt');\n   *     form.submit();\n   *\n   * For uploads to function correctly, the entered path must reference a file\n   * on the _browser's_ machine, not the local machine running this script. When\n   * running against a remote Selenium server, a {@link input.FileDetector}\n   * may be used to transparently copy files to the remote machine before\n   * attempting to upload them in the browser.\n   *\n   * __Note:__ On browsers where native keyboard events are not supported\n   * (e.g. Firefox on OS X), key events will be synthesized. Special\n   * punctuation keys will be synthesized according to a standard QWERTY en-us\n   * keyboard layout.\n   *\n   * @param {...(number|string|!IThenable<(number|string)>)} args The\n   *     sequence of keys to type. Number keys may be referenced numerically or\n   *     by string (1 or '1'). All arguments will be joined into a single\n   *     sequence.\n   * @return {!Promise<void>} A promise that will be resolved when all keys\n   *     have been typed.\n   */\n  async sendKeys() {\n    let keys = [];\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    (await Promise.all(args)).forEach(key => {\n      let type = typeof key;\n      if (type === 'number') {\n        key = String(key);\n      } else if (type !== 'string') {\n        throw TypeError('each key must be a number or string; got ' + type);\n      }\n\n      // The W3C protocol requires keys to be specified as an array where\n      // each element is a single key.\n      keys.push(...key);\n    });\n    if (!this.driver_.fileDetector_) {\n      return this.execute_(new command.Command(command.Name.SEND_KEYS_TO_ELEMENT).setParameter('text', keys.join('')).setParameter('value', keys));\n    }\n    try {\n      keys = await this.driver_.fileDetector_.handleFile(this.driver_, keys.join(''));\n    } catch (ex) {\n      console.log('Error trying parse string as a file with file detector; sending keys instead' + ex);\n    }\n    return this.execute_(new command.Command(command.Name.SEND_KEYS_TO_ELEMENT).setParameter('text', keys).setParameter('value', keys.split('')));\n  }\n\n  /**\n   * Retrieves the element's tag name.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the\n   *     element's tag name.\n   */\n  getTagName() {\n    return this.execute_(new command.Command(command.Name.GET_ELEMENT_TAG_NAME));\n  }\n\n  /**\n   * Retrieves the value of a computed style property for this instance. If\n   * the element inherits the named style from its parent, the parent will be\n   * queried for its value.  Where possible, color values will be converted to\n   * their hex representation (e.g. #00ff00 instead of rgb(0, 255, 0)).\n   *\n   * _Warning:_ the value returned will be as the browser interprets it, so\n   * it may be tricky to form a proper assertion.\n   *\n   * @param {string} cssStyleProperty The name of the CSS style property to look\n   *     up.\n   * @return {!Promise<string>} A promise that will be resolved with the\n   *     requested CSS value.\n   */\n  getCssValue(cssStyleProperty) {\n    const name = command.Name.GET_ELEMENT_VALUE_OF_CSS_PROPERTY;\n    return this.execute_(new command.Command(name).setParameter('propertyName', cssStyleProperty));\n  }\n\n  /**\n   * Retrieves the current value of the given attribute of this element.\n   * Will return the current value, even if it has been modified after the page\n   * has been loaded. More exactly, this method will return the value\n   * of the given attribute, unless that attribute is not present, in which case\n   * the value of the property with the same name is returned. If neither value\n   * is set, null is returned (for example, the \"value\" property of a textarea\n   * element). The \"style\" attribute is converted as best can be to a\n   * text representation with a trailing semicolon. The following are deemed to\n   * be \"boolean\" attributes and will return either \"true\" or null:\n   *\n   * async, autofocus, autoplay, checked, compact, complete, controls, declare,\n   * defaultchecked, defaultselected, defer, disabled, draggable, ended,\n   * formnovalidate, hidden, indeterminate, iscontenteditable, ismap, itemscope,\n   * loop, multiple, muted, nohref, noresize, noshade, novalidate, nowrap, open,\n   * paused, pubdate, readonly, required, reversed, scoped, seamless, seeking,\n   * selected, spellcheck, truespeed, willvalidate\n   *\n   * Finally, the following commonly mis-capitalized attribute/property names\n   * are evaluated as expected:\n   *\n   * - \"class\"\n   * - \"readonly\"\n   *\n   * @param {string} attributeName The name of the attribute to query.\n   * @return {!Promise<?string>} A promise that will be\n   *     resolved with the attribute's value. The returned value will always be\n   *     either a string or null.\n   */\n  getAttribute(attributeName) {\n    return this.execute_(new command.Command(command.Name.GET_ELEMENT_ATTRIBUTE).setParameter('name', attributeName));\n  }\n\n  /**\n   * Get the value of the given attribute of the element.\n   * <p>\n   * This method, unlike {@link #getAttribute(String)}, returns the value of the attribute with the\n   * given name but not the property with the same name.\n   * <p>\n   * The following are deemed to be \"boolean\" attributes, and will return either \"true\" or null:\n   * <p>\n   * async, autofocus, autoplay, checked, compact, complete, controls, declare, defaultchecked,\n   * defaultselected, defer, disabled, draggable, ended, formnovalidate, hidden, indeterminate,\n   * iscontenteditable, ismap, itemscope, loop, multiple, muted, nohref, noresize, noshade,\n   * novalidate, nowrap, open, paused, pubdate, readonly, required, reversed, scoped, seamless,\n   * seeking, selected, truespeed, willvalidate\n   * <p>\n   * See <a href=\"https://w3c.github.io/webdriver/#get-element-attribute\">W3C WebDriver specification</a>\n   * for more details.\n   *\n   * @param attributeName The name of the attribute.\n   * @return The attribute's value or null if the value is not set.\n   */\n\n  getDomAttribute(attributeName) {\n    return this.execute_(new command.Command(command.Name.GET_DOM_ATTRIBUTE).setParameter('name', attributeName));\n  }\n\n  /**\n   * Get the given property of the referenced web element\n   * @param {string} propertyName The name of the attribute to query.\n   * @return {!Promise<string>} A promise that will be\n   *     resolved with the element's property value\n   */\n  getProperty(propertyName) {\n    return this.execute_(new command.Command(command.Name.GET_ELEMENT_PROPERTY).setParameter('name', propertyName));\n  }\n\n  /**\n   * Get the shadow root of the current web element.\n   * @returns {!Promise<ShadowRoot>} A promise that will be\n   *      resolved with the elements shadow root or rejected\n   *      with {@link NoSuchShadowRootError}\n   */\n  getShadowRoot() {\n    return this.execute_(new command.Command(command.Name.GET_SHADOW_ROOT));\n  }\n\n  /**\n   * Get the visible (i.e. not hidden by CSS) innerText of this element,\n   * including sub-elements, without any leading or trailing whitespace.\n   *\n   * @return {!Promise<string>} A promise that will be\n   *     resolved with the element's visible text.\n   */\n  getText() {\n    return this.execute_(new command.Command(command.Name.GET_ELEMENT_TEXT));\n  }\n\n  /**\n   * Get the computed WAI-ARIA role of element.\n   *\n   * @return {!Promise<string>} A promise that will be\n   *     resolved with the element's computed role.\n   */\n  getAriaRole() {\n    return this.execute_(new command.Command(command.Name.GET_COMPUTED_ROLE));\n  }\n\n  /**\n   * Get the computed WAI-ARIA label of element.\n   *\n   * @return {!Promise<string>} A promise that will be\n   *     resolved with the element's computed label.\n   */\n  getAccessibleName() {\n    return this.execute_(new command.Command(command.Name.GET_COMPUTED_LABEL));\n  }\n  /**\n   * Returns an object describing an element's location, in pixels relative to\n   * the document element, and the element's size in pixels.\n   *\n   * @return {!Promise<{width: number, height: number, x: number, y: number}>}\n   *     A promise that will resolve with the element's rect.\n   */\n  getRect() {\n    return this.execute_(new command.Command(command.Name.GET_ELEMENT_RECT));\n  }\n\n  /**\n   * Tests whether this element is enabled, as dictated by the `disabled`\n   * attribute.\n   *\n   * @return {!Promise<boolean>} A promise that will be\n   *     resolved with whether this element is currently enabled.\n   */\n  isEnabled() {\n    return this.execute_(new command.Command(command.Name.IS_ELEMENT_ENABLED));\n  }\n\n  /**\n   * Tests whether this element is selected.\n   *\n   * @return {!Promise<boolean>} A promise that will be\n   *     resolved with whether this element is currently selected.\n   */\n  isSelected() {\n    return this.execute_(new command.Command(command.Name.IS_ELEMENT_SELECTED));\n  }\n\n  /**\n   * Submits the form containing this element (or this element if it is itself\n   * a FORM element). his command is a no-op if the element is not contained in\n   * a form.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the form has been submitted.\n   */\n  submit() {\n    const script = '/* submitForm */var form = arguments[0];\\n' + 'while (form.nodeName != \"FORM\" && form.parentNode) {\\n' + '  form = form.parentNode;\\n' + '}\\n' + \"if (!form) { throw Error('Unable to find containing form element'); }\\n\" + \"if (!form.ownerDocument) { throw Error('Unable to find owning document'); }\\n\" + \"var e = form.ownerDocument.createEvent('Event');\\n\" + \"e.initEvent('submit', true, true);\\n\" + 'if (form.dispatchEvent(e)) { HTMLFormElement.prototype.submit.call(form) }\\n';\n    return this.driver_.executeScript(script, this);\n  }\n\n  /**\n   * Clear the `value` of this element. This command has no effect if the\n   * underlying DOM element is neither a text INPUT element nor a TEXTAREA\n   * element.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the element has been cleared.\n   */\n  clear() {\n    return this.execute_(new command.Command(command.Name.CLEAR_ELEMENT));\n  }\n\n  /**\n   * Test whether this element is currently displayed.\n   *\n   * @return {!Promise<boolean>} A promise that will be\n   *     resolved with whether this element is currently visible on the page.\n   */\n  isDisplayed() {\n    return this.execute_(new command.Command(command.Name.IS_ELEMENT_DISPLAYED));\n  }\n\n  /**\n   * Take a screenshot of the visible region encompassed by this element's\n   * bounding rectangle.\n   *\n   * @return {!Promise<string>} A promise that will be\n   *     resolved to the screenshot as a base-64 encoded PNG.\n   */\n  takeScreenshot() {\n    return this.execute_(new command.Command(command.Name.TAKE_ELEMENT_SCREENSHOT));\n  }\n}\n\n/**\n * WebElementPromise is a promise that will be fulfilled with a WebElement.\n * This serves as a forward proxy on WebElement, allowing calls to be\n * scheduled without directly on this instance before the underlying\n * WebElement has been fulfilled. In other words, the following two statements\n * are equivalent:\n *\n *     driver.findElement({id: 'my-button'}).click();\n *     driver.findElement({id: 'my-button'}).then(function(el) {\n *       return el.click();\n *     });\n *\n * @implements {IThenable<!WebElement>}\n * @final\n */\nclass WebElementPromise extends WebElement {\n  /**\n   * @param {!WebDriver} driver The parent WebDriver instance for this\n   *     element.\n   * @param {!Promise<!WebElement>} el A promise\n   *     that will resolve to the promised element.\n   */\n  constructor(driver, el) {\n    super(driver, 'unused');\n\n    /** @override */\n    this.then = el.then.bind(el);\n\n    /** @override */\n    this.catch = el.catch.bind(el);\n\n    /**\n     * Defers returning the element ID until the wrapped WebElement has been\n     * resolved.\n     * @override\n     */\n    this.getId = function () {\n      return el.then(function (el) {\n        return el.getId();\n      });\n    };\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  ShadowRoot\n//\n//////////////////////////////////////////////////////////////////////////////\n\n/**\n * Represents a ShadowRoot of a {@link WebElement}. Provides functions to\n * retrieve elements that live in the DOM below the ShadowRoot.\n */\nclass ShadowRoot {\n  constructor(driver, id) {\n    this.driver_ = driver;\n    this.id_ = id;\n  }\n\n  /**\n   * Extracts the encoded ShadowRoot ID from the object.\n   *\n   * @param {?} obj The object to extract the ID from.\n   * @return {string} the extracted ID.\n   * @throws {TypeError} if the object is not a valid encoded ID.\n   */\n  static extractId(obj) {\n    if (obj && typeof obj === 'object') {\n      if (typeof obj[SHADOW_ROOT_ID_KEY] === 'string') {\n        return obj[SHADOW_ROOT_ID_KEY];\n      }\n    }\n    throw new TypeError('object is not a ShadowRoot ID');\n  }\n\n  /**\n   * @param {?} obj the object to test.\n   * @return {boolean} whether the object is a valid encoded WebElement ID.\n   */\n  static isId(obj) {\n    return obj && typeof obj === 'object' && typeof obj[SHADOW_ROOT_ID_KEY] === 'string';\n  }\n\n  /**\n   * @return {!Object} Returns the serialized representation of this ShadowRoot.\n   */\n  [Symbols.serialize]() {\n    return this.getId();\n  }\n\n  /**\n   * Schedules a command that targets this element with the parent WebDriver\n   * instance. Will ensure this element's ID is included in the command\n   * parameters under the \"id\" key.\n   *\n   * @param {!command.Command} command The command to schedule.\n   * @return {!Promise<T>} A promise that will be resolved with the result.\n   * @template T\n   * @see WebDriver#schedule\n   * @private\n   */\n  execute_(command) {\n    command.setParameter('id', this);\n    return this.driver_.execute(command);\n  }\n\n  /**\n   * Schedule a command to find a descendant of this ShadowROot. If the element\n   * cannot be found, the returned promise will be rejected with a\n   * {@linkplain error.NoSuchElementError NoSuchElementError}.\n   *\n   * The search criteria for an element may be defined using one of the static\n   * factories on the {@link by.By} class, or as a short-hand\n   * {@link ./by.ByHash} object. For example, the following two statements\n   * are equivalent:\n   *\n   *     var e1 = shadowroot.findElement(By.id('foo'));\n   *     var e2 = shadowroot.findElement({id:'foo'});\n   *\n   * You may also provide a custom locator function, which takes as input this\n   * instance and returns a {@link WebElement}, or a promise that will resolve\n   * to a WebElement. If the returned promise resolves to an array of\n   * WebElements, WebDriver will use the first element. For example, to find the\n   * first visible link on a page, you could write:\n   *\n   *     var link = element.findElement(firstVisibleLink);\n   *\n   *     function firstVisibleLink(shadowRoot) {\n   *       var links = shadowRoot.findElements(By.tagName('a'));\n   *       return promise.filter(links, function(link) {\n   *         return link.isDisplayed();\n   *       });\n   *     }\n   *\n   * @param {!(by.By|Function)} locator The locator strategy to use when\n   *     searching for the element.\n   * @return {!WebElementPromise} A WebElement that can be used to issue\n   *     commands against the located element. If the element is not found, the\n   *     element will be invalidated and all scheduled commands aborted.\n   */\n  findElement(locator) {\n    locator = by.checkedLocator(locator);\n    let id;\n    if (typeof locator === 'function') {\n      id = this.driver_.findElementInternal_(locator, this);\n    } else {\n      let cmd = new command.Command(command.Name.FIND_ELEMENT_FROM_SHADOWROOT).setParameter('using', locator.using).setParameter('value', locator.value);\n      id = this.execute_(cmd);\n    }\n    return new ShadowRootPromise(this.driver_, id);\n  }\n\n  /**\n   * Locates all the descendants of this element that match the given search\n   * criteria.\n   *\n   * @param {!(by.By|Function)} locator The locator strategy to use when\n   *     searching for the element.\n   * @return {!Promise<!Array<!WebElement>>} A promise that will resolve to an\n   *     array of WebElements.\n   */\n  async findElements(locator) {\n    locator = by.checkedLocator(locator);\n    if (typeof locator === 'function') {\n      return this.driver_.findElementsInternal_(locator, this);\n    } else {\n      let cmd = new command.Command(command.Name.FIND_ELEMENTS_FROM_SHADOWROOT).setParameter('using', locator.using).setParameter('value', locator.value);\n      let result = await this.execute_(cmd);\n      return Array.isArray(result) ? result : [];\n    }\n  }\n  getId() {\n    return this.id_;\n  }\n}\n\n/**\n * ShadowRootPromise is a promise that will be fulfilled with a WebElement.\n * This serves as a forward proxy on ShadowRoot, allowing calls to be\n * scheduled without directly on this instance before the underlying\n * ShadowRoot has been fulfilled.\n *\n * @implements { IThenable<!ShadowRoot>}\n * @final\n */\nclass ShadowRootPromise extends ShadowRoot {\n  /**\n   * @param {!WebDriver} driver The parent WebDriver instance for this\n   *     element.\n   * @param {!Promise<!ShadowRoot>} shadow A promise\n   *     that will resolve to the promised element.\n   */\n  constructor(driver, shadow) {\n    super(driver, 'unused');\n\n    /** @override */\n    this.then = shadow.then.bind(shadow);\n\n    /** @override */\n    this.catch = shadow.catch.bind(shadow);\n\n    /**\n     * Defers returning the ShadowRoot ID until the wrapped WebElement has been\n     * resolved.\n     * @override\n     */\n    this.getId = function () {\n      return shadow.then(function (shadow) {\n        return shadow.getId();\n      });\n    };\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  Alert\n//\n//////////////////////////////////////////////////////////////////////////////\n\n/**\n * Represents a modal dialog such as {@code alert}, {@code confirm}, or\n * {@code prompt}. Provides functions to retrieve the message displayed with\n * the alert, accept or dismiss the alert, and set the response text (in the\n * case of {@code prompt}).\n */\nclass Alert {\n  /**\n   * @param {!WebDriver} driver The driver controlling the browser this alert\n   *     is attached to.\n   * @param {string} text The message text displayed with this alert.\n   */\n  constructor(driver, text) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n\n    /** @private {!Promise<string>} */\n    this.text_ = Promise.resolve(text);\n  }\n\n  /**\n   * Retrieves the message text displayed with this alert. For instance, if the\n   * alert were opened with alert(\"hello\"), then this would return \"hello\".\n   *\n   * @return {!Promise<string>} A promise that will be\n   *     resolved to the text displayed with this alert.\n   */\n  getText() {\n    return this.text_;\n  }\n\n  /**\n   * Accepts this alert.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when this command has completed.\n   */\n  accept() {\n    return this.driver_.execute(new command.Command(command.Name.ACCEPT_ALERT));\n  }\n\n  /**\n   * Dismisses this alert.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when this command has completed.\n   */\n  dismiss() {\n    return this.driver_.execute(new command.Command(command.Name.DISMISS_ALERT));\n  }\n\n  /**\n   * Sets the response text on this alert. This command will return an error if\n   * the underlying alert does not support response text (e.g. window.alert and\n   * window.confirm).\n   *\n   * @param {string} text The text to set.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when this command has completed.\n   */\n  sendKeys(text) {\n    return this.driver_.execute(new command.Command(command.Name.SET_ALERT_TEXT).setParameter('text', text));\n  }\n}\n\n/**\n * AlertPromise is a promise that will be fulfilled with an Alert. This promise\n * serves as a forward proxy on an Alert, allowing calls to be scheduled\n * directly on this instance before the underlying Alert has been fulfilled. In\n * other words, the following two statements are equivalent:\n *\n *     driver.switchTo().alert().dismiss();\n *     driver.switchTo().alert().then(function(alert) {\n *       return alert.dismiss();\n *     });\n *\n * @implements {IThenable<!Alert>}\n * @final\n */\nclass AlertPromise extends Alert {\n  /**\n   * @param {!WebDriver} driver The driver controlling the browser this\n   *     alert is attached to.\n   * @param {!Promise<!Alert>} alert A thenable\n   *     that will be fulfilled with the promised alert.\n   */\n  constructor(driver, alert) {\n    super(driver, 'unused');\n\n    /** @override */\n    this.then = alert.then.bind(alert);\n\n    /** @override */\n    this.catch = alert.catch.bind(alert);\n\n    /**\n     * Defer returning text until the promised alert has been resolved.\n     * @override\n     */\n    this.getText = function () {\n      return alert.then(function (alert) {\n        return alert.getText();\n      });\n    };\n\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n    this.accept = function () {\n      return alert.then(function (alert) {\n        return alert.accept();\n      });\n    };\n\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n    this.dismiss = function () {\n      return alert.then(function (alert) {\n        return alert.dismiss();\n      });\n    };\n\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n    this.sendKeys = function (text) {\n      return alert.then(function (alert) {\n        return alert.sendKeys(text);\n      });\n    };\n  }\n}\n\n// PUBLIC API\n\nmodule.exports = {\n  Alert,\n  AlertPromise,\n  Condition,\n  Logs,\n  Navigation,\n  Options,\n  ShadowRoot,\n  TargetLocator,\n  IWebDriver,\n  WebDriver,\n  WebElement,\n  WebElementCondition,\n  WebElementPromise,\n  Window\n};","map":{"version":3,"names":["by","require","RelativeBy","command","error","input","logging","promise","Symbols","cdp","WebSocket","http","fs","Capabilities","path","NoSuchElementError","cdpTargets","Credential","webElement","isObject","BIDI","PinnedScript","W3C_CAPABILITY_NAMES","Set","Condition","constructor","message","fn","description_","description","WebElementCondition","executeCommand","executor","toWireValue","getParameters","then","parameters","setParameters","execute","obj","value","Promise","resolve","Array","isArray","convertKeys","serialize","toJSON","numKeys","length","Object","keys","ret","forEachKey","i","n","key","fromWireValue","driver","map","v","WebElement","isId","id","extractId","ShadowRoot","result","prototype","hasOwnProperty","call","resolveWaitMessage","IWebDriver","setFileDetector","detector","getExecutor","getSession","getCapabilities","quit","actions","options","executeScript","script","executeAsyncScript","wait","condition","timeout","arguments","undefined","pollTimeout","sleep","ms","getWindowHandle","getAllWindowHandles","getPageSource","close","get","url","getCurrentUrl","getTitle","findElement","locator","findElements","takeScreenshot","manage","navigate","switchTo","printPage","filterNonW3CCaps","capabilities","newCaps","k","has","indexOf","delete","WebDriver","session","onQuit","session_","catch","executor_","fileDetector_","onQuit_","authenticatorId_","pinnedScripts_","createSession","cmd","Command","Name","NEW_SESSION","setParameter","firstMatch","alwaysMatch","err","_","s","QUIT","finally","reject","NoSuchSessionError","Actions","_len","args","_key","EXECUTE_SCRIPT","executionScript","_len2","_key2","EXECUTE_ASYNC_SCRIPT","TypeError","isPromise","start","Date","now","timer","setTimeout","timeoutMessage","TimeoutError","ex","clearTimer","clearTimeout","evaluateCondition","startTime","pollCondition","elapsed","WebElementPromise","toString","GET_CURRENT_WINDOW_HANDLE","GET_WINDOW_HANDLES","GET_PAGE_SOURCE","CLOSE","to","GET_CURRENT_URL","GET_TITLE","FIND_ELEMENTS_RELATIVE","marshall","checkedLocator","findElementInternal_","FIND_ELEMENT","using","normalize_","webElementPromise","locatorFn","context","findElementsInternal_","FIND_ELEMENTS","res","filter","item","SCREENSHOT","Options","Navigation","TargetLocator","validatePrintPageParams","object","page","margin","data","forEach","orientation","scale","background","width","height","top","left","bottom","right","shrinkToFit","pageRanges","InvalidArgumentError","params","resultObj","self","PRINT_PAGE","createCDPConnection","target","debuggerUrl","caps","process","env","SELENIUM_REMOTE_URL","host","URL","sessionId","getId","seCdp","vendorInfo","VENDOR_COMMAND_PREFIX","VENDOR_CAPABILITY_PREFIX","Map","_wsUrl","getWsUrl","_wsConnection","replace","_cdpConnection","CdpConnection","on","getCdpTargets","JSON","parse","targetInfos","targets","find","info","type","targetID","targetId","flatten","getBidi","WebSocketUrl","debuggerAddress","toLowerCase","match","request","Request","client","HttpClient","response","send","body","register","username","password","connection","method","requestParams","requestId","authChallengeResponse","requestPausedParams","handleAuthRequests","cacheDisabled","onIntercept","httpResponse","callback","urlToIntercept","responseCode","status","responseHeaders","headers","onLogEvent","consoleEventParams","event","timestamp","logEventParams","logEntry","level","onLogException","exceptionEventParams","exceptionDetails","logMutationEvents","name","mutationListener","readFileSync","__dirname","source","payload","elements","css","escapeCss","element","attribute_name","current_value","old_value","pinScript","pinnedScript","is","expression","creationScript","scriptId","handle","unpinScript","Error","removalScript","identifier","virtualAuthenticatorId","addVirtualAuthenticator","ADD_VIRTUAL_AUTHENTICATOR","toDict","removeVirtualAuthenticator","REMOVE_VIRTUAL_AUTHENTICATOR","addCredential","credential","ADD_CREDENTIAL","getCredentials","credential_data","GET_CREDENTIALS","credential_list","push","fromDict","removeCredential","credential_id","Buffer","from","REMOVE_CREDENTIAL","removeAllCredentials","REMOVE_ALL_CREDENTIALS","setUserVerified","verified","SET_USER_VERIFIED","driver_","GET","back","GO_BACK","forward","GO_FORWARD","refresh","REFRESH","addCookie","_ref","domain","secure","httpOnly","expiry","sameSite","test","Math","floor","date","getTime","includes","ADD_COOKIE","deleteAllCookies","DELETE_ALL_COOKIES","deleteCookie","DELETE_COOKIE","getCookies","GET_ALL_COOKIES","getCookie","cookie","GET_COOKIE","UnknownCommandError","UnsupportedOperationError","cookies","getTimeouts","GET_TIMEOUT","setTimeouts","pageLoad","implicit","SET_TIMEOUT","valid","setParam","cmds","legacyTimeout","all","logs","Logs","window","Window","Cookie","getRect","GET_WINDOW_RECT","setRect","_ref2","x","y","SET_WINDOW_RECT","maximize","MAXIMIZE_WINDOW","minimize","MINIMIZE_WINDOW","fullscreen","FULLSCREEN_WINDOW","getSize","windowHandle","console","warn","rect","setSize","_ref3","GET_LOG","entries","entry","Entry","getAvailableLogTypes","GET_AVAILABLE_LOG_TYPES","activeElement","GET_ACTIVE_ELEMENT","defaultContent","SWITCH_TO_FRAME","frame","frameReference","parentFrame","SWITCH_TO_FRAME_PARENT","nameOrHandle","SWITCH_TO_WINDOW","newWindow","typeHint","SWITCH_TO_NEW_WINDOW","alert","text","GET_ALERT_TEXT","AlertPromise","Alert","LEGACY_ELEMENT_ID_KEY","ELEMENT_ID_KEY","SHADOW_ROOT_ID_KEY","id_","buildId","noLegacy","equals","a","b","getDriver","execute_","FIND_CHILD_ELEMENT","FIND_CHILD_ELEMENTS","click","CLICK_ELEMENT","sendKeys","_len3","_key3","String","SEND_KEYS_TO_ELEMENT","join","handleFile","log","split","getTagName","GET_ELEMENT_TAG_NAME","getCssValue","cssStyleProperty","GET_ELEMENT_VALUE_OF_CSS_PROPERTY","getAttribute","attributeName","GET_ELEMENT_ATTRIBUTE","getDomAttribute","GET_DOM_ATTRIBUTE","getProperty","propertyName","GET_ELEMENT_PROPERTY","getShadowRoot","GET_SHADOW_ROOT","getText","GET_ELEMENT_TEXT","getAriaRole","GET_COMPUTED_ROLE","getAccessibleName","GET_COMPUTED_LABEL","GET_ELEMENT_RECT","isEnabled","IS_ELEMENT_ENABLED","isSelected","IS_ELEMENT_SELECTED","submit","clear","CLEAR_ELEMENT","isDisplayed","IS_ELEMENT_DISPLAYED","TAKE_ELEMENT_SCREENSHOT","el","bind","FIND_ELEMENT_FROM_SHADOWROOT","ShadowRootPromise","FIND_ELEMENTS_FROM_SHADOWROOT","shadow","text_","accept","ACCEPT_ALERT","dismiss","DISMISS_ALERT","SET_ALERT_TEXT","module","exports"],"sources":["/Users/Shared/ATS Git/ATSDemo/ReactJs/ReactCaseStudy/my-app/node_modules/selenium-webdriver/lib/webdriver.js"],"sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview The heart of the WebDriver JavaScript API.\n */\n\n'use strict'\n\nconst by = require('./by')\nconst { RelativeBy } = require('./by')\nconst command = require('./command')\nconst error = require('./error')\nconst input = require('./input')\nconst logging = require('./logging')\nconst promise = require('./promise')\nconst Symbols = require('./symbols')\nconst cdp = require('../devtools/CDPConnection')\nconst WebSocket = require('ws')\nconst http = require('../http/index')\nconst fs = require('fs')\nconst { Capabilities } = require('./capabilities')\nconst path = require('path')\nconst { NoSuchElementError } = require('./error')\nconst cdpTargets = ['page', 'browser']\nconst { Credential } = require('./virtual_authenticator')\nconst webElement = require('./webelement')\nconst { isObject } = require('./util')\nconst BIDI = require('../bidi')\nconst { PinnedScript } = require('./pinnedScript')\n\n// Capability names that are defined in the W3C spec.\nconst W3C_CAPABILITY_NAMES = new Set([\n  'acceptInsecureCerts',\n  'browserName',\n  'browserVersion',\n  'pageLoadStrategy',\n  'platformName',\n  'proxy',\n  'setWindowRect',\n  'strictFileInteractability',\n  'timeouts',\n  'unhandledPromptBehavior',\n  'webSocketUrl',\n])\n\n/**\n * Defines a condition for use with WebDriver's {@linkplain WebDriver#wait wait\n * command}.\n *\n * @template OUT\n */\nclass Condition {\n  /**\n   * @param {string} message A descriptive error message. Should complete the\n   *     sentence \"Waiting [...]\"\n   * @param {function(!WebDriver): OUT} fn The condition function to\n   *     evaluate on each iteration of the wait loop.\n   */\n  constructor(message, fn) {\n    /** @private {string} */\n    this.description_ = 'Waiting ' + message\n\n    /** @type {function(!WebDriver): OUT} */\n    this.fn = fn\n  }\n\n  /** @return {string} A description of this condition. */\n  description() {\n    return this.description_\n  }\n}\n\n/**\n * Defines a condition that will result in a {@link WebElement}.\n *\n * @extends {Condition<!(WebElement|IThenable<!WebElement>)>}\n */\nclass WebElementCondition extends Condition {\n  /**\n   * @param {string} message A descriptive error message. Should complete the\n   *     sentence \"Waiting [...]\"\n   * @param {function(!WebDriver): !(WebElement|IThenable<!WebElement>)}\n   *     fn The condition function to evaluate on each iteration of the wait\n   *     loop.\n   */\n  constructor(message, fn) {\n    super(message, fn)\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  WebDriver\n//\n//////////////////////////////////////////////////////////////////////////////\n\n/**\n * Translates a command to its wire-protocol representation before passing it\n * to the given `executor` for execution.\n * @param {!command.Executor} executor The executor to use.\n * @param {!command.Command} command The command to execute.\n * @return {!Promise} A promise that will resolve with the command response.\n */\nfunction executeCommand(executor, command) {\n  return toWireValue(command.getParameters()).then(function (parameters) {\n    command.setParameters(parameters)\n    return executor.execute(command)\n  })\n}\n\n/**\n * Converts an object to its JSON representation in the WebDriver wire protocol.\n * When converting values of type object, the following steps will be taken:\n * <ol>\n * <li>if the object is a WebElement, the return value will be the element's\n *     server ID\n * <li>if the object defines a {@link Symbols.serialize} method, this algorithm\n *     will be recursively applied to the object's serialized representation\n * <li>if the object provides a \"toJSON\" function, this algorithm will\n *     recursively be applied to the result of that function\n * <li>otherwise, the value of each key will be recursively converted according\n *     to the rules above.\n * </ol>\n *\n * @param {*} obj The object to convert.\n * @return {!Promise<?>} A promise that will resolve to the input value's JSON\n *     representation.\n */\nasync function toWireValue(obj) {\n  let value = await Promise.resolve(obj)\n  if (value === void 0 || value === null) {\n    return value\n  }\n\n  if (\n    typeof value === 'boolean' ||\n    typeof value === 'number' ||\n    typeof value === 'string'\n  ) {\n    return value\n  }\n\n  if (Array.isArray(value)) {\n    return convertKeys(value)\n  }\n\n  if (typeof value === 'function') {\n    return '' + value\n  }\n\n  if (typeof value[Symbols.serialize] === 'function') {\n    return toWireValue(value[Symbols.serialize]())\n  } else if (typeof value.toJSON === 'function') {\n    return toWireValue(value.toJSON())\n  }\n  return convertKeys(value)\n}\n\nasync function convertKeys(obj) {\n  const isArray = Array.isArray(obj)\n  const numKeys = isArray ? obj.length : Object.keys(obj).length\n  const ret = isArray ? new Array(numKeys) : {}\n  if (!numKeys) {\n    return ret\n  }\n\n  async function forEachKey(obj, fn) {\n    if (Array.isArray(obj)) {\n      for (let i = 0, n = obj.length; i < n; i++) {\n        await fn(obj[i], i)\n      }\n    } else {\n      for (let key in obj) {\n        await fn(obj[key], key)\n      }\n    }\n  }\n\n  await forEachKey(obj, async function (value, key) {\n    ret[key] = await toWireValue(value)\n  })\n\n  return ret\n}\n\n/**\n * Converts a value from its JSON representation according to the WebDriver wire\n * protocol. Any JSON object that defines a WebElement ID will be decoded to a\n * {@link WebElement} object. All other values will be passed through as is.\n *\n * @param {!WebDriver} driver The driver to use as the parent of any unwrapped\n *     {@link WebElement} values.\n * @param {*} value The value to convert.\n * @return {*} The converted value.\n */\nfunction fromWireValue(driver, value) {\n  if (Array.isArray(value)) {\n    value = value.map((v) => fromWireValue(driver, v))\n  } else if (WebElement.isId(value)) {\n    let id = WebElement.extractId(value)\n    value = new WebElement(driver, id)\n  } else if (ShadowRoot.isId(value)) {\n    let id = ShadowRoot.extractId(value)\n    value = new ShadowRoot(driver, id)\n  } else if (isObject(value)) {\n    let result = {}\n    for (let key in value) {\n      if (Object.prototype.hasOwnProperty.call(value, key)) {\n        result[key] = fromWireValue(driver, value[key])\n      }\n    }\n    value = result\n  }\n  return value\n}\n\n/**\n * Resolves a wait message from either a function or a string.\n * @param {(string|Function)=} message An optional message to use if the wait times out.\n * @return {string} The resolved message\n */\nfunction resolveWaitMessage(message) {\n  return message\n    ? `${typeof message === 'function' ? message() : message}\\n`\n    : ''\n}\n\n/**\n * Structural interface for a WebDriver client.\n *\n * @record\n */\nclass IWebDriver {\n  /**\n   * Executes the provided {@link command.Command} using this driver's\n   * {@link command.Executor}.\n   *\n   * @param {!command.Command} command The command to schedule.\n   * @return {!Promise<T>} A promise that will be resolved with the command\n   *     result.\n   * @template T\n   */\n  execute(command) {} // eslint-disable-line\n\n  /**\n   * Sets the {@linkplain input.FileDetector file detector} that should be\n   * used with this instance.\n   * @param {input.FileDetector} detector The detector to use or `null`.\n   */\n  setFileDetector(detector) {} // eslint-disable-line\n\n  /**\n   * @return {!command.Executor} The command executor used by this instance.\n   */\n  getExecutor() {}\n\n  /**\n   * @return {!Promise<!Session>} A promise for this client's session.\n   */\n  getSession() {}\n\n  /**\n   * @return {!Promise<!Capabilities>} A promise that will resolve with\n   *     the instance's capabilities.\n   */\n  getCapabilities() {}\n\n  /**\n   * Terminates the browser session. After calling quit, this instance will be\n   * invalidated and may no longer be used to issue commands against the\n   * browser.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the\n   *     command has completed.\n   */\n  quit() {}\n\n  /**\n   * Creates a new action sequence using this driver. The sequence will not be\n   * submitted for execution until\n   * {@link ./input.Actions#perform Actions.perform()} is called.\n   *\n   * @param {{async: (boolean|undefined),\n   *          bridge: (boolean|undefined)}=} options Configuration options for\n   *     the action sequence (see {@link ./input.Actions Actions} documentation\n   *     for details).\n   * @return {!input.Actions} A new action sequence for this instance.\n   */\n  actions(options) {} // eslint-disable-line\n\n  /**\n   * Executes a snippet of JavaScript in the context of the currently selected\n   * frame or window. The script fragment will be executed as the body of an\n   * anonymous function. If the script is provided as a function object, that\n   * function will be converted to a string for injection into the target\n   * window.\n   *\n   * Any arguments provided in addition to the script will be included as script\n   * arguments and may be referenced using the `arguments` object. Arguments may\n   * be a boolean, number, string, or {@linkplain WebElement}. Arrays and\n   * objects may also be used as script arguments as long as each item adheres\n   * to the types previously mentioned.\n   *\n   * The script may refer to any variables accessible from the current window.\n   * Furthermore, the script will execute in the window's context, thus\n   * `document` may be used to refer to the current document. Any local\n   * variables will not be available once the script has finished executing,\n   * though global variables will persist.\n   *\n   * If the script has a return value (i.e. if the script contains a return\n   * statement), then the following steps will be taken for resolving this\n   * functions return value:\n   *\n   * - For a HTML element, the value will resolve to a {@linkplain WebElement}\n   * - Null and undefined return values will resolve to null</li>\n   * - Booleans, numbers, and strings will resolve as is</li>\n   * - Functions will resolve to their string representation</li>\n   * - For arrays and objects, each member item will be converted according to\n   *     the rules above\n   *\n   * @param {!(string|Function)} script The script to execute.\n   * @param {...*} args The arguments to pass to the script.\n   * @return {!IThenable<T>} A promise that will resolve to the\n   *    scripts return value.\n   * @template T\n   */\n  executeScript(script, ...args) {} // eslint-disable-line\n\n  /**\n   * Executes a snippet of asynchronous JavaScript in the context of the\n   * currently selected frame or window. The script fragment will be executed as\n   * the body of an anonymous function. If the script is provided as a function\n   * object, that function will be converted to a string for injection into the\n   * target window.\n   *\n   * Any arguments provided in addition to the script will be included as script\n   * arguments and may be referenced using the `arguments` object. Arguments may\n   * be a boolean, number, string, or {@linkplain WebElement}. Arrays and\n   * objects may also be used as script arguments as long as each item adheres\n   * to the types previously mentioned.\n   *\n   * Unlike executing synchronous JavaScript with {@link #executeScript},\n   * scripts executed with this function must explicitly signal they are\n   * finished by invoking the provided callback. This callback will always be\n   * injected into the executed function as the last argument, and thus may be\n   * referenced with  `arguments[arguments.length - 1]`. The following steps\n   * will be taken for resolving this functions return value against the first\n   * argument to the script's callback function:\n   *\n   * - For a HTML element, the value will resolve to a {@link WebElement}\n   * - Null and undefined return values will resolve to null\n   * - Booleans, numbers, and strings will resolve as is\n   * - Functions will resolve to their string representation\n   * - For arrays and objects, each member item will be converted according to\n   *     the rules above\n   *\n   * __Example #1:__ Performing a sleep that is synchronized with the currently\n   * selected window:\n   *\n   *     var start = new Date().getTime();\n   *     driver.executeAsyncScript(\n   *         'window.setTimeout(arguments[arguments.length - 1], 500);').\n   *         then(function() {\n   *           console.log(\n   *               'Elapsed time: ' + (new Date().getTime() - start) + ' ms');\n   *         });\n   *\n   * __Example #2:__ Synchronizing a test with an AJAX application:\n   *\n   *     var button = driver.findElement(By.id('compose-button'));\n   *     button.click();\n   *     driver.executeAsyncScript(\n   *         'var callback = arguments[arguments.length - 1];' +\n   *         'mailClient.getComposeWindowWidget().onload(callback);');\n   *     driver.switchTo().frame('composeWidget');\n   *     driver.findElement(By.id('to')).sendKeys('dog@example.com');\n   *\n   * __Example #3:__ Injecting a XMLHttpRequest and waiting for the result. In\n   * this example, the inject script is specified with a function literal. When\n   * using this format, the function is converted to a string for injection, so\n   * it should not reference any symbols not defined in the scope of the page\n   * under test.\n   *\n   *     driver.executeAsyncScript(function() {\n   *       var callback = arguments[arguments.length - 1];\n   *       var xhr = new XMLHttpRequest();\n   *       xhr.open(\"GET\", \"/resource/data.json\", true);\n   *       xhr.onreadystatechange = function() {\n   *         if (xhr.readyState == 4) {\n   *           callback(xhr.responseText);\n   *         }\n   *       };\n   *       xhr.send('');\n   *     }).then(function(str) {\n   *       console.log(JSON.parse(str)['food']);\n   *     });\n   *\n   * @param {!(string|Function)} script The script to execute.\n   * @param {...*} args The arguments to pass to the script.\n   * @return {!IThenable<T>} A promise that will resolve to the scripts return\n   *     value.\n   * @template T\n   */\n  executeAsyncScript(script, ...args) {} // eslint-disable-line\n\n  /**\n   * Waits for a condition to evaluate to a \"truthy\" value. The condition may be\n   * specified by a {@link Condition}, as a custom function, or as any\n   * promise-like thenable.\n   *\n   * For a {@link Condition} or function, the wait will repeatedly\n   * evaluate the condition until it returns a truthy value. If any errors occur\n   * while evaluating the condition, they will be allowed to propagate. In the\n   * event a condition returns a {@linkplain Promise}, the polling loop will\n   * wait for it to be resolved and use the resolved value for whether the\n   * condition has been satisfied. The resolution time for a promise is always\n   * factored into whether a wait has timed out.\n   *\n   * If the provided condition is a {@link WebElementCondition}, then\n   * the wait will return a {@link WebElementPromise} that will resolve to the\n   * element that satisfied the condition.\n   *\n   * _Example:_ waiting up to 10 seconds for an element to be present on the\n   * page.\n   *\n   *     async function example() {\n   *       let button =\n   *           await driver.wait(until.elementLocated(By.id('foo')), 10000);\n   *       await button.click();\n   *     }\n   *\n   * @param {!(IThenable<T>|\n   *           Condition<T>|\n   *           function(!WebDriver): T)} condition The condition to\n   *     wait on, defined as a promise, condition object, or  a function to\n   *     evaluate as a condition.\n   * @param {number=} timeout The duration in milliseconds, how long to wait\n   *     for the condition to be true.\n   * @param {(string|Function)=} message An optional message to use if the wait times out.\n   * @param {number=} pollTimeout The duration in milliseconds, how long to\n   *     wait between polling the condition.\n   * @return {!(IThenable<T>|WebElementPromise)} A promise that will be\n   *     resolved with the first truthy value returned by the condition\n   *     function, or rejected if the condition times out. If the input\n   *     condition is an instance of a {@link WebElementCondition},\n   *     the returned value will be a {@link WebElementPromise}.\n   * @throws {TypeError} if the provided `condition` is not a valid type.\n   * @template T\n   */\n  wait(\n    condition, // eslint-disable-line\n    timeout = undefined, // eslint-disable-line\n    message = undefined, // eslint-disable-line\n    pollTimeout = undefined // eslint-disable-line\n  ) {}\n\n  /**\n   * Makes the driver sleep for the given amount of time.\n   *\n   * @param {number} ms The amount of time, in milliseconds, to sleep.\n   * @return {!Promise<void>} A promise that will be resolved when the sleep has\n   *     finished.\n   */\n  sleep(ms) {} // eslint-disable-line\n\n  /**\n   * Retrieves the current window handle.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the current\n   *     window handle.\n   */\n  getWindowHandle() {}\n\n  /**\n   * Retrieves a list of all available window handles.\n   *\n   * @return {!Promise<!Array<string>>} A promise that will be resolved with an\n   *     array of window handles.\n   */\n  getAllWindowHandles() {}\n\n  /**\n   * Retrieves the current page's source. The returned source is a representation\n   * of the underlying DOM: do not expect it to be formatted or escaped in the\n   * same way as the raw response sent from the web server.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the current\n   *     page source.\n   */\n  getPageSource() {}\n\n  /**\n   * Closes the current window.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when this command\n   *     has completed.\n   */\n  close() {}\n\n  /**\n   * Navigates to the given URL.\n   *\n   * @param {string} url The fully qualified URL to open.\n   * @return {!Promise<void>} A promise that will be resolved when the document\n   *     has finished loading.\n   */\n  get(url) {} // eslint-disable-line\n\n  /**\n   * Retrieves the URL for the current page.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the\n   *     current URL.\n   */\n  getCurrentUrl() {}\n\n  /**\n   * Retrieves the current page title.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the current\n   *     page's title.\n   */\n  getTitle() {}\n\n  /**\n   * Locates an element on the page. If the element cannot be found, a\n   * {@link error.NoSuchElementError} will be returned by the driver.\n   *\n   * This function should not be used to test whether an element is present on\n   * the page. Rather, you should use {@link #findElements}:\n   *\n   *     driver.findElements(By.id('foo'))\n   *         .then(found => console.log('Element found? %s', !!found.length));\n   *\n   * The search criteria for an element may be defined using one of the\n   * factories in the {@link webdriver.By} namespace, or as a short-hand\n   * {@link webdriver.By.Hash} object. For example, the following two statements\n   * are equivalent:\n   *\n   *     var e1 = driver.findElement(By.id('foo'));\n   *     var e2 = driver.findElement({id:'foo'});\n   *\n   * You may also provide a custom locator function, which takes as input this\n   * instance and returns a {@link WebElement}, or a promise that will resolve\n   * to a WebElement. If the returned promise resolves to an array of\n   * WebElements, WebDriver will use the first element. For example, to find the\n   * first visible link on a page, you could write:\n   *\n   *     var link = driver.findElement(firstVisibleLink);\n   *\n   *     function firstVisibleLink(driver) {\n   *       var links = driver.findElements(By.tagName('a'));\n   *       return promise.filter(links, function(link) {\n   *         return link.isDisplayed();\n   *       });\n   *     }\n   *\n   * @param {!(by.By|Function)} locator The locator to use.\n   * @return {!WebElementPromise} A WebElement that can be used to issue\n   *     commands against the located element. If the element is not found, the\n   *     element will be invalidated and all scheduled commands aborted.\n   */\n  findElement(locator) {} // eslint-disable-line\n\n  /**\n   * Search for multiple elements on the page. Refer to the documentation on\n   * {@link #findElement(by)} for information on element locator strategies.\n   *\n   * @param {!(by.By|Function)} locator The locator to use.\n   * @return {!Promise<!Array<!WebElement>>} A promise that will resolve to an\n   *     array of WebElements.\n   */\n  findElements(locator) {} // eslint-disable-line\n\n  /**\n   * Takes a screenshot of the current page. The driver makes the best effort to\n   * return a screenshot of the following, in order of preference:\n   *\n   * 1. Entire page\n   * 2. Current window\n   * 3. Visible portion of the current frame\n   * 4. The entire display containing the browser\n   *\n   * @return {!Promise<string>} A promise that will be resolved to the\n   *     screenshot as a base-64 encoded PNG.\n   */\n  takeScreenshot() {}\n\n  /**\n   * @return {!Options} The options interface for this instance.\n   */\n  manage() {}\n\n  /**\n   * @return {!Navigation} The navigation interface for this instance.\n   */\n  navigate() {}\n\n  /**\n   * @return {!TargetLocator} The target locator interface for this\n   *     instance.\n   */\n  switchTo() {}\n\n  /**\n   *\n   * Takes a PDF of the current page. The driver makes a best effort to\n   * return a PDF based on the provided parameters.\n   *\n   * @param {{orientation:(string|undefined),\n   *         scale:(number|undefined),\n   *         background:(boolean|undefined),\n   *         width:(number|undefined),\n   *         height:(number|undefined),\n   *         top:(number|undefined),\n   *         bottom:(number|undefined),\n   *         left:(number|undefined),\n   *         right:(number|undefined),\n   *         shrinkToFit:(boolean|undefined),\n   *         pageRanges:(Array|undefined)}} options\n   */\n  printPage(options) {} // eslint-disable-line\n}\n\n/**\n * @param {!Capabilities} capabilities A capabilities object.\n * @return {!Capabilities} A copy of the parameter capabilities, omitting\n *     capability names that are not valid W3C names.\n */\nfunction filterNonW3CCaps(capabilities) {\n  let newCaps = new Capabilities(capabilities)\n  for (let k of newCaps.keys()) {\n    // Any key containing a colon is a vendor-prefixed capability.\n    if (!(W3C_CAPABILITY_NAMES.has(k) || k.indexOf(':') >= 0)) {\n      newCaps.delete(k)\n    }\n  }\n  return newCaps\n}\n\n/**\n * Each WebDriver instance provides automated control over a browser session.\n *\n * @implements {IWebDriver}\n */\nclass WebDriver {\n  /**\n   * @param {!(./session.Session|IThenable<!./session.Session>)} session Either\n   *     a known session or a promise that will be resolved to a session.\n   * @param {!command.Executor} executor The executor to use when sending\n   *     commands to the browser.\n   * @param {(function(this: void): ?)=} onQuit A function to call, if any,\n   *     when the session is terminated.\n   */\n  constructor(session, executor, onQuit = undefined) {\n    /** @private {!Promise<!Session>} */\n    this.session_ = Promise.resolve(session)\n\n    // If session is a rejected promise, add a no-op rejection handler.\n    // This effectively hides setup errors until users attempt to interact\n    // with the session.\n    this.session_.catch(function () {})\n\n    /** @private {!command.Executor} */\n    this.executor_ = executor\n\n    /** @private {input.FileDetector} */\n    this.fileDetector_ = null\n\n    /** @private @const {(function(this: void): ?|undefined)} */\n    this.onQuit_ = onQuit\n\n    /** @private {./virtual_authenticator}*/\n    this.authenticatorId_ = null\n\n    this.pinnedScripts_ = {}\n  }\n\n  /**\n   * Creates a new WebDriver session.\n   *\n   * This function will always return a WebDriver instance. If there is an error\n   * creating the session, such as the aforementioned SessionNotCreatedError,\n   * the driver will have a rejected {@linkplain #getSession session} promise.\n   * This rejection will propagate through any subsequent commands scheduled\n   * on the returned WebDriver instance.\n   *\n   *     let required = Capabilities.firefox();\n   *     let driver = WebDriver.createSession(executor, {required});\n   *\n   *     // If the createSession operation failed, then this command will also\n   *     // also fail, propagating the creation failure.\n   *     driver.get('http://www.google.com').catch(e => console.log(e));\n   *\n   * @param {!command.Executor} executor The executor to create the new session\n   *     with.\n   * @param {!Capabilities} capabilities The desired capabilities for the new\n   *     session.\n   * @param {(function(this: void): ?)=} onQuit A callback to invoke when\n   *    the newly created session is terminated. This should be used to clean\n   *    up any resources associated with the session.\n   * @return {!WebDriver} The driver for the newly created session.\n   */\n  static createSession(executor, capabilities, onQuit = undefined) {\n    let cmd = new command.Command(command.Name.NEW_SESSION)\n\n    // For W3C remote ends.\n    cmd.setParameter('capabilities', {\n      firstMatch: [{}],\n      alwaysMatch: filterNonW3CCaps(capabilities),\n    })\n\n    let session = executeCommand(executor, cmd)\n    if (typeof onQuit === 'function') {\n      session = session.catch((err) => {\n        return Promise.resolve(onQuit.call(void 0)).then((_) => {\n          throw err\n        })\n      })\n    }\n    return new this(session, executor, onQuit)\n  }\n\n  /** @override */\n  async execute(command) {\n    command.setParameter('sessionId', this.session_)\n\n    let parameters = await toWireValue(command.getParameters())\n    command.setParameters(parameters)\n    let value = await this.executor_.execute(command)\n    return fromWireValue(this, value)\n  }\n\n  /** @override */\n  setFileDetector(detector) {\n    this.fileDetector_ = detector\n  }\n\n  /** @override */\n  getExecutor() {\n    return this.executor_\n  }\n\n  /** @override */\n  getSession() {\n    return this.session_\n  }\n\n  /** @override */\n  getCapabilities() {\n    return this.session_.then((s) => s.getCapabilities())\n  }\n\n  /** @override */\n  quit() {\n    let result = this.execute(new command.Command(command.Name.QUIT))\n    // Delete our session ID when the quit command finishes; this will allow us\n    // to throw an error when attempting to use a driver post-quit.\n    return promise.finally(result, () => {\n      this.session_ = Promise.reject(\n        new error.NoSuchSessionError(\n          'This driver instance does not have a valid session ID ' +\n            '(did you call WebDriver.quit()?) and may no longer be used.'\n        )\n      )\n\n      // Only want the session rejection to bubble if accessed.\n      this.session_.catch(function () {})\n\n      if (this.onQuit_) {\n        return this.onQuit_.call(void 0)\n      }\n    })\n  }\n\n  /** @override */\n  actions(options) {\n    return new input.Actions(this, options || undefined)\n  }\n\n  /** @override */\n  executeScript(script, ...args) {\n    if (typeof script === 'function') {\n      script = 'return (' + script + ').apply(null, arguments);'\n    }\n\n    if (script && script instanceof PinnedScript) {\n      return this.execute(\n        new command.Command(command.Name.EXECUTE_SCRIPT)\n          .setParameter('script', script.executionScript())\n          .setParameter('args', args)\n      )\n    }\n\n    return this.execute(\n      new command.Command(command.Name.EXECUTE_SCRIPT)\n        .setParameter('script', script)\n        .setParameter('args', args)\n    )\n  }\n\n  /** @override */\n  executeAsyncScript(script, ...args) {\n    if (typeof script === 'function') {\n      script = 'return (' + script + ').apply(null, arguments);'\n    }\n\n    if (script && script instanceof PinnedScript) {\n      return this.execute(\n        new command.Command(command.Name.EXECUTE_ASYNC_SCRIPT)\n          .setParameter('script', script.executionScript())\n          .setParameter('args', args)\n      )\n    }\n\n    return this.execute(\n      new command.Command(command.Name.EXECUTE_ASYNC_SCRIPT)\n        .setParameter('script', script)\n        .setParameter('args', args)\n    )\n  }\n\n  /** @override */\n  wait(condition, timeout = 0, message = undefined, pollTimeout = 200) {\n    if (typeof timeout !== 'number' || timeout < 0) {\n      throw TypeError('timeout must be a number >= 0: ' + timeout)\n    }\n\n    if (typeof pollTimeout !== 'number' || pollTimeout < 0) {\n      throw TypeError('pollTimeout must be a number >= 0: ' + pollTimeout)\n    }\n\n    if (promise.isPromise(condition)) {\n      return new Promise((resolve, reject) => {\n        if (!timeout) {\n          resolve(condition)\n          return\n        }\n\n        let start = Date.now()\n        let timer = setTimeout(function () {\n          timer = null\n          try {\n            let timeoutMessage = resolveWaitMessage(message)\n            reject(\n              new error.TimeoutError(\n                `${timeoutMessage}Timed out waiting for promise to resolve after ${\n                  Date.now() - start\n                }ms`\n              )\n            )\n          } catch (ex) {\n            reject(\n              new error.TimeoutError(\n                `${\n                  ex.message\n                }\\nTimed out waiting for promise to resolve after ${\n                  Date.now() - start\n                }ms`\n              )\n            )\n          }\n        }, timeout)\n        const clearTimer = () => timer && clearTimeout(timer)\n\n        /** @type {!IThenable} */ condition.then(\n          function (value) {\n            clearTimer()\n            resolve(value)\n          },\n          function (error) {\n            clearTimer()\n            reject(error)\n          }\n        )\n      })\n    }\n\n    let fn = /** @type {!Function} */ (condition)\n    if (condition instanceof Condition) {\n      message = message || condition.description()\n      fn = condition.fn\n    }\n\n    if (typeof fn !== 'function') {\n      throw TypeError(\n        'Wait condition must be a promise-like object, function, or a ' +\n          'Condition object'\n      )\n    }\n\n    const driver = this\n    function evaluateCondition() {\n      return new Promise((resolve, reject) => {\n        try {\n          resolve(fn(driver))\n        } catch (ex) {\n          reject(ex)\n        }\n      })\n    }\n\n    let result = new Promise((resolve, reject) => {\n      const startTime = Date.now()\n      const pollCondition = async () => {\n        evaluateCondition().then(function (value) {\n          const elapsed = Date.now() - startTime\n          if (value) {\n            resolve(value)\n          } else if (timeout && elapsed >= timeout) {\n            try {\n              let timeoutMessage = resolveWaitMessage(message)\n              reject(\n                new error.TimeoutError(\n                  `${timeoutMessage}Wait timed out after ${elapsed}ms`\n                )\n              )\n            } catch (ex) {\n              reject(\n                new error.TimeoutError(\n                  `${ex.message}\\nWait timed out after ${elapsed}ms`\n                )\n              )\n            }\n          } else {\n            setTimeout(pollCondition, pollTimeout)\n          }\n        }, reject)\n      }\n      pollCondition()\n    })\n\n    if (condition instanceof WebElementCondition) {\n      result = new WebElementPromise(\n        this,\n        result.then(function (value) {\n          if (!(value instanceof WebElement)) {\n            throw TypeError(\n              'WebElementCondition did not resolve to a WebElement: ' +\n                Object.prototype.toString.call(value)\n            )\n          }\n          return value\n        })\n      )\n    }\n    return result\n  }\n\n  /** @override */\n  sleep(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms))\n  }\n\n  /** @override */\n  getWindowHandle() {\n    return this.execute(\n      new command.Command(command.Name.GET_CURRENT_WINDOW_HANDLE)\n    )\n  }\n\n  /** @override */\n  getAllWindowHandles() {\n    return this.execute(new command.Command(command.Name.GET_WINDOW_HANDLES))\n  }\n\n  /** @override */\n  getPageSource() {\n    return this.execute(new command.Command(command.Name.GET_PAGE_SOURCE))\n  }\n\n  /** @override */\n  close() {\n    return this.execute(new command.Command(command.Name.CLOSE))\n  }\n\n  /** @override */\n  get(url) {\n    return this.navigate().to(url)\n  }\n\n  /** @override */\n  getCurrentUrl() {\n    return this.execute(new command.Command(command.Name.GET_CURRENT_URL))\n  }\n\n  /** @override */\n  getTitle() {\n    return this.execute(new command.Command(command.Name.GET_TITLE))\n  }\n\n  /** @override */\n  findElement(locator) {\n    let id\n    let cmd = null\n\n    if (locator instanceof RelativeBy) {\n      cmd = new command.Command(\n        command.Name.FIND_ELEMENTS_RELATIVE\n      ).setParameter('args', locator.marshall())\n    } else {\n      locator = by.checkedLocator(locator)\n    }\n\n    if (typeof locator === 'function') {\n      id = this.findElementInternal_(locator, this)\n      return new WebElementPromise(this, id)\n    } else if (cmd === null) {\n      cmd = new command.Command(command.Name.FIND_ELEMENT)\n        .setParameter('using', locator.using)\n        .setParameter('value', locator.value)\n    }\n\n    id = this.execute(cmd)\n    if (locator instanceof RelativeBy) {\n      return this.normalize_(id)\n    } else {\n      return new WebElementPromise(this, id)\n    }\n  }\n\n  /**\n   * @param {!Function} webElementPromise The webElement in unresolved state\n   * @return {!Promise<!WebElement>} First single WebElement from array of resolved promises\n   */\n  async normalize_(webElementPromise) {\n    let result = await webElementPromise\n    if (result.length === 0) {\n      throw new NoSuchElementError(\n        'Cannot locate an element with provided parameters'\n      )\n    } else {\n      return result[0]\n    }\n  }\n\n  /**\n   * @param {!Function} locatorFn The locator function to use.\n   * @param {!(WebDriver|WebElement)} context The search context.\n   * @return {!Promise<!WebElement>} A promise that will resolve to a list of\n   *     WebElements.\n   * @private\n   */\n  async findElementInternal_(locatorFn, context) {\n    let result = await locatorFn(context)\n    if (Array.isArray(result)) {\n      result = result[0]\n    }\n    if (!(result instanceof WebElement)) {\n      throw new TypeError('Custom locator did not return a WebElement')\n    }\n    return result\n  }\n\n  /** @override */\n  async findElements(locator) {\n    let cmd = null\n    if (locator instanceof RelativeBy) {\n      cmd = new command.Command(\n        command.Name.FIND_ELEMENTS_RELATIVE\n      ).setParameter('args', locator.marshall())\n    } else {\n      locator = by.checkedLocator(locator)\n    }\n\n    if (typeof locator === 'function') {\n      return this.findElementsInternal_(locator, this)\n    } else if (cmd === null) {\n      cmd = new command.Command(command.Name.FIND_ELEMENTS)\n        .setParameter('using', locator.using)\n        .setParameter('value', locator.value)\n    }\n    try {\n      let res = await this.execute(cmd)\n      return Array.isArray(res) ? res : []\n    } catch (ex) {\n      if (ex instanceof error.NoSuchElementError) {\n        return []\n      }\n      throw ex\n    }\n  }\n\n  /**\n   * @param {!Function} locatorFn The locator function to use.\n   * @param {!(WebDriver|WebElement)} context The search context.\n   * @return {!Promise<!Array<!WebElement>>} A promise that will resolve to an\n   *     array of WebElements.\n   * @private\n   */\n  async findElementsInternal_(locatorFn, context) {\n    const result = await locatorFn(context)\n    if (result instanceof WebElement) {\n      return [result]\n    }\n\n    if (!Array.isArray(result)) {\n      return []\n    }\n\n    return result.filter(function (item) {\n      return item instanceof WebElement\n    })\n  }\n\n  /** @override */\n  takeScreenshot() {\n    return this.execute(new command.Command(command.Name.SCREENSHOT))\n  }\n\n  /** @override */\n  manage() {\n    return new Options(this)\n  }\n\n  /** @override */\n  navigate() {\n    return new Navigation(this)\n  }\n\n  /** @override */\n  switchTo() {\n    return new TargetLocator(this)\n  }\n\n  validatePrintPageParams(keys, object) {\n    let page = {}\n    let margin = {}\n    let data\n    Object.keys(keys).forEach(function (key) {\n      data = keys[key]\n      let obj = {\n        orientation: function () {\n          object.orientation = data\n        },\n\n        scale: function () {\n          object.scale = data\n        },\n\n        background: function () {\n          object.background = data\n        },\n\n        width: function () {\n          page.width = data\n          object.page = page\n        },\n\n        height: function () {\n          page.height = data\n          object.page = page\n        },\n\n        top: function () {\n          margin.top = data\n          object.margin = margin\n        },\n\n        left: function () {\n          margin.left = data\n          object.margin = margin\n        },\n\n        bottom: function () {\n          margin.bottom = data\n          object.margin = margin\n        },\n\n        right: function () {\n          margin.right = data\n          object.margin = margin\n        },\n\n        shrinkToFit: function () {\n          object.shrinkToFit = data\n        },\n\n        pageRanges: function () {\n          object.pageRanges = data\n        },\n      }\n\n      if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n        throw new error.InvalidArgumentError(`Invalid Argument '${key}'`)\n      } else {\n        obj[key]()\n      }\n    })\n\n    return object\n  }\n\n  /** @override */\n  printPage(options = {}) {\n    let keys = options\n    let params = {}\n    let resultObj\n\n    let self = this\n    resultObj = self.validatePrintPageParams(keys, params)\n\n    return this.execute(\n      new command.Command(command.Name.PRINT_PAGE).setParameters(resultObj)\n    )\n  }\n\n  /**\n   * Creates a new WebSocket connection.\n   * @return {!Promise<resolved>} A new CDP instance.\n   */\n  async createCDPConnection(target) {\n    let debuggerUrl = null\n\n    const caps = await this.getCapabilities()\n\n    if (process.env.SELENIUM_REMOTE_URL) {\n      const host = new URL(process.env.SELENIUM_REMOTE_URL).host\n      const sessionId = await this.getSession().then((session) =>\n        session.getId()\n      )\n      debuggerUrl = `ws://${host}/session/${sessionId}/se/cdp`\n    } else {\n      const seCdp = caps['map_'].get('se:cdp')\n      const vendorInfo =\n        caps['map_'].get(this.VENDOR_COMMAND_PREFIX + ':chromeOptions') ||\n        caps['map_'].get(this.VENDOR_CAPABILITY_PREFIX + ':edgeOptions') ||\n        caps['map_'].get('moz:debuggerAddress') ||\n        new Map()\n      debuggerUrl = seCdp || vendorInfo['debuggerAddress'] || vendorInfo\n    }\n    this._wsUrl = await this.getWsUrl(debuggerUrl, target, caps)\n    return new Promise((resolve, reject) => {\n      try {\n        this._wsConnection = new WebSocket(\n          this._wsUrl.replace('localhost', '127.0.0.1')\n        )\n        this._cdpConnection = new cdp.CdpConnection(this._wsConnection)\n      } catch (err) {\n        reject(err)\n        return\n      }\n\n      this._wsConnection.on('open', async () => {\n        await this.getCdpTargets()\n      })\n\n      this._wsConnection.on('message', async (message) => {\n        const params = JSON.parse(message)\n        if (params.result) {\n          if (params.result.targetInfos) {\n            const targets = params.result.targetInfos\n            const page = targets.find((info) => info.type === 'page')\n            if (page) {\n              this.targetID = page.targetId\n              this._cdpConnection.execute(\n                'Target.attachToTarget',\n                { targetId: this.targetID, flatten: true },\n                null\n              )\n            } else {\n              reject('Unable to find Page target.')\n            }\n          }\n          if (params.result.sessionId) {\n            this.sessionId = params.result.sessionId\n            this._cdpConnection.sessionId = this.sessionId\n            resolve(this._cdpConnection)\n          }\n        }\n      })\n\n      this._wsConnection.on('error', (error) => {\n        reject(error)\n      })\n    })\n  }\n\n  async getCdpTargets() {\n    this._cdpConnection.execute('Target.getTargets')\n  }\n\n  /**\n   * Initiates bidi connection using 'webSocketUrl'\n   * @returns {BIDI}\n   */\n  async getBidi() {\n    const caps = await this.getCapabilities()\n    let WebSocketUrl = caps['map_'].get('webSocketUrl')\n    return new BIDI(WebSocketUrl.replace('localhost', '127.0.0.1'))\n  }\n\n  /**\n   * Retrieves 'webSocketDebuggerUrl' by sending a http request using debugger address\n   * @param {string} debuggerAddress\n   * @param target\n   * @param caps\n   * @return {string} Returns parsed webSocketDebuggerUrl obtained from the http request\n   */\n  async getWsUrl(debuggerAddress, target, caps) {\n    if (target && cdpTargets.indexOf(target.toLowerCase()) === -1) {\n      throw new error.InvalidArgumentError('invalid target value')\n    }\n\n    if (debuggerAddress.match(/\\/se\\/cdp/)) {\n      return debuggerAddress\n    }\n\n    let path\n    if (target === 'page' && caps['map_'].get('browserName') !== 'firefox') {\n      path = '/json'\n    } else if (\n      target === 'page' &&\n      caps['map_'].get('browserName') === 'firefox'\n    ) {\n      path = '/json/list'\n    } else {\n      path = '/json/version'\n    }\n\n    let request = new http.Request('GET', path)\n    let client = new http.HttpClient('http://' + debuggerAddress)\n    let response = await client.send(request)\n\n    if (target.toLowerCase() === 'page') {\n      return JSON.parse(response.body)[0]['webSocketDebuggerUrl']\n    } else {\n      return JSON.parse(response.body)['webSocketDebuggerUrl']\n    }\n  }\n\n  /**\n   * Sets a listener for Fetch.authRequired event from CDP\n   * If event is triggered, it enters username and password\n   * and allows the test to move forward\n   * @param {string} username\n   * @param {string} password\n   * @param connection CDP Connection\n   */\n  async register(username, password, connection) {\n    this._wsConnection.on('message', (message) => {\n      const params = JSON.parse(message)\n\n      if (params.method === 'Fetch.authRequired') {\n        const requestParams = params['params']\n        connection.execute('Fetch.continueWithAuth', {\n          requestId: requestParams['requestId'],\n          authChallengeResponse: {\n            response: 'ProvideCredentials',\n            username: username,\n            password: password,\n          },\n        })\n      } else if (params.method === 'Fetch.requestPaused') {\n        const requestPausedParams = params['params']\n        connection.execute('Fetch.continueRequest', {\n          requestId: requestPausedParams['requestId'],\n        })\n      }\n    })\n\n    await connection.execute(\n      'Fetch.enable',\n      {\n        handleAuthRequests: true,\n      },\n      null\n    )\n    await connection.execute(\n      'Network.setCacheDisabled',\n      {\n        cacheDisabled: true,\n      },\n      null\n    )\n  }\n\n  /**\n   * Handle Network interception requests\n   * @param connection WebSocket connection to the browser\n   * @param httpResponse Object representing what we are intercepting\n   *                     as well as what should be returned.\n   * @param callback callback called when we intercept requests.\n   */\n  async onIntercept(connection, httpResponse, callback) {\n    this._wsConnection.on('message', (message) => {\n      const params = JSON.parse(message)\n      if (params.method === 'Fetch.requestPaused') {\n        const requestPausedParams = params['params']\n        if (requestPausedParams.request.url == httpResponse.urlToIntercept) {\n          connection.execute('Fetch.fulfillRequest', {\n            requestId: requestPausedParams['requestId'],\n            responseCode: httpResponse.status,\n            responseHeaders: httpResponse.headers,\n            body: httpResponse.body,\n          })\n          callback()\n        } else {\n          connection.execute('Fetch.continueRequest', {\n            requestId: requestPausedParams['requestId'],\n          })\n        }\n      }\n    })\n\n    await connection.execute('Fetch.enable', {}, null)\n    await connection.execute(\n      'Network.setCacheDisabled',\n      {\n        cacheDisabled: true,\n      },\n      null\n    )\n  }\n  /**\n   *\n   * @param connection\n   * @param callback\n   * @returns {Promise<void>}\n   */\n  async onLogEvent(connection, callback) {\n    this._wsConnection.on('message', (message) => {\n      const params = JSON.parse(message)\n      if (params.method === 'Runtime.consoleAPICalled') {\n        const consoleEventParams = params['params']\n        let event = {\n          type: consoleEventParams['type'],\n          timestamp: new Date(consoleEventParams['timestamp']),\n          args: consoleEventParams['args'],\n        }\n\n        callback(event)\n      }\n\n      if (params.method === 'Log.entryAdded') {\n        const logEventParams = params['params']\n        const logEntry = logEventParams['entry']\n        let event = {\n          level: logEntry['level'],\n          timestamp: new Date(logEntry['timestamp']),\n          message: logEntry['text'],\n        }\n\n        callback(event)\n      }\n    })\n    await connection.execute('Runtime.enable', {}, null)\n  }\n\n  /**\n   *\n   * @param connection\n   * @param callback\n   * @returns {Promise<void>}\n   */\n  async onLogException(connection, callback) {\n    await connection.execute('Runtime.enable', {}, null)\n\n    this._wsConnection.on('message', (message) => {\n      const params = JSON.parse(message)\n\n      if (params.method === 'Runtime.exceptionThrown') {\n        const exceptionEventParams = params['params']\n        let event = {\n          exceptionDetails: exceptionEventParams['exceptionDetails'],\n          timestamp: new Date(exceptionEventParams['timestamp']),\n        }\n\n        callback(event)\n      }\n    })\n  }\n\n  /**\n   * @param connection\n   * @param callback\n   * @returns {Promise<void>}\n   */\n  async logMutationEvents(connection, callback) {\n    await connection.execute('Runtime.enable', {}, null)\n    await connection.execute('Page.enable', {}, null)\n\n    await connection.execute(\n      'Runtime.addBinding',\n      {\n        name: '__webdriver_attribute',\n      },\n      null\n    )\n\n    let mutationListener = ''\n    try {\n      // Depending on what is running the code it could appear in 2 different places which is why we try\n      // here and then the other location\n      mutationListener = fs\n        .readFileSync(\n          './javascript/node/selenium-webdriver/lib/atoms/mutation-listener.js',\n          'utf-8'\n        )\n        .toString()\n    } catch {\n      mutationListener = fs\n        .readFileSync(\n          path.resolve(__dirname, './atoms/mutation-listener.js'),\n          'utf-8'\n        )\n        .toString()\n    }\n\n    this.executeScript(mutationListener)\n\n    await connection.execute(\n      'Page.addScriptToEvaluateOnNewDocument',\n      {\n        source: mutationListener,\n      },\n      null\n    )\n\n    this._wsConnection.on('message', async (message) => {\n      const params = JSON.parse(message)\n      if (params.method === 'Runtime.bindingCalled') {\n        let payload = JSON.parse(params['params']['payload'])\n        let elements = await this.findElements({\n          css: '*[data-__webdriver_id=' + by.escapeCss(payload['target']) + ']',\n        })\n\n        if (elements.length === 0) {\n          return\n        }\n\n        let event = {\n          element: elements[0],\n          attribute_name: payload['name'],\n          current_value: payload['value'],\n          old_value: payload['oldValue'],\n        }\n        callback(event)\n      }\n    })\n  }\n\n  async pinScript(script) {\n    let pinnedScript = new PinnedScript(script)\n    let connection\n    if (Object.is(this._cdpConnection, undefined)) {\n      connection = await this.createCDPConnection('page')\n    } else {\n      connection = this._cdpConnection\n    }\n\n    await connection.execute('Page.enable', {}, null)\n\n    await connection.execute(\n      'Runtime.evaluate',\n      {\n        expression: pinnedScript.creationScript(),\n      },\n      null\n    )\n\n    let result = await connection.send(\n      'Page.addScriptToEvaluateOnNewDocument',\n      {\n        source: pinnedScript.creationScript(),\n      }\n    )\n\n    pinnedScript.scriptId = result['result']['identifier']\n\n    this.pinnedScripts_[pinnedScript.handle] = pinnedScript\n\n    return pinnedScript\n  }\n\n  async unpinScript(script) {\n    if (script && !(script instanceof PinnedScript)) {\n      throw Error(`Pass valid PinnedScript object. Received: ${script}`)\n    }\n\n    if (script.handle in this.pinnedScripts_) {\n      let connection\n      if (Object.is(this._cdpConnection, undefined)) {\n        connection = this.createCDPConnection('page')\n      } else {\n        connection = this._cdpConnection\n      }\n\n      await connection.execute('Page.enable', {}, null)\n\n      await connection.execute(\n        'Runtime.evaluate',\n        {\n          expression: script.removalScript(),\n        },\n        null\n      )\n\n      await connection.execute(\n        'Page.removeScriptToEvaluateOnLoad',\n        {\n          identifier: script.scriptId,\n        },\n        null\n      )\n\n      delete this.pinnedScripts_[script.handle]\n    }\n  }\n\n  /**\n   *\n   * @returns The value of authenticator ID added\n   */\n  virtualAuthenticatorId() {\n    return this.authenticatorId_\n  }\n\n  /**\n   * Adds a virtual authenticator with the given options.\n   * @param options VirtualAuthenticatorOptions object to set authenticator options.\n   */\n  async addVirtualAuthenticator(options) {\n    this.authenticatorId_ = await this.execute(\n      new command.Command(command.Name.ADD_VIRTUAL_AUTHENTICATOR).setParameters(\n        options.toDict()\n      )\n    )\n  }\n\n  /**\n   * Removes a previously added virtual authenticator. The authenticator is no\n   * longer valid after removal, so no methods may be called.\n   */\n  async removeVirtualAuthenticator() {\n    await this.execute(\n      new command.Command(\n        command.Name.REMOVE_VIRTUAL_AUTHENTICATOR\n      ).setParameter('authenticatorId', this.authenticatorId_)\n    )\n    this.authenticatorId_ = null\n  }\n\n  /**\n   * Injects a credential into the authenticator.\n   * @param credential Credential to be added\n   */\n  async addCredential(credential) {\n    credential = credential.toDict()\n    credential['authenticatorId'] = this.authenticatorId_\n    await this.execute(\n      new command.Command(command.Name.ADD_CREDENTIAL).setParameters(credential)\n    )\n  }\n\n  /**\n   *\n   * @returns The list of credentials owned by the authenticator.\n   */\n  async getCredentials() {\n    let credential_data = await this.execute(\n      new command.Command(command.Name.GET_CREDENTIALS).setParameter(\n        'authenticatorId',\n        this.virtualAuthenticatorId()\n      )\n    )\n    var credential_list = []\n    for (var i = 0; i < credential_data.length; i++) {\n      credential_list.push(new Credential().fromDict(credential_data[i]))\n    }\n    return credential_list\n  }\n\n  /**\n   * Removes a credential from the authenticator.\n   * @param credential_id The ID of the credential to be removed.\n   */\n  async removeCredential(credential_id) {\n    // If credential_id is not a base64url, then convert it to base64url.\n    if (Array.isArray(credential_id)) {\n      credential_id = Buffer.from(credential_id).toString('base64url')\n    }\n\n    await this.execute(\n      new command.Command(command.Name.REMOVE_CREDENTIAL)\n        .setParameter('credentialId', credential_id)\n        .setParameter('authenticatorId', this.authenticatorId_)\n    )\n  }\n\n  /**\n   * Removes all the credentials from the authenticator.\n   */\n  async removeAllCredentials() {\n    await this.execute(\n      new command.Command(command.Name.REMOVE_ALL_CREDENTIALS).setParameter(\n        'authenticatorId',\n        this.authenticatorId_\n      )\n    )\n  }\n\n  /**\n   * Sets whether the authenticator will simulate success or fail on user verification.\n   * @param verified true if the authenticator will pass user verification, false otherwise.\n   */\n  async setUserVerified(verified) {\n    await this.execute(\n      new command.Command(command.Name.SET_USER_VERIFIED)\n        .setParameter('authenticatorId', this.authenticatorId_)\n        .setParameter('isUserVerified', verified)\n    )\n  }\n}\n\n/**\n * Interface for navigating back and forth in the browser history.\n *\n * This class should never be instantiated directly. Instead, obtain an instance\n * with\n *\n *    webdriver.navigate()\n *\n * @see WebDriver#navigate()\n */\nclass Navigation {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver\n  }\n\n  /**\n   * Navigates to a new URL.\n   *\n   * @param {string} url The URL to navigate to.\n   * @return {!Promise<void>} A promise that will be resolved when the URL\n   *     has been loaded.\n   */\n  to(url) {\n    return this.driver_.execute(\n      new command.Command(command.Name.GET).setParameter('url', url)\n    )\n  }\n\n  /**\n   * Moves backwards in the browser history.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the\n   *     navigation event has completed.\n   */\n  back() {\n    return this.driver_.execute(new command.Command(command.Name.GO_BACK))\n  }\n\n  /**\n   * Moves forwards in the browser history.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the\n   *     navigation event has completed.\n   */\n  forward() {\n    return this.driver_.execute(new command.Command(command.Name.GO_FORWARD))\n  }\n\n  /**\n   * Refreshes the current page.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the\n   *     navigation event has completed.\n   */\n  refresh() {\n    return this.driver_.execute(new command.Command(command.Name.REFRESH))\n  }\n}\n\n/**\n * Provides methods for managing browser and driver state.\n *\n * This class should never be instantiated directly. Instead, obtain an instance\n * with {@linkplain WebDriver#manage() webdriver.manage()}.\n */\nclass Options {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver\n  }\n\n  /**\n   * Adds a cookie.\n   *\n   * __Sample Usage:__\n   *\n   *     // Set a basic cookie.\n   *     driver.manage().addCookie({name: 'foo', value: 'bar'});\n   *\n   *     // Set a cookie that expires in 10 minutes.\n   *     let expiry = new Date(Date.now() + (10 * 60 * 1000));\n   *     driver.manage().addCookie({name: 'foo', value: 'bar', expiry});\n   *\n   *     // The cookie expiration may also be specified in seconds since epoch.\n   *     driver.manage().addCookie({\n   *       name: 'foo',\n   *       value: 'bar',\n   *       expiry: Math.floor(Date.now() / 1000)\n   *     });\n   *\n   * @param {!Options.Cookie} spec Defines the cookie to add.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the cookie has been added to the page.\n   * @throws {error.InvalidArgumentError} if any of the cookie parameters are\n   *     invalid.\n   * @throws {TypeError} if `spec` is not a cookie object.\n   */\n  addCookie({ name, value, path, domain, secure, httpOnly, expiry, sameSite }) {\n    // We do not allow '=' or ';' in the name.\n    if (/[;=]/.test(name)) {\n      throw new error.InvalidArgumentError('Invalid cookie name \"' + name + '\"')\n    }\n\n    // We do not allow ';' in value.\n    if (/;/.test(value)) {\n      throw new error.InvalidArgumentError(\n        'Invalid cookie value \"' + value + '\"'\n      )\n    }\n\n    if (typeof expiry === 'number') {\n      expiry = Math.floor(expiry)\n    } else if (expiry instanceof Date) {\n      let date = /** @type {!Date} */ (expiry)\n      expiry = Math.floor(date.getTime() / 1000)\n    }\n\n    if (sameSite && !['Strict', 'Lax', 'None'].includes(sameSite)) {\n      throw new error.InvalidArgumentError(\n        `Invalid sameSite cookie value '${sameSite}'. It should be one of \"Lax\", \"Strict\" or \"None\"`\n      )\n    }\n\n    if (sameSite === 'None' && !secure) {\n      throw new error.InvalidArgumentError(\n        'Invalid cookie configuration: SameSite=None must be Secure'\n      )\n    }\n\n    return this.driver_.execute(\n      new command.Command(command.Name.ADD_COOKIE).setParameter('cookie', {\n        name: name,\n        value: value,\n        path: path,\n        domain: domain,\n        secure: !!secure,\n        httpOnly: !!httpOnly,\n        expiry: expiry,\n        sameSite: sameSite,\n      })\n    )\n  }\n\n  /**\n   * Deletes all cookies visible to the current page.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when all cookies have been deleted.\n   */\n  deleteAllCookies() {\n    return this.driver_.execute(\n      new command.Command(command.Name.DELETE_ALL_COOKIES)\n    )\n  }\n\n  /**\n   * Deletes the cookie with the given name. This command is a no-op if there is\n   * no cookie with the given name visible to the current page.\n   *\n   * @param {string} name The name of the cookie to delete.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the cookie has been deleted.\n   */\n  deleteCookie(name) {\n    return this.driver_.execute(\n      new command.Command(command.Name.DELETE_COOKIE).setParameter('name', name)\n    )\n  }\n\n  /**\n   * Retrieves all cookies visible to the current page. Each cookie will be\n   * returned as a JSON object as described by the WebDriver wire protocol.\n   *\n   * @return {!Promise<!Array<!Options.Cookie>>} A promise that will be\n   *     resolved with the cookies visible to the current browsing context.\n   */\n  getCookies() {\n    return this.driver_.execute(\n      new command.Command(command.Name.GET_ALL_COOKIES)\n    )\n  }\n\n  /**\n   * Retrieves the cookie with the given name. Returns null if there is no such\n   * cookie. The cookie will be returned as a JSON object as described by the\n   * WebDriver wire protocol.\n   *\n   * @param {string} name The name of the cookie to retrieve.\n   * @return {!Promise<?Options.Cookie>} A promise that will be resolved\n   *     with the named cookie\n   * @throws {error.NoSuchCookieError} if there is no such cookie.\n   */\n  async getCookie(name) {\n    try {\n      const cookie = await this.driver_.execute(\n        new command.Command(command.Name.GET_COOKIE).setParameter('name', name)\n      )\n      return cookie\n    } catch (err) {\n      if (\n        !(err instanceof error.UnknownCommandError) &&\n        !(err instanceof error.UnsupportedOperationError)\n      ) {\n        throw err\n      }\n\n      const cookies = await this.getCookies()\n      for (let cookie of cookies) {\n        if (cookie && cookie['name'] === name) {\n          return cookie\n        }\n      }\n      return null\n    }\n  }\n\n  /**\n   * Fetches the timeouts currently configured for the current session.\n   *\n   * @return {!Promise<{script: number,\n   *                             pageLoad: number,\n   *                             implicit: number}>} A promise that will be\n   *     resolved with the timeouts currently configured for the current\n   *     session.\n   * @see #setTimeouts()\n   */\n  getTimeouts() {\n    return this.driver_.execute(new command.Command(command.Name.GET_TIMEOUT))\n  }\n\n  /**\n   * Sets the timeout durations associated with the current session.\n   *\n   * The following timeouts are supported (all timeouts are specified in\n   * milliseconds):\n   *\n   * -  `implicit` specifies the maximum amount of time to wait for an element\n   *    locator to succeed when {@linkplain WebDriver#findElement locating}\n   *    {@linkplain WebDriver#findElements elements} on the page.\n   *    Defaults to 0 milliseconds.\n   *\n   * -  `pageLoad` specifies the maximum amount of time to wait for a page to\n   *    finishing loading. Defaults to 300000 milliseconds.\n   *\n   * -  `script` specifies the maximum amount of time to wait for an\n   *    {@linkplain WebDriver#executeScript evaluated script} to run. If set to\n   *    `null`, the script timeout will be indefinite.\n   *    Defaults to 30000 milliseconds.\n   *\n   * @param {{script: (number|null|undefined),\n   *          pageLoad: (number|null|undefined),\n   *          implicit: (number|null|undefined)}} conf\n   *     The desired timeout configuration.\n   * @return {!Promise<void>} A promise that will be resolved when the timeouts\n   *     have been set.\n   * @throws {!TypeError} if an invalid options object is provided.\n   * @see #getTimeouts()\n   * @see <https://w3c.github.io/webdriver/webdriver-spec.html#dfn-set-timeouts>\n   */\n  setTimeouts({ script, pageLoad, implicit } = {}) {\n    let cmd = new command.Command(command.Name.SET_TIMEOUT)\n\n    let valid = false\n    function setParam(key, value) {\n      if (value === null || typeof value === 'number') {\n        valid = true\n        cmd.setParameter(key, value)\n      } else if (typeof value !== 'undefined') {\n        throw TypeError(\n          'invalid timeouts configuration:' +\n            ` expected \"${key}\" to be a number, got ${typeof value}`\n        )\n      }\n    }\n    setParam('implicit', implicit)\n    setParam('pageLoad', pageLoad)\n    setParam('script', script)\n\n    if (valid) {\n      return this.driver_.execute(cmd).catch(() => {\n        // Fallback to the legacy method.\n        let cmds = []\n        if (typeof script === 'number') {\n          cmds.push(legacyTimeout(this.driver_, 'script', script))\n        }\n        if (typeof implicit === 'number') {\n          cmds.push(legacyTimeout(this.driver_, 'implicit', implicit))\n        }\n        if (typeof pageLoad === 'number') {\n          cmds.push(legacyTimeout(this.driver_, 'page load', pageLoad))\n        }\n        return Promise.all(cmds)\n      })\n    }\n    throw TypeError('no timeouts specified')\n  }\n\n  /**\n   * @return {!Logs} The interface for managing driver logs.\n   */\n  logs() {\n    return new Logs(this.driver_)\n  }\n\n  /**\n   * @return {!Window} The interface for managing the current window.\n   */\n  window() {\n    return new Window(this.driver_)\n  }\n}\n\n/**\n * @param {!WebDriver} driver\n * @param {string} type\n * @param {number} ms\n * @return {!Promise<void>}\n */\nfunction legacyTimeout(driver, type, ms) {\n  return driver.execute(\n    new command.Command(command.Name.SET_TIMEOUT)\n      .setParameter('type', type)\n      .setParameter('ms', ms)\n  )\n}\n\n/**\n * A record object describing a browser cookie.\n *\n * @record\n */\nOptions.Cookie = function () {}\n\n/**\n * The name of the cookie.\n *\n * @type {string}\n */\nOptions.Cookie.prototype.name\n\n/**\n * The cookie value.\n *\n * @type {string}\n */\nOptions.Cookie.prototype.value\n\n/**\n * The cookie path. Defaults to \"/\" when adding a cookie.\n *\n * @type {(string|undefined)}\n */\nOptions.Cookie.prototype.path\n\n/**\n * The domain the cookie is visible to. Defaults to the current browsing\n * context's document's URL when adding a cookie.\n *\n * @type {(string|undefined)}\n */\nOptions.Cookie.prototype.domain\n\n/**\n * Whether the cookie is a secure cookie. Defaults to false when adding a new\n * cookie.\n *\n * @type {(boolean|undefined)}\n */\nOptions.Cookie.prototype.secure\n\n/**\n * Whether the cookie is an HTTP only cookie. Defaults to false when adding a\n * new cookie.\n *\n * @type {(boolean|undefined)}\n */\nOptions.Cookie.prototype.httpOnly\n\n/**\n * When the cookie expires.\n *\n * When {@linkplain Options#addCookie() adding a cookie}, this may be specified\n * as a {@link Date} object, or in _seconds_ since Unix epoch (January 1, 1970).\n *\n * The expiry is always returned in seconds since epoch when\n * {@linkplain Options#getCookies() retrieving cookies} from the browser.\n *\n * @type {(!Date|number|undefined)}\n */\nOptions.Cookie.prototype.expiry\n\n/**\n * When the cookie applies to a SameSite policy.\n *\n * When {@linkplain Options#addCookie() adding a cookie}, this may be specified\n * as a {@link string} object which is one of 'Lax', 'Strict' or 'None'.\n *\n *\n * @type {(string|undefined)}\n */\nOptions.Cookie.prototype.sameSite\n\n/**\n * An interface for managing the current window.\n *\n * This class should never be instantiated directly. Instead, obtain an instance\n * with\n *\n *    webdriver.manage().window()\n *\n * @see WebDriver#manage()\n * @see Options#window()\n */\nclass Window {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver\n  }\n\n  /**\n   * Retrieves a rect describing the current top-level window's size and\n   * position.\n   *\n   * @return {!Promise<{x: number, y: number, width: number, height: number}>}\n   *     A promise that will resolve to the window rect of the current window.\n   */\n  getRect() {\n    return this.driver_.execute(\n      new command.Command(command.Name.GET_WINDOW_RECT)\n    )\n  }\n\n  /**\n   * Sets the current top-level window's size and position. You may update just\n   * the size by omitting `x` & `y`, or just the position by omitting\n   * `width` & `height` options.\n   *\n   * @param {{x: (number|undefined),\n   *          y: (number|undefined),\n   *          width: (number|undefined),\n   *          height: (number|undefined)}} options\n   *     The desired window size and position.\n   * @return {!Promise<{x: number, y: number, width: number, height: number}>}\n   *     A promise that will resolve to the current window's updated window\n   *     rect.\n   */\n  setRect({ x, y, width, height }) {\n    return this.driver_.execute(\n      new command.Command(command.Name.SET_WINDOW_RECT).setParameters({\n        x,\n        y,\n        width,\n        height,\n      })\n    )\n  }\n\n  /**\n   * Maximizes the current window. The exact behavior of this command is\n   * specific to individual window managers, but typically involves increasing\n   * the window to the maximum available size without going full-screen.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the command\n   *     has completed.\n   */\n  maximize() {\n    return this.driver_.execute(\n      new command.Command(command.Name.MAXIMIZE_WINDOW).setParameter(\n        'windowHandle',\n        'current'\n      )\n    )\n  }\n\n  /**\n   * Minimizes the current window. The exact behavior of this command is\n   * specific to individual window managers, but typically involves hiding\n   * the window in the system tray.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the command\n   *     has completed.\n   */\n  minimize() {\n    return this.driver_.execute(\n      new command.Command(command.Name.MINIMIZE_WINDOW)\n    )\n  }\n\n  /**\n   * Invokes the \"full screen\" operation on the current window. The exact\n   * behavior of this command is specific to individual window managers, but\n   * this will typically increase the window size to the size of the physical\n   * display and hide the browser chrome.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the command\n   *     has completed.\n   * @see <https://fullscreen.spec.whatwg.org/#fullscreen-an-element>\n   */\n  fullscreen() {\n    return this.driver_.execute(\n      new command.Command(command.Name.FULLSCREEN_WINDOW)\n    )\n  }\n\n  /**\n   * Gets the width and height of the current window\n   * @param windowHandle\n   * @returns {Promise<{width: *, height: *}>}\n   */\n  async getSize(windowHandle = 'current') {\n    if (windowHandle !== 'current') {\n      console.warn(\n        `Only 'current' window is supported for W3C compatible browsers.`\n      )\n    }\n\n    const rect = await this.getRect()\n    return { height: rect.height, width: rect.width }\n  }\n\n  /**\n   * Sets the width and height of the current window. (window.resizeTo)\n   * @param x\n   * @param y\n   * @param width\n   * @param height\n   * @param windowHandle\n   * @returns {Promise<void>}\n   */\n  async setSize(\n    { x = 0, y = 0, width = 0, height = 0 },\n    windowHandle = 'current'\n  ) {\n    if (windowHandle !== 'current') {\n      console.warn(\n        `Only 'current' window is supported for W3C compatible browsers.`\n      )\n    }\n\n    await this.setRect({ x, y, width, height })\n  }\n}\n\n/**\n * Interface for managing WebDriver log records.\n *\n * This class should never be instantiated directly. Instead, obtain an\n * instance with\n *\n *     webdriver.manage().logs()\n *\n * @see WebDriver#manage()\n * @see Options#logs()\n */\nclass Logs {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver\n  }\n\n  /**\n   * Fetches available log entries for the given type.\n   *\n   * Note that log buffers are reset after each call, meaning that available\n   * log entries correspond to those entries not yet returned for a given log\n   * type. In practice, this means that this call will return the available log\n   * entries since the last call, or from the start of the session.\n   *\n   * @param {!logging.Type} type The desired log type.\n   * @return {!Promise<!Array.<!logging.Entry>>} A\n   *   promise that will resolve to a list of log entries for the specified\n   *   type.\n   */\n  get(type) {\n    let cmd = new command.Command(command.Name.GET_LOG).setParameter(\n      'type',\n      type\n    )\n    return this.driver_.execute(cmd).then(function (entries) {\n      return entries.map(function (entry) {\n        if (!(entry instanceof logging.Entry)) {\n          return new logging.Entry(\n            entry['level'],\n            entry['message'],\n            entry['timestamp'],\n            entry['type']\n          )\n        }\n        return entry\n      })\n    })\n  }\n\n  /**\n   * Retrieves the log types available to this driver.\n   * @return {!Promise<!Array<!logging.Type>>} A\n   *     promise that will resolve to a list of available log types.\n   */\n  getAvailableLogTypes() {\n    return this.driver_.execute(\n      new command.Command(command.Name.GET_AVAILABLE_LOG_TYPES)\n    )\n  }\n}\n\n/**\n * An interface for changing the focus of the driver to another frame or window.\n *\n * This class should never be instantiated directly. Instead, obtain an\n * instance with\n *\n *     webdriver.switchTo()\n *\n * @see WebDriver#switchTo()\n */\nclass TargetLocator {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  constructor(driver) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver\n  }\n\n  /**\n   * Locates the DOM element on the current page that corresponds to\n   * `document.activeElement` or `document.body` if the active element is not\n   * available.\n   *\n   * @return {!WebElementPromise} The active element.\n   */\n  activeElement() {\n    const id = this.driver_.execute(\n      new command.Command(command.Name.GET_ACTIVE_ELEMENT)\n    )\n    return new WebElementPromise(this.driver_, id)\n  }\n\n  /**\n   * Switches focus of all future commands to the topmost frame in the current\n   * window.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the driver has changed focus to the default content.\n   */\n  defaultContent() {\n    return this.driver_.execute(\n      new command.Command(command.Name.SWITCH_TO_FRAME).setParameter('id', null)\n    )\n  }\n\n  /**\n   * Changes the focus of all future commands to another frame on the page. The\n   * target frame may be specified as one of the following:\n   *\n   * - A number that specifies a (zero-based) index into [window.frames](\n   *   https://developer.mozilla.org/en-US/docs/Web/API/Window.frames).\n   * - A {@link WebElement} reference, which correspond to a `frame` or `iframe`\n   *   DOM element.\n   * - The `null` value, to select the topmost frame on the page. Passing `null`\n   *   is the same as calling {@link #defaultContent defaultContent()}.\n   *\n   * If the specified frame can not be found, the returned promise will be\n   * rejected with a {@linkplain error.NoSuchFrameError}.\n   *\n   * @param {(number|string|WebElement|null)} id The frame locator.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the driver has changed focus to the specified frame.\n   */\n  frame(id) {\n    let frameReference = id\n    if (typeof id === 'string') {\n      frameReference = this.driver_\n        .findElement({ id })\n        .catch((_) => this.driver_.findElement({ name: id }))\n    }\n\n    return this.driver_.execute(\n      new command.Command(command.Name.SWITCH_TO_FRAME).setParameter(\n        'id',\n        frameReference\n      )\n    )\n  }\n\n  /**\n   * Changes the focus of all future commands to the parent frame of the\n   * currently selected frame. This command has no effect if the driver is\n   * already focused on the top-level browsing context.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the command\n   *     has completed.\n   */\n  parentFrame() {\n    return this.driver_.execute(\n      new command.Command(command.Name.SWITCH_TO_FRAME_PARENT)\n    )\n  }\n\n  /**\n   * Changes the focus of all future commands to another window. Windows may be\n   * specified by their {@code window.name} attribute or by its handle\n   * (as returned by {@link WebDriver#getWindowHandles}).\n   *\n   * If the specified window cannot be found, the returned promise will be\n   * rejected with a {@linkplain error.NoSuchWindowError}.\n   *\n   * @param {string} nameOrHandle The name or window handle of the window to\n   *     switch focus to.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the driver has changed focus to the specified window.\n   */\n  window(nameOrHandle) {\n    return this.driver_.execute(\n      new command.Command(command.Name.SWITCH_TO_WINDOW)\n        // \"name\" supports the legacy drivers. \"handle\" is the W3C\n        // compliant parameter.\n        .setParameter('name', nameOrHandle)\n        .setParameter('handle', nameOrHandle)\n    )\n  }\n\n  /**\n   * Creates a new browser window and switches the focus for future\n   * commands of this driver to the new window.\n   *\n   * @param {string} typeHint 'window' or 'tab'. The created window is not\n   *     guaranteed to be of the requested type; if the driver does not support\n   *     the requested type, a new browser window will be created of whatever type\n   *     the driver does support.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the driver has changed focus to the new window.\n   */\n  newWindow(typeHint) {\n    const driver = this.driver_\n    return this.driver_\n      .execute(\n        new command.Command(command.Name.SWITCH_TO_NEW_WINDOW).setParameter(\n          'type',\n          typeHint\n        )\n      )\n      .then(function (response) {\n        return driver.switchTo().window(response.handle)\n      })\n  }\n\n  /**\n   * Changes focus to the active modal dialog, such as those opened by\n   * `window.alert()`, `window.confirm()`, and `window.prompt()`. The returned\n   * promise will be rejected with a\n   * {@linkplain error.NoSuchAlertError} if there are no open alerts.\n   *\n   * @return {!AlertPromise} The open alert.\n   */\n  alert() {\n    const text = this.driver_.execute(\n      new command.Command(command.Name.GET_ALERT_TEXT)\n    )\n    const driver = this.driver_\n    return new AlertPromise(\n      driver,\n      text.then(function (text) {\n        return new Alert(driver, text)\n      })\n    )\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  WebElement\n//\n//////////////////////////////////////////////////////////////////////////////\n\nconst LEGACY_ELEMENT_ID_KEY = 'ELEMENT'\nconst ELEMENT_ID_KEY = 'element-6066-11e4-a52e-4f735466cecf'\nconst SHADOW_ROOT_ID_KEY = 'shadow-6066-11e4-a52e-4f735466cecf'\n\n/**\n * Represents a DOM element. WebElements can be found by searching from the\n * document root using a {@link WebDriver} instance, or by searching\n * under another WebElement:\n *\n *     driver.get('http://www.google.com');\n *     var searchForm = driver.findElement(By.tagName('form'));\n *     var searchBox = searchForm.findElement(By.name('q'));\n *     searchBox.sendKeys('webdriver');\n */\nclass WebElement {\n  /**\n   * @param {!WebDriver} driver the parent WebDriver instance for this element.\n   * @param {(!IThenable<string>|string)} id The server-assigned opaque ID for\n   *     the underlying DOM element.\n   */\n  constructor(driver, id) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver\n\n    /** @private {!Promise<string>} */\n    this.id_ = Promise.resolve(id)\n  }\n\n  /**\n   * @param {string} id The raw ID.\n   * @param {boolean=} noLegacy Whether to exclude the legacy element key.\n   * @return {!Object} The element ID for use with WebDriver's wire protocol.\n   */\n  static buildId(id, noLegacy = false) {\n    return noLegacy\n      ? { [ELEMENT_ID_KEY]: id }\n      : { [ELEMENT_ID_KEY]: id, [LEGACY_ELEMENT_ID_KEY]: id }\n  }\n\n  /**\n   * Extracts the encoded WebElement ID from the object.\n   *\n   * @param {?} obj The object to extract the ID from.\n   * @return {string} the extracted ID.\n   * @throws {TypeError} if the object is not a valid encoded ID.\n   */\n  static extractId(obj) {\n    return webElement.extractId(obj)\n  }\n\n  /**\n   * @param {?} obj the object to test.\n   * @return {boolean} whether the object is a valid encoded WebElement ID.\n   */\n  static isId(obj) {\n    return webElement.isId(obj)\n  }\n\n  /**\n   * Compares two WebElements for equality.\n   *\n   * @param {!WebElement} a A WebElement.\n   * @param {!WebElement} b A WebElement.\n   * @return {!Promise<boolean>} A promise that will be\n   *     resolved to whether the two WebElements are equal.\n   */\n  static async equals(a, b) {\n    if (a === b) {\n      return true\n    }\n    return a.driver_.executeScript('return arguments[0] === arguments[1]', a, b)\n  }\n\n  /** @return {!WebDriver} The parent driver for this instance. */\n  getDriver() {\n    return this.driver_\n  }\n\n  /**\n   * @return {!Promise<string>} A promise that resolves to\n   *     the server-assigned opaque ID assigned to this element.\n   */\n  getId() {\n    return this.id_\n  }\n\n  /**\n   * @return {!Object} Returns the serialized representation of this WebElement.\n   */\n  [Symbols.serialize]() {\n    return this.getId().then(WebElement.buildId)\n  }\n\n  /**\n   * Schedules a command that targets this element with the parent WebDriver\n   * instance. Will ensure this element's ID is included in the command\n   * parameters under the \"id\" key.\n   *\n   * @param {!command.Command} command The command to schedule.\n   * @return {!Promise<T>} A promise that will be resolved with the result.\n   * @template T\n   * @see WebDriver#schedule\n   * @private\n   */\n  execute_(command) {\n    command.setParameter('id', this)\n    return this.driver_.execute(command)\n  }\n\n  /**\n   * Schedule a command to find a descendant of this element. If the element\n   * cannot be found, the returned promise will be rejected with a\n   * {@linkplain error.NoSuchElementError NoSuchElementError}.\n   *\n   * The search criteria for an element may be defined using one of the static\n   * factories on the {@link by.By} class, or as a short-hand\n   * {@link ./by.ByHash} object. For example, the following two statements\n   * are equivalent:\n   *\n   *     var e1 = element.findElement(By.id('foo'));\n   *     var e2 = element.findElement({id:'foo'});\n   *\n   * You may also provide a custom locator function, which takes as input this\n   * instance and returns a {@link WebElement}, or a promise that will resolve\n   * to a WebElement. If the returned promise resolves to an array of\n   * WebElements, WebDriver will use the first element. For example, to find the\n   * first visible link on a page, you could write:\n   *\n   *     var link = element.findElement(firstVisibleLink);\n   *\n   *     function firstVisibleLink(element) {\n   *       var links = element.findElements(By.tagName('a'));\n   *       return promise.filter(links, function(link) {\n   *         return link.isDisplayed();\n   *       });\n   *     }\n   *\n   * @param {!(by.By|Function)} locator The locator strategy to use when\n   *     searching for the element.\n   * @return {!WebElementPromise} A WebElement that can be used to issue\n   *     commands against the located element. If the element is not found, the\n   *     element will be invalidated and all scheduled commands aborted.\n   */\n  findElement(locator) {\n    locator = by.checkedLocator(locator)\n    let id\n    if (typeof locator === 'function') {\n      id = this.driver_.findElementInternal_(locator, this)\n    } else {\n      let cmd = new command.Command(command.Name.FIND_CHILD_ELEMENT)\n        .setParameter('using', locator.using)\n        .setParameter('value', locator.value)\n      id = this.execute_(cmd)\n    }\n    return new WebElementPromise(this.driver_, id)\n  }\n\n  /**\n   * Locates all the descendants of this element that match the given search\n   * criteria.\n   *\n   * @param {!(by.By|Function)} locator The locator strategy to use when\n   *     searching for the element.\n   * @return {!Promise<!Array<!WebElement>>} A promise that will resolve to an\n   *     array of WebElements.\n   */\n  async findElements(locator) {\n    locator = by.checkedLocator(locator)\n    if (typeof locator === 'function') {\n      return this.driver_.findElementsInternal_(locator, this)\n    } else {\n      let cmd = new command.Command(command.Name.FIND_CHILD_ELEMENTS)\n        .setParameter('using', locator.using)\n        .setParameter('value', locator.value)\n      let result = await this.execute_(cmd)\n      return Array.isArray(result) ? result : []\n    }\n  }\n\n  /**\n   * Clicks on this element.\n   *\n   * @return {!Promise<void>} A promise that will be resolved when the click\n   *     command has completed.\n   */\n  click() {\n    return this.execute_(new command.Command(command.Name.CLICK_ELEMENT))\n  }\n\n  /**\n   * Types a key sequence on the DOM element represented by this instance.\n   *\n   * Modifier keys (SHIFT, CONTROL, ALT, META) are stateful; once a modifier is\n   * processed in the key sequence, that key state is toggled until one of the\n   * following occurs:\n   *\n   * - The modifier key is encountered again in the sequence. At this point the\n   *   state of the key is toggled (along with the appropriate keyup/down\n   *   events).\n   * - The {@link input.Key.NULL} key is encountered in the sequence. When\n   *   this key is encountered, all modifier keys current in the down state are\n   *   released (with accompanying keyup events). The NULL key can be used to\n   *   simulate common keyboard shortcuts:\n   *\n   *         element.sendKeys(\"text was\",\n   *                          Key.CONTROL, \"a\", Key.NULL,\n   *                          \"now text is\");\n   *         // Alternatively:\n   *         element.sendKeys(\"text was\",\n   *                          Key.chord(Key.CONTROL, \"a\"),\n   *                          \"now text is\");\n   *\n   * - The end of the key sequence is encountered. When there are no more keys\n   *   to type, all depressed modifier keys are released (with accompanying\n   *   keyup events).\n   *\n   * If this element is a file input ({@code <input type=\"file\">}), the\n   * specified key sequence should specify the path to the file to attach to\n   * the element. This is analogous to the user clicking \"Browse...\" and entering\n   * the path into the file select dialog.\n   *\n   *     var form = driver.findElement(By.css('form'));\n   *     var element = form.findElement(By.css('input[type=file]'));\n   *     element.sendKeys('/path/to/file.txt');\n   *     form.submit();\n   *\n   * For uploads to function correctly, the entered path must reference a file\n   * on the _browser's_ machine, not the local machine running this script. When\n   * running against a remote Selenium server, a {@link input.FileDetector}\n   * may be used to transparently copy files to the remote machine before\n   * attempting to upload them in the browser.\n   *\n   * __Note:__ On browsers where native keyboard events are not supported\n   * (e.g. Firefox on OS X), key events will be synthesized. Special\n   * punctuation keys will be synthesized according to a standard QWERTY en-us\n   * keyboard layout.\n   *\n   * @param {...(number|string|!IThenable<(number|string)>)} args The\n   *     sequence of keys to type. Number keys may be referenced numerically or\n   *     by string (1 or '1'). All arguments will be joined into a single\n   *     sequence.\n   * @return {!Promise<void>} A promise that will be resolved when all keys\n   *     have been typed.\n   */\n  async sendKeys(...args) {\n    let keys = []\n    ;(await Promise.all(args)).forEach((key) => {\n      let type = typeof key\n      if (type === 'number') {\n        key = String(key)\n      } else if (type !== 'string') {\n        throw TypeError('each key must be a number or string; got ' + type)\n      }\n\n      // The W3C protocol requires keys to be specified as an array where\n      // each element is a single key.\n      keys.push(...key)\n    })\n\n    if (!this.driver_.fileDetector_) {\n      return this.execute_(\n        new command.Command(command.Name.SEND_KEYS_TO_ELEMENT)\n          .setParameter('text', keys.join(''))\n          .setParameter('value', keys)\n      )\n    }\n\n    try {\n      keys = await this.driver_.fileDetector_.handleFile(\n        this.driver_,\n        keys.join('')\n      )\n    } catch (ex) {\n      console.log(\n        'Error trying parse string as a file with file detector; sending keys instead' +\n          ex\n      )\n    }\n\n    return this.execute_(\n      new command.Command(command.Name.SEND_KEYS_TO_ELEMENT)\n        .setParameter('text', keys)\n        .setParameter('value', keys.split(''))\n    )\n  }\n\n  /**\n   * Retrieves the element's tag name.\n   *\n   * @return {!Promise<string>} A promise that will be resolved with the\n   *     element's tag name.\n   */\n  getTagName() {\n    return this.execute_(new command.Command(command.Name.GET_ELEMENT_TAG_NAME))\n  }\n\n  /**\n   * Retrieves the value of a computed style property for this instance. If\n   * the element inherits the named style from its parent, the parent will be\n   * queried for its value.  Where possible, color values will be converted to\n   * their hex representation (e.g. #00ff00 instead of rgb(0, 255, 0)).\n   *\n   * _Warning:_ the value returned will be as the browser interprets it, so\n   * it may be tricky to form a proper assertion.\n   *\n   * @param {string} cssStyleProperty The name of the CSS style property to look\n   *     up.\n   * @return {!Promise<string>} A promise that will be resolved with the\n   *     requested CSS value.\n   */\n  getCssValue(cssStyleProperty) {\n    const name = command.Name.GET_ELEMENT_VALUE_OF_CSS_PROPERTY\n    return this.execute_(\n      new command.Command(name).setParameter('propertyName', cssStyleProperty)\n    )\n  }\n\n  /**\n   * Retrieves the current value of the given attribute of this element.\n   * Will return the current value, even if it has been modified after the page\n   * has been loaded. More exactly, this method will return the value\n   * of the given attribute, unless that attribute is not present, in which case\n   * the value of the property with the same name is returned. If neither value\n   * is set, null is returned (for example, the \"value\" property of a textarea\n   * element). The \"style\" attribute is converted as best can be to a\n   * text representation with a trailing semicolon. The following are deemed to\n   * be \"boolean\" attributes and will return either \"true\" or null:\n   *\n   * async, autofocus, autoplay, checked, compact, complete, controls, declare,\n   * defaultchecked, defaultselected, defer, disabled, draggable, ended,\n   * formnovalidate, hidden, indeterminate, iscontenteditable, ismap, itemscope,\n   * loop, multiple, muted, nohref, noresize, noshade, novalidate, nowrap, open,\n   * paused, pubdate, readonly, required, reversed, scoped, seamless, seeking,\n   * selected, spellcheck, truespeed, willvalidate\n   *\n   * Finally, the following commonly mis-capitalized attribute/property names\n   * are evaluated as expected:\n   *\n   * - \"class\"\n   * - \"readonly\"\n   *\n   * @param {string} attributeName The name of the attribute to query.\n   * @return {!Promise<?string>} A promise that will be\n   *     resolved with the attribute's value. The returned value will always be\n   *     either a string or null.\n   */\n  getAttribute(attributeName) {\n    return this.execute_(\n      new command.Command(command.Name.GET_ELEMENT_ATTRIBUTE).setParameter(\n        'name',\n        attributeName\n      )\n    )\n  }\n\n  /**\n   * Get the value of the given attribute of the element.\n   * <p>\n   * This method, unlike {@link #getAttribute(String)}, returns the value of the attribute with the\n   * given name but not the property with the same name.\n   * <p>\n   * The following are deemed to be \"boolean\" attributes, and will return either \"true\" or null:\n   * <p>\n   * async, autofocus, autoplay, checked, compact, complete, controls, declare, defaultchecked,\n   * defaultselected, defer, disabled, draggable, ended, formnovalidate, hidden, indeterminate,\n   * iscontenteditable, ismap, itemscope, loop, multiple, muted, nohref, noresize, noshade,\n   * novalidate, nowrap, open, paused, pubdate, readonly, required, reversed, scoped, seamless,\n   * seeking, selected, truespeed, willvalidate\n   * <p>\n   * See <a href=\"https://w3c.github.io/webdriver/#get-element-attribute\">W3C WebDriver specification</a>\n   * for more details.\n   *\n   * @param attributeName The name of the attribute.\n   * @return The attribute's value or null if the value is not set.\n   */\n\n  getDomAttribute(attributeName) {\n    return this.execute_(\n      new command.Command(command.Name.GET_DOM_ATTRIBUTE).setParameter(\n        'name',\n        attributeName\n      )\n    )\n  }\n\n  /**\n   * Get the given property of the referenced web element\n   * @param {string} propertyName The name of the attribute to query.\n   * @return {!Promise<string>} A promise that will be\n   *     resolved with the element's property value\n   */\n  getProperty(propertyName) {\n    return this.execute_(\n      new command.Command(command.Name.GET_ELEMENT_PROPERTY).setParameter(\n        'name',\n        propertyName\n      )\n    )\n  }\n\n  /**\n   * Get the shadow root of the current web element.\n   * @returns {!Promise<ShadowRoot>} A promise that will be\n   *      resolved with the elements shadow root or rejected\n   *      with {@link NoSuchShadowRootError}\n   */\n  getShadowRoot() {\n    return this.execute_(new command.Command(command.Name.GET_SHADOW_ROOT))\n  }\n\n  /**\n   * Get the visible (i.e. not hidden by CSS) innerText of this element,\n   * including sub-elements, without any leading or trailing whitespace.\n   *\n   * @return {!Promise<string>} A promise that will be\n   *     resolved with the element's visible text.\n   */\n  getText() {\n    return this.execute_(new command.Command(command.Name.GET_ELEMENT_TEXT))\n  }\n\n  /**\n   * Get the computed WAI-ARIA role of element.\n   *\n   * @return {!Promise<string>} A promise that will be\n   *     resolved with the element's computed role.\n   */\n  getAriaRole() {\n    return this.execute_(new command.Command(command.Name.GET_COMPUTED_ROLE))\n  }\n\n  /**\n   * Get the computed WAI-ARIA label of element.\n   *\n   * @return {!Promise<string>} A promise that will be\n   *     resolved with the element's computed label.\n   */\n  getAccessibleName() {\n    return this.execute_(new command.Command(command.Name.GET_COMPUTED_LABEL))\n  }\n  /**\n   * Returns an object describing an element's location, in pixels relative to\n   * the document element, and the element's size in pixels.\n   *\n   * @return {!Promise<{width: number, height: number, x: number, y: number}>}\n   *     A promise that will resolve with the element's rect.\n   */\n  getRect() {\n    return this.execute_(new command.Command(command.Name.GET_ELEMENT_RECT))\n  }\n\n  /**\n   * Tests whether this element is enabled, as dictated by the `disabled`\n   * attribute.\n   *\n   * @return {!Promise<boolean>} A promise that will be\n   *     resolved with whether this element is currently enabled.\n   */\n  isEnabled() {\n    return this.execute_(new command.Command(command.Name.IS_ELEMENT_ENABLED))\n  }\n\n  /**\n   * Tests whether this element is selected.\n   *\n   * @return {!Promise<boolean>} A promise that will be\n   *     resolved with whether this element is currently selected.\n   */\n  isSelected() {\n    return this.execute_(new command.Command(command.Name.IS_ELEMENT_SELECTED))\n  }\n\n  /**\n   * Submits the form containing this element (or this element if it is itself\n   * a FORM element). his command is a no-op if the element is not contained in\n   * a form.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the form has been submitted.\n   */\n  submit() {\n    const script =\n      '/* submitForm */var form = arguments[0];\\n' +\n      'while (form.nodeName != \"FORM\" && form.parentNode) {\\n' +\n      '  form = form.parentNode;\\n' +\n      '}\\n' +\n      \"if (!form) { throw Error('Unable to find containing form element'); }\\n\" +\n      \"if (!form.ownerDocument) { throw Error('Unable to find owning document'); }\\n\" +\n      \"var e = form.ownerDocument.createEvent('Event');\\n\" +\n      \"e.initEvent('submit', true, true);\\n\" +\n      'if (form.dispatchEvent(e)) { HTMLFormElement.prototype.submit.call(form) }\\n'\n\n    return this.driver_.executeScript(script, this)\n  }\n\n  /**\n   * Clear the `value` of this element. This command has no effect if the\n   * underlying DOM element is neither a text INPUT element nor a TEXTAREA\n   * element.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when the element has been cleared.\n   */\n  clear() {\n    return this.execute_(new command.Command(command.Name.CLEAR_ELEMENT))\n  }\n\n  /**\n   * Test whether this element is currently displayed.\n   *\n   * @return {!Promise<boolean>} A promise that will be\n   *     resolved with whether this element is currently visible on the page.\n   */\n  isDisplayed() {\n    return this.execute_(new command.Command(command.Name.IS_ELEMENT_DISPLAYED))\n  }\n\n  /**\n   * Take a screenshot of the visible region encompassed by this element's\n   * bounding rectangle.\n   *\n   * @return {!Promise<string>} A promise that will be\n   *     resolved to the screenshot as a base-64 encoded PNG.\n   */\n  takeScreenshot() {\n    return this.execute_(\n      new command.Command(command.Name.TAKE_ELEMENT_SCREENSHOT)\n    )\n  }\n}\n\n/**\n * WebElementPromise is a promise that will be fulfilled with a WebElement.\n * This serves as a forward proxy on WebElement, allowing calls to be\n * scheduled without directly on this instance before the underlying\n * WebElement has been fulfilled. In other words, the following two statements\n * are equivalent:\n *\n *     driver.findElement({id: 'my-button'}).click();\n *     driver.findElement({id: 'my-button'}).then(function(el) {\n *       return el.click();\n *     });\n *\n * @implements {IThenable<!WebElement>}\n * @final\n */\nclass WebElementPromise extends WebElement {\n  /**\n   * @param {!WebDriver} driver The parent WebDriver instance for this\n   *     element.\n   * @param {!Promise<!WebElement>} el A promise\n   *     that will resolve to the promised element.\n   */\n  constructor(driver, el) {\n    super(driver, 'unused')\n\n    /** @override */\n    this.then = el.then.bind(el)\n\n    /** @override */\n    this.catch = el.catch.bind(el)\n\n    /**\n     * Defers returning the element ID until the wrapped WebElement has been\n     * resolved.\n     * @override\n     */\n    this.getId = function () {\n      return el.then(function (el) {\n        return el.getId()\n      })\n    }\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  ShadowRoot\n//\n//////////////////////////////////////////////////////////////////////////////\n\n/**\n * Represents a ShadowRoot of a {@link WebElement}. Provides functions to\n * retrieve elements that live in the DOM below the ShadowRoot.\n */\nclass ShadowRoot {\n  constructor(driver, id) {\n    this.driver_ = driver\n    this.id_ = id\n  }\n\n  /**\n   * Extracts the encoded ShadowRoot ID from the object.\n   *\n   * @param {?} obj The object to extract the ID from.\n   * @return {string} the extracted ID.\n   * @throws {TypeError} if the object is not a valid encoded ID.\n   */\n  static extractId(obj) {\n    if (obj && typeof obj === 'object') {\n      if (typeof obj[SHADOW_ROOT_ID_KEY] === 'string') {\n        return obj[SHADOW_ROOT_ID_KEY]\n      }\n    }\n    throw new TypeError('object is not a ShadowRoot ID')\n  }\n\n  /**\n   * @param {?} obj the object to test.\n   * @return {boolean} whether the object is a valid encoded WebElement ID.\n   */\n  static isId(obj) {\n    return (\n      obj &&\n      typeof obj === 'object' &&\n      typeof obj[SHADOW_ROOT_ID_KEY] === 'string'\n    )\n  }\n\n  /**\n   * @return {!Object} Returns the serialized representation of this ShadowRoot.\n   */\n  [Symbols.serialize]() {\n    return this.getId()\n  }\n\n  /**\n   * Schedules a command that targets this element with the parent WebDriver\n   * instance. Will ensure this element's ID is included in the command\n   * parameters under the \"id\" key.\n   *\n   * @param {!command.Command} command The command to schedule.\n   * @return {!Promise<T>} A promise that will be resolved with the result.\n   * @template T\n   * @see WebDriver#schedule\n   * @private\n   */\n  execute_(command) {\n    command.setParameter('id', this)\n    return this.driver_.execute(command)\n  }\n\n  /**\n   * Schedule a command to find a descendant of this ShadowROot. If the element\n   * cannot be found, the returned promise will be rejected with a\n   * {@linkplain error.NoSuchElementError NoSuchElementError}.\n   *\n   * The search criteria for an element may be defined using one of the static\n   * factories on the {@link by.By} class, or as a short-hand\n   * {@link ./by.ByHash} object. For example, the following two statements\n   * are equivalent:\n   *\n   *     var e1 = shadowroot.findElement(By.id('foo'));\n   *     var e2 = shadowroot.findElement({id:'foo'});\n   *\n   * You may also provide a custom locator function, which takes as input this\n   * instance and returns a {@link WebElement}, or a promise that will resolve\n   * to a WebElement. If the returned promise resolves to an array of\n   * WebElements, WebDriver will use the first element. For example, to find the\n   * first visible link on a page, you could write:\n   *\n   *     var link = element.findElement(firstVisibleLink);\n   *\n   *     function firstVisibleLink(shadowRoot) {\n   *       var links = shadowRoot.findElements(By.tagName('a'));\n   *       return promise.filter(links, function(link) {\n   *         return link.isDisplayed();\n   *       });\n   *     }\n   *\n   * @param {!(by.By|Function)} locator The locator strategy to use when\n   *     searching for the element.\n   * @return {!WebElementPromise} A WebElement that can be used to issue\n   *     commands against the located element. If the element is not found, the\n   *     element will be invalidated and all scheduled commands aborted.\n   */\n  findElement(locator) {\n    locator = by.checkedLocator(locator)\n    let id\n    if (typeof locator === 'function') {\n      id = this.driver_.findElementInternal_(locator, this)\n    } else {\n      let cmd = new command.Command(command.Name.FIND_ELEMENT_FROM_SHADOWROOT)\n        .setParameter('using', locator.using)\n        .setParameter('value', locator.value)\n      id = this.execute_(cmd)\n    }\n    return new ShadowRootPromise(this.driver_, id)\n  }\n\n  /**\n   * Locates all the descendants of this element that match the given search\n   * criteria.\n   *\n   * @param {!(by.By|Function)} locator The locator strategy to use when\n   *     searching for the element.\n   * @return {!Promise<!Array<!WebElement>>} A promise that will resolve to an\n   *     array of WebElements.\n   */\n  async findElements(locator) {\n    locator = by.checkedLocator(locator)\n    if (typeof locator === 'function') {\n      return this.driver_.findElementsInternal_(locator, this)\n    } else {\n      let cmd = new command.Command(command.Name.FIND_ELEMENTS_FROM_SHADOWROOT)\n        .setParameter('using', locator.using)\n        .setParameter('value', locator.value)\n      let result = await this.execute_(cmd)\n      return Array.isArray(result) ? result : []\n    }\n  }\n\n  getId() {\n    return this.id_\n  }\n}\n\n/**\n * ShadowRootPromise is a promise that will be fulfilled with a WebElement.\n * This serves as a forward proxy on ShadowRoot, allowing calls to be\n * scheduled without directly on this instance before the underlying\n * ShadowRoot has been fulfilled.\n *\n * @implements { IThenable<!ShadowRoot>}\n * @final\n */\nclass ShadowRootPromise extends ShadowRoot {\n  /**\n   * @param {!WebDriver} driver The parent WebDriver instance for this\n   *     element.\n   * @param {!Promise<!ShadowRoot>} shadow A promise\n   *     that will resolve to the promised element.\n   */\n  constructor(driver, shadow) {\n    super(driver, 'unused')\n\n    /** @override */\n    this.then = shadow.then.bind(shadow)\n\n    /** @override */\n    this.catch = shadow.catch.bind(shadow)\n\n    /**\n     * Defers returning the ShadowRoot ID until the wrapped WebElement has been\n     * resolved.\n     * @override\n     */\n    this.getId = function () {\n      return shadow.then(function (shadow) {\n        return shadow.getId()\n      })\n    }\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  Alert\n//\n//////////////////////////////////////////////////////////////////////////////\n\n/**\n * Represents a modal dialog such as {@code alert}, {@code confirm}, or\n * {@code prompt}. Provides functions to retrieve the message displayed with\n * the alert, accept or dismiss the alert, and set the response text (in the\n * case of {@code prompt}).\n */\nclass Alert {\n  /**\n   * @param {!WebDriver} driver The driver controlling the browser this alert\n   *     is attached to.\n   * @param {string} text The message text displayed with this alert.\n   */\n  constructor(driver, text) {\n    /** @private {!WebDriver} */\n    this.driver_ = driver\n\n    /** @private {!Promise<string>} */\n    this.text_ = Promise.resolve(text)\n  }\n\n  /**\n   * Retrieves the message text displayed with this alert. For instance, if the\n   * alert were opened with alert(\"hello\"), then this would return \"hello\".\n   *\n   * @return {!Promise<string>} A promise that will be\n   *     resolved to the text displayed with this alert.\n   */\n  getText() {\n    return this.text_\n  }\n\n  /**\n   * Accepts this alert.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when this command has completed.\n   */\n  accept() {\n    return this.driver_.execute(new command.Command(command.Name.ACCEPT_ALERT))\n  }\n\n  /**\n   * Dismisses this alert.\n   *\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when this command has completed.\n   */\n  dismiss() {\n    return this.driver_.execute(new command.Command(command.Name.DISMISS_ALERT))\n  }\n\n  /**\n   * Sets the response text on this alert. This command will return an error if\n   * the underlying alert does not support response text (e.g. window.alert and\n   * window.confirm).\n   *\n   * @param {string} text The text to set.\n   * @return {!Promise<void>} A promise that will be resolved\n   *     when this command has completed.\n   */\n  sendKeys(text) {\n    return this.driver_.execute(\n      new command.Command(command.Name.SET_ALERT_TEXT).setParameter(\n        'text',\n        text\n      )\n    )\n  }\n}\n\n/**\n * AlertPromise is a promise that will be fulfilled with an Alert. This promise\n * serves as a forward proxy on an Alert, allowing calls to be scheduled\n * directly on this instance before the underlying Alert has been fulfilled. In\n * other words, the following two statements are equivalent:\n *\n *     driver.switchTo().alert().dismiss();\n *     driver.switchTo().alert().then(function(alert) {\n *       return alert.dismiss();\n *     });\n *\n * @implements {IThenable<!Alert>}\n * @final\n */\nclass AlertPromise extends Alert {\n  /**\n   * @param {!WebDriver} driver The driver controlling the browser this\n   *     alert is attached to.\n   * @param {!Promise<!Alert>} alert A thenable\n   *     that will be fulfilled with the promised alert.\n   */\n  constructor(driver, alert) {\n    super(driver, 'unused')\n\n    /** @override */\n    this.then = alert.then.bind(alert)\n\n    /** @override */\n    this.catch = alert.catch.bind(alert)\n\n    /**\n     * Defer returning text until the promised alert has been resolved.\n     * @override\n     */\n    this.getText = function () {\n      return alert.then(function (alert) {\n        return alert.getText()\n      })\n    }\n\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n    this.accept = function () {\n      return alert.then(function (alert) {\n        return alert.accept()\n      })\n    }\n\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n    this.dismiss = function () {\n      return alert.then(function (alert) {\n        return alert.dismiss()\n      })\n    }\n\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n    this.sendKeys = function (text) {\n      return alert.then(function (alert) {\n        return alert.sendKeys(text)\n      })\n    }\n  }\n}\n\n// PUBLIC API\n\nmodule.exports = {\n  Alert,\n  AlertPromise,\n  Condition,\n  Logs,\n  Navigation,\n  Options,\n  ShadowRoot,\n  TargetLocator,\n  IWebDriver,\n  WebDriver,\n  WebElement,\n  WebElementCondition,\n  WebElementPromise,\n  Window,\n}\n"],"mappings":"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,GAAGA,OAAQ,IAAG,GAC1D,EAAE;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM6C,UAAU,CAAC;EACf;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEjC,OAAOA,CAACnC,OAAO,EAAE,CAAC,CAAC,CAAC;;EAEpB;AACF;AACA;AACA;AACA;EACEqE,eAAeA,CAACC,QAAQ,EAAE,CAAC,CAAC,CAAC;;EAE7B;AACF;AACA;EACEC,WAAWA,CAAA,EAAG,CAAC;;EAEf;AACF;AACA;EACEC,UAAUA,CAAA,EAAG,CAAC;;EAEd;AACF;AACA;AACA;EACEC,eAAeA,CAAA,EAAG,CAAC;;EAEnB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,IAAIA,CAAA,EAAG,CAAC;;EAER;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,OAAOA,CAACC,OAAO,EAAE,CAAC,CAAC,CAAC;;EAEpB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,aAAaA,CAACC,MAAM,EAAW,CAAC,CAAC,CAAC;;EAElC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,kBAAkBA,CAACD,MAAM,EAAW,CAAC,CAAC,CAAC;;EAEvC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEE,IAAIA,CACFC,SAAS,EAIT;IAAA,IAHAC,OAAO,GAAAC,SAAA,CAAArC,MAAA,QAAAqC,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAGC,SAAS;IAAA,IACnB7D,OAAO,GAAA4D,SAAA,CAAArC,MAAA,QAAAqC,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAGC,SAAS;IAAA,IACnBC,WAAW,GAAAF,SAAA,CAAArC,MAAA,QAAAqC,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAGC,SAAS;EACtB;;EAEH;AACF;AACA;AACA;AACA;AACA;AACA;EACEE,KAAKA,CAACC,EAAE,EAAE,CAAC,CAAC,CAAC;;EAEb;AACF;AACA;AACA;AACA;AACA;EACEC,eAAeA,CAAA,EAAG,CAAC;;EAEnB;AACF;AACA;AACA;AACA;AACA;EACEC,mBAAmBA,CAAA,EAAG,CAAC;;EAEvB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,aAAaA,CAAA,EAAG,CAAC;;EAEjB;AACF;AACA;AACA;AACA;AACA;EACEC,KAAKA,CAAA,EAAG,CAAC;;EAET;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,GAAGA,CAACC,GAAG,EAAE,CAAC,CAAC,CAAC;;EAEZ;AACF;AACA;AACA;AACA;AACA;EACEC,aAAaA,CAAA,EAAG,CAAC;;EAEjB;AACF;AACA;AACA;AACA;AACA;EACEC,QAAQA,CAAA,EAAG,CAAC;;EAEZ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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M,MAAM,GAAG,YAAY,CAAC,CAAC;;AAE/B;AACA;AACA;AACA;AACA;AACAvM,OAAO,CAACuM,MAAM,CAACjU,SAAS,CAAC+N,IAAI;;AAE7B;AACA;AACA;AACA;AACA;AACArG,OAAO,CAACuM,MAAM,CAACjU,SAAS,CAAC3B,KAAK;;AAE9B;AACA;AACA;AACA;AACA;AACAqJ,OAAO,CAACuM,MAAM,CAACjU,SAAS,CAACrD,IAAI;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA+K,OAAO,CAACuM,MAAM,CAACjU,SAAS,CAAC0R,MAAM;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACAhK,OAAO,CAACuM,MAAM,CAACjU,SAAS,CAAC2R,MAAM;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACAjK,OAAO,CAACuM,MAAM,CAACjU,SAAS,CAAC4R,QAAQ;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAlK,OAAO,CAACuM,MAAM,CAACjU,SAAS,CAAC6R,MAAM;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAnK,OAAO,CAACuM,MAAM,CAACjU,SAAS,CAAC8R,QAAQ;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMkC,MAAM,CAAC;EACX;AACF;AACA;AACA;EACE1W,WAAWA,CAACiC,MAAM,EAAE;IAClB;IACA,IAAI,CAACyR,OAAO,GAAGzR,MAAM;EACvB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE2U,OAAOA,CAAA,EAAG;IACR,OAAO,IAAI,CAAClD,OAAO,CAAC7S,OAAO,CACzB,IAAInC,OAAO,CAAC2H,OAAO,CAAC3H,OAAO,CAAC4H,IAAI,CAACuQ,eAAe,CAClD,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,OAAOA,CAAAC,KAAA,EAA0B;IAAA,IAAzB;MAAEC,CAAC;MAAEC,CAAC;MAAEjM,KAAK;MAAEC;IA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"},"metadata":{},"sourceType":"script","externalDependencies":[]}