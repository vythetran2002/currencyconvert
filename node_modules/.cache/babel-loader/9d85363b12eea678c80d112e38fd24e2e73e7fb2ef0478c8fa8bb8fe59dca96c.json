{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines a handful of utility functions to simplify working\n * with promises.\n */\n\n'use strict';\n\nconst {\n  isObject,\n  isPromise\n} = require('./util');\n\n/**\n * Creates a promise that will be resolved at a set time in the future.\n * @param {number} ms The amount of time, in milliseconds, to wait before\n *     resolving the promise.\n * @return {!Promise<void>} The promise.\n */\nfunction delayed(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Wraps a function that expects a node-style callback as its final\n * argument. This callback expects two arguments: an error value (which will be\n * null if the call succeeded), and the success value as the second argument.\n * The callback will the resolve or reject the returned promise, based on its\n * arguments.\n * @param {!Function} fn The function to wrap.\n * @param {...?} args The arguments to apply to the function, excluding the\n *     final callback.\n * @return {!Thenable} A promise that will be resolved with the\n *     result of the provided function's callback.\n */\nfunction checkedNodeCall(fn) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  return new Promise(function (fulfill, reject) {\n    try {\n      fn(...args, function (error, value) {\n        error ? reject(error) : fulfill(value);\n      });\n    } catch (ex) {\n      reject(ex);\n    }\n  });\n}\n\n/**\n * Registers a listener to invoke when a promise is resolved, regardless\n * of whether the promise's value was successfully computed. This function\n * is synonymous with the {@code finally} clause in a synchronous API:\n *\n *     // Synchronous API:\n *     try {\n *       doSynchronousWork();\n *     } finally {\n *       cleanUp();\n *     }\n *\n *     // Asynchronous promise API:\n *     doAsynchronousWork().finally(cleanUp);\n *\n * __Note:__ similar to the {@code finally} clause, if the registered\n * callback returns a rejected promise or throws an error, it will silently\n * replace the rejection error (if any) from this promise:\n *\n *     try {\n *       throw Error('one');\n *     } finally {\n *       throw Error('two');  // Hides Error: one\n *     }\n *\n *     let p = Promise.reject(Error('one'));\n *     promise.finally(p, function() {\n *       throw Error('two');  // Hides Error: one\n *     });\n *\n * @param {!IThenable<?>} promise The promise to add the listener to.\n * @param {function(): (R|IThenable<R>)} callback The function to call when\n *     the promise is resolved.\n * @return {!Promise<R>} A promise that will be resolved with the callback\n *     result.\n * @template R\n */\nasync function thenFinally(promise, callback) {\n  try {\n    await Promise.resolve(promise);\n    return callback();\n  } catch (e) {\n    await callback();\n    throw e;\n  }\n}\n\n/**\n * Calls a function for each element in an array and inserts the result into a\n * new array, which is used as the fulfillment value of the promise returned\n * by this function.\n *\n * If the return value of the mapping function is a promise, this function\n * will wait for it to be fulfilled before inserting it into the new array.\n *\n * If the mapping function throws or returns a rejected promise, the\n * promise returned by this function will be rejected with the same reason.\n * Only the first failure will be reported; all subsequent errors will be\n * silently ignored.\n *\n * @param {!(Array<TYPE>|IThenable<!Array<TYPE>>)} array The array to iterate\n *     over, or a promise that will resolve to said array.\n * @param {function(this: SELF, TYPE, number, !Array<TYPE>): ?} fn The\n *     function to call for each element in the array. This function should\n *     expect three arguments (the element, the index, and the array itself.\n * @param {SELF=} self The object to be used as the value of 'this' within `fn`.\n * @template TYPE, SELF\n */\nasync function map(array, fn) {\n  let self = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  const v = await Promise.resolve(array);\n  if (!Array.isArray(v)) {\n    throw TypeError('not an array');\n  }\n  const arr = /** @type {!Array} */v;\n  const values = [];\n  for (const [index, item] of arr.entries()) {\n    values.push(await Promise.resolve(fn.call(self, item, index, arr)));\n  }\n  return values;\n}\n\n/**\n * Calls a function for each element in an array, and if the function returns\n * true adds the element to a new array.\n *\n * If the return value of the filter function is a promise, this function\n * will wait for it to be fulfilled before determining whether to insert the\n * element into the new array.\n *\n * If the filter function throws or returns a rejected promise, the promise\n * returned by this function will be rejected with the same reason. Only the\n * first failure will be reported; all subsequent errors will be silently\n * ignored.\n *\n * @param {!(Array<TYPE>|IThenable<!Array<TYPE>>)} array The array to iterate\n *     over, or a promise that will resolve to said array.\n * @param {function(this: SELF, TYPE, number, !Array<TYPE>): (\n *             boolean|IThenable<boolean>)} fn The function\n *     to call for each element in the array.\n * @param {SELF=} self The object to be used as the value of 'this' within `fn`.\n * @template TYPE, SELF\n */\nasync function filter(array, fn) {\n  let self = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  const v = await Promise.resolve(array);\n  if (!Array.isArray(v)) {\n    throw TypeError('not an array');\n  }\n  const arr = /** @type {!Array} */v;\n  const values = [];\n  for (const [index, item] of arr.entries()) {\n    const isConditionTrue = await Promise.resolve(fn.call(self, item, index, arr));\n    if (isConditionTrue) {\n      values.push(item);\n    }\n  }\n  return values;\n}\n\n/**\n * Returns a promise that will be resolved with the input value in a\n * fully-resolved state. If the value is an array, each element will be fully\n * resolved. Likewise, if the value is an object, all keys will be fully\n * resolved. In both cases, all nested arrays and objects will also be\n * fully resolved.  All fields are resolved in place; the returned promise will\n * resolve on {@code value} and not a copy.\n *\n * Warning: This function makes no checks against objects that contain\n * cyclical references:\n *\n *     var value = {};\n *     value['self'] = value;\n *     promise.fullyResolved(value);  // Stack overflow.\n *\n * @param {*} value The value to fully resolve.\n * @return {!Thenable} A promise for a fully resolved version\n *     of the input value.\n */\nasync function fullyResolved(value) {\n  value = await Promise.resolve(value);\n  if (Array.isArray(value)) {\n    return fullyResolveKeys( /** @type {!Array} */value);\n  }\n  if (isObject(value)) {\n    return fullyResolveKeys( /** @type {!Object} */value);\n  }\n  if (typeof value === 'function') {\n    return fullyResolveKeys( /** @type {!Object} */value);\n  }\n  return value;\n}\n\n/**\n * @param {!(Array|Object)} obj the object to resolve.\n * @return {!Thenable} A promise that will be resolved with the\n *     input object once all of its values have been fully resolved.\n */\nasync function fullyResolveKeys(obj) {\n  const isArray = Array.isArray(obj);\n  const numKeys = isArray ? obj.length : Object.keys(obj).length;\n  if (!numKeys) {\n    return obj;\n  }\n  async function forEachProperty(obj, fn) {\n    for (let key in obj) {\n      await fn(obj[key], key);\n    }\n  }\n  async function forEachElement(arr, fn) {\n    for (let i = 0; i < arr.length; i++) {\n      await fn(arr[i], i);\n    }\n  }\n  const forEachKey = isArray ? forEachElement : forEachProperty;\n  await forEachKey(obj, async function (partialValue, key) {\n    if (!Array.isArray(partialValue) && (!partialValue || typeof partialValue !== 'object')) {\n      return;\n    }\n    obj[key] = await fullyResolved(partialValue);\n  });\n  return obj;\n}\n\n// PUBLIC API\n\nmodule.exports = {\n  checkedNodeCall,\n  delayed,\n  filter,\n  finally: thenFinally,\n  fullyResolved,\n  isPromise,\n  map\n};","map":{"version":3,"names":["isObject","isPromise","require","delayed","ms","Promise","resolve","setTimeout","checkedNodeCall","fn","_len","arguments","length","args","Array","_key","fulfill","reject","error","value","ex","thenFinally","promise","callback","e","map","array","self","undefined","v","isArray","TypeError","arr","values","index","item","entries","push","call","filter","isConditionTrue","fullyResolved","fullyResolveKeys","obj","numKeys","Object","keys","forEachProperty","key","forEachElement","i","forEachKey","partialValue","module","exports","finally"],"sources":["/Users/Shared/ATS Git/ATSDemo/ReactJs/ReactCaseStudy/my-app/node_modules/selenium-webdriver/lib/promise.js"],"sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines a handful of utility functions to simplify working\n * with promises.\n */\n\n'use strict'\n\nconst { isObject, isPromise } = require('./util')\n\n/**\n * Creates a promise that will be resolved at a set time in the future.\n * @param {number} ms The amount of time, in milliseconds, to wait before\n *     resolving the promise.\n * @return {!Promise<void>} The promise.\n */\nfunction delayed(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms))\n}\n\n/**\n * Wraps a function that expects a node-style callback as its final\n * argument. This callback expects two arguments: an error value (which will be\n * null if the call succeeded), and the success value as the second argument.\n * The callback will the resolve or reject the returned promise, based on its\n * arguments.\n * @param {!Function} fn The function to wrap.\n * @param {...?} args The arguments to apply to the function, excluding the\n *     final callback.\n * @return {!Thenable} A promise that will be resolved with the\n *     result of the provided function's callback.\n */\nfunction checkedNodeCall(fn, ...args) {\n  return new Promise(function (fulfill, reject) {\n    try {\n      fn(...args, function (error, value) {\n        error ? reject(error) : fulfill(value)\n      })\n    } catch (ex) {\n      reject(ex)\n    }\n  })\n}\n\n/**\n * Registers a listener to invoke when a promise is resolved, regardless\n * of whether the promise's value was successfully computed. This function\n * is synonymous with the {@code finally} clause in a synchronous API:\n *\n *     // Synchronous API:\n *     try {\n *       doSynchronousWork();\n *     } finally {\n *       cleanUp();\n *     }\n *\n *     // Asynchronous promise API:\n *     doAsynchronousWork().finally(cleanUp);\n *\n * __Note:__ similar to the {@code finally} clause, if the registered\n * callback returns a rejected promise or throws an error, it will silently\n * replace the rejection error (if any) from this promise:\n *\n *     try {\n *       throw Error('one');\n *     } finally {\n *       throw Error('two');  // Hides Error: one\n *     }\n *\n *     let p = Promise.reject(Error('one'));\n *     promise.finally(p, function() {\n *       throw Error('two');  // Hides Error: one\n *     });\n *\n * @param {!IThenable<?>} promise The promise to add the listener to.\n * @param {function(): (R|IThenable<R>)} callback The function to call when\n *     the promise is resolved.\n * @return {!Promise<R>} A promise that will be resolved with the callback\n *     result.\n * @template R\n */\nasync function thenFinally(promise, callback) {\n  try {\n    await Promise.resolve(promise)\n    return callback()\n  } catch (e) {\n    await callback()\n    throw e\n  }\n}\n\n/**\n * Calls a function for each element in an array and inserts the result into a\n * new array, which is used as the fulfillment value of the promise returned\n * by this function.\n *\n * If the return value of the mapping function is a promise, this function\n * will wait for it to be fulfilled before inserting it into the new array.\n *\n * If the mapping function throws or returns a rejected promise, the\n * promise returned by this function will be rejected with the same reason.\n * Only the first failure will be reported; all subsequent errors will be\n * silently ignored.\n *\n * @param {!(Array<TYPE>|IThenable<!Array<TYPE>>)} array The array to iterate\n *     over, or a promise that will resolve to said array.\n * @param {function(this: SELF, TYPE, number, !Array<TYPE>): ?} fn The\n *     function to call for each element in the array. This function should\n *     expect three arguments (the element, the index, and the array itself.\n * @param {SELF=} self The object to be used as the value of 'this' within `fn`.\n * @template TYPE, SELF\n */\nasync function map(array, fn, self = undefined) {\n  const v = await Promise.resolve(array)\n  if (!Array.isArray(v)) {\n    throw TypeError('not an array')\n  }\n\n  const arr = /** @type {!Array} */ (v)\n  const values = []\n\n  for (const [index, item] of arr.entries()) {\n    values.push(await Promise.resolve(fn.call(self, item, index, arr)))\n  }\n\n  return values\n}\n\n/**\n * Calls a function for each element in an array, and if the function returns\n * true adds the element to a new array.\n *\n * If the return value of the filter function is a promise, this function\n * will wait for it to be fulfilled before determining whether to insert the\n * element into the new array.\n *\n * If the filter function throws or returns a rejected promise, the promise\n * returned by this function will be rejected with the same reason. Only the\n * first failure will be reported; all subsequent errors will be silently\n * ignored.\n *\n * @param {!(Array<TYPE>|IThenable<!Array<TYPE>>)} array The array to iterate\n *     over, or a promise that will resolve to said array.\n * @param {function(this: SELF, TYPE, number, !Array<TYPE>): (\n *             boolean|IThenable<boolean>)} fn The function\n *     to call for each element in the array.\n * @param {SELF=} self The object to be used as the value of 'this' within `fn`.\n * @template TYPE, SELF\n */\nasync function filter(array, fn, self = undefined) {\n  const v = await Promise.resolve(array)\n  if (!Array.isArray(v)) {\n    throw TypeError('not an array')\n  }\n\n  const arr = /** @type {!Array} */ (v)\n  const values = []\n\n  for (const [index, item] of arr.entries()) {\n    const isConditionTrue = await Promise.resolve(\n      fn.call(self, item, index, arr)\n    )\n    if (isConditionTrue) {\n      values.push(item)\n    }\n  }\n\n  return values\n}\n\n/**\n * Returns a promise that will be resolved with the input value in a\n * fully-resolved state. If the value is an array, each element will be fully\n * resolved. Likewise, if the value is an object, all keys will be fully\n * resolved. In both cases, all nested arrays and objects will also be\n * fully resolved.  All fields are resolved in place; the returned promise will\n * resolve on {@code value} and not a copy.\n *\n * Warning: This function makes no checks against objects that contain\n * cyclical references:\n *\n *     var value = {};\n *     value['self'] = value;\n *     promise.fullyResolved(value);  // Stack overflow.\n *\n * @param {*} value The value to fully resolve.\n * @return {!Thenable} A promise for a fully resolved version\n *     of the input value.\n */\nasync function fullyResolved(value) {\n  value = await Promise.resolve(value)\n  if (Array.isArray(value)) {\n    return fullyResolveKeys(/** @type {!Array} */ (value))\n  }\n\n  if (isObject(value)) {\n    return fullyResolveKeys(/** @type {!Object} */ (value))\n  }\n\n  if (typeof value === 'function') {\n    return fullyResolveKeys(/** @type {!Object} */ (value))\n  }\n\n  return value\n}\n\n/**\n * @param {!(Array|Object)} obj the object to resolve.\n * @return {!Thenable} A promise that will be resolved with the\n *     input object once all of its values have been fully resolved.\n */\nasync function fullyResolveKeys(obj) {\n  const isArray = Array.isArray(obj)\n  const numKeys = isArray ? obj.length : Object.keys(obj).length\n\n  if (!numKeys) {\n    return obj\n  }\n\n  async function forEachProperty(obj, fn) {\n    for (let key in obj) {\n      await fn(obj[key], key)\n    }\n  }\n\n  async function forEachElement(arr, fn) {\n    for (let i = 0; i < arr.length; i++) {\n      await fn(arr[i], i)\n    }\n  }\n\n  const forEachKey = isArray ? forEachElement : forEachProperty\n  await forEachKey(obj, async function (partialValue, key) {\n    if (\n      !Array.isArray(partialValue) &&\n      (!partialValue || typeof partialValue !== 'object')\n    ) {\n      return\n    }\n    obj[key] = await fullyResolved(partialValue)\n  })\n  return obj\n}\n\n// PUBLIC API\n\nmodule.exports = {\n  checkedNodeCall,\n  delayed,\n  filter,\n  finally: thenFinally,\n  fullyResolved,\n  isPromise,\n  map,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}